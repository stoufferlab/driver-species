\documentclass[a4paper,10pt]{article}
\usepackage[margin=22.5mm]{geometry}

% abstract + title + authors 
\usepackage{abstract}
\renewcommand{\abstractnamefont}{\normalfont\bfseries}
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} 
\usepackage{titlesec}
\usepackage{authblk}
\usepackage{datetime}
\newdateformat{usvardate}{
\monthname[\THEMONTH] \ordinal{DAY}, \THEYEAR}

% keywords
\providecommand{\keywords}[1]{\textbf{\textit{Keywords---}} #1}

% math
\usepackage{amssymb}
\usepackage{newtxmath}
\usepackage{xfrac}
 
% manuscript looking document
\usepackage{setspace}
\usepackage{lineno,xcolor}
\setlength{\parskip}{0.5em}

% comments
\usepackage[draft, textsize = scriptsize, color = gray]{todonotes}

% graphics
\usepackage{graphicx}
\usepackage{float}
\usepackage{sidecap}
\sidecaptionvpos{figure}{t}
\usepackage[font=small]{caption}
\usepackage{subfig}
\usepackage{caption}

% table
\usepackage{booktabs}

% box
\usepackage{tcolorbox}

% references & links
\usepackage[
backend=bibtex,
style= authoryear,
citestyle = authoryear,
url=false,
doi=true,
isbn=false
]{biblatex}
\addbibresource{references.bib}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    citecolor=magenta,
    linkcolor=magenta
}
\usepackage{doi}
\begin{document}
\renewcommand*{\bibfont}{\small}
% line numbers
\linenumbers
\setlength\linenumbersep{15pt}
\renewcommand\linenumberfont{\normalfont\footnotesize\sffamily\color{gray}}

\doublespacing
%\onehalfspacing

% title
% Article title
  \title{{\LARGE \textsc{Structural controlability of pollination networks}}}

% Authors and Affiliations
  \author{\large E. Fernando Cagua}
  \author{\large Kate L. Wootton}
  \author{\large Daniel B. Stouffer}
  \affil{\normalsize Center of Integrative Ecology, School of Biological Sciences, University of Canterbury}
 \date{}
 
\maketitle


<<libraries, echo = FALSE, warning = F, message = F>>=
library(magrittr)
library(knitr)
library(ggplot2)
library(glmulti)
library(Hmisc)
library(lme4)
opts_knit$set (root.dir=normalizePath('../'))
@

<<auxiliary functions, echo = FALSE, warning = F, message = F>>=
"./code/V2.0/functions" %>% 
	list.files(full.names = T) %>%
	plyr::l_ply(source)
@

<<plot theme, echo = FALSE, warning = F, message = F>>=
fer_theme <- theme_bw() +
	theme(text = element_text(family = "Times"),
	      title = element_text(size = 7.5, hjust = 0),
	      legend.title = element_text(size = 9),
	      legend.text = element_text(size = 8),
				axis.text = element_text(size = 8),
				axis.title = element_text(size = 9, hjust = 0.5), 
				strip.text = element_text(size = 9, hjust = 0), 
				strip.background = element_blank(),
				plot.margin = grid::unit(c(5, 0, 2, 0), "mm"))
@

<<read data and results, echo = FALSE, warning = F, message = F>>=
net <- "./data/V2.0/networks" %>%
	read_networks()
meta <- readr::read_csv("data/ntw_info.csv") %>% dplyr::tbl_df() %>%
	dplyr::rename(count = method)
n_matched <- readRDS("./data/V2.0/n_matched.rds")
a_m <- readRDS("./data/V2.0/n_matched_all_types.rds") 
r_w <- readRDS("./data/V2.0/random_weights.rds") %>% dplyr::tbl_df() %>%
  dplyr::rename_("net_name" = ".id")
r_d <- readRDS("./data/V2.0/random_directions.rds") %>% dplyr::tbl_df() %>%
  dplyr::rename_("net_name" = ".id")
s_p <- readRDS("./data/V2.0/species_properties.rds") %>% dplyr::tbl_df()
# mod <- readRDS("./data/V2.0/species_models.rds")
driver <- c("./data/V2.0/matching_frequency") %>% 
  list.files(full.names = T) %>%
  lapply(list.files, full.names = T) %>% 
  unlist() %>% 
  lapply(read_allRDS)
prop <- expand.grid(c("asymmetry", "max_dep"), 
                    c("scaled_FALSE", "scaled_TRUE")) %>% plyr::alply(1)
driver <- mapply(function(x, y){
  attr(x, "type") <- as.character(y[,1])
  attr(x, "scaled") <- stringr::str_split(as.character(y[,2]), "_") %>% unlist() %>% extract(2) %>% as.logical()
  return(x)
}, driver, prop)
driver_bi <- "./data/V2.0/matching_frequency_bi" %>% 
  read_allRDS()
mod <- readRDS("./data/V2.0/detailed_species_models.rds")
mo <- readRDS("./data/V2.0/detailed_species_models_data.rds")
@


\section*{Introduction}

\textit{Tentative spiel for the first paragraph:} We need to manage ecological communities because of ecosystem services and biodiversity maintenance. We would like to control communities in the sense of conserving and restoring them. However to control them (in that sense) we need to understand how species affect each other and potentially the whole system when they are faced by perturbations or management interventions. But we cannot do that yet because we lack a theoretical framework that link the dynamics of the community to management. Control theory might provide this link.

Seminal work on control theory has established a strong link between the structure of complex networks and its controlability and that in principle it is possible to alter any ecological community's composition, by modifying the abundances of just some key species \autocite{Liu2011, Cornelius2013}. Based on this work and using a small number of binary food-webs (only presence or absence of interactions), it has been suggested that the degree distribution of ecological networks makes them inherently difficult to control \autocite{Liu2011, Ruths2014}. This theoretical result is in agreement with many cases in which the management of ecological communities is more challenging than aticipated. In contrast with other types of complex systems like neural, intra-organizational, or trust neworks, ecological networks do not have a hierarchical or distributed structuretend but rather tend to be closed systems in which resources recirculate. As such, ecosystems contain multiple feedbacks that allow them to self-regulate and, therefore, function relatively independent from external stimulation\todo{add ref}. Although these conceptual advances on control theory have provided an initial link between the structure of ecological communities and our ability to manage them, this relationship is still ambiguous. Ultimately, the challenge of ecological networks is represented by the variablity of their structure and interaction strengths---which can vary by several orders of mangitude\todo{add ref}.

For instance, biotic invasions, as other major drivers of global change, can induce dramatic changes on the patterns of interactions that determine the structure of ecological networks \autocite{Baxter2004, Tylianakis2008, Ehrenfeld2010a}. These changes can be particularly pronounced in mutualistic networks of plants and pollinators where biotic invasions have been shown to modify the strength of species interactions and the degree of network nestedness and connectivity \autocite{Olesen2002, Aizen2008, Bartomeus2008, Vila2009, Traveset2013}. Moreover, as evidenced by the limited amount of success of restoration projects \autocite{Smith2016}, returning invaded communities to a predisturbance state is quite a difficult endeavour \autocite{Suding2004, Rodewald2015}. Understanding how invasion-induced differences in network structure impact our ability to manage them, can provide useful lessons to conservation science. What is more, there are also ecological insights to be had: by explicitly taking into account the extent to which changes in the abbundances of one species may ripple trough the community, applying control theory to ecological networks can provide an indication of which species are important from a dynamic perspective, and therefore crucial when attempting to alter (or maintain) the ecosystem state. 

\textcite{Isbell2013} used a control theoretic approach to find the minimum subset of species neccessary to maintain network structure in six marine food webs. They found that humans affect a larger proportion of this subset of species than, for instance, apex predators. They argue that this disproportionate influence could translate into unintentional restructuring of food webs. Although insightful, the scope and applicability of \textcite{Isbell2013} can be extended in numerous ways. First, although they find the size of this minimum set, they disregard the fact that the set species composition is not unique and thus not all species that might be included are equally important for the community population dynamics. Second, their methods were naive to differences on the strength of interspecific effects. And third, their approach was conceptually limited to trophic interactions\todo{is this too harsh?}. 

Here, we expand previous theory of the control of complex systems and use a set of paired invaded and uninvaded plant-pollinator communities to investigate the link between network structure and our ability to manage them. Plant-pollinator networks provide an ideal framework to answer these questions. On one hand, community networks that quantify relative levels of interaction are readily available. On the other, the bipartite nature of pollination networks makes it is possible to simplify assumptions of how these interactions translate into interspecific effects. Our theoretical extension of network control, allow us to ask the question of whether biotic invasions as drivers of change in network structure increasses or decreasses the manageability of communities as well as the relative importance of species at driving the population dynamics of other species in the community. \todo{punchy line to finish here?}.



\section*{Theory of community manageability}

\subsection*{Maximum matching}

The number of nodes necessary to fully control a complex network can be calculated by counting the number of unmatched nodes in the network's maximum matching \autocite{Liu2011}. In a directed network a matching is a subset of links in which no two links share a common starting node or a common ending node; a node is matched if it is the ending node of one of the links in the matching (\autoref{fig:explain_mm}a). A matching is then maximum if \textit{(i)} the number of matched liks---also known as matching size---is maximal and \textit{(ii)} the sum of the weights of the matched links---known as matching weight---is the largest possible among all possible matchings \autocite{West2001}. To find the maximum matching we used an alternative bipartite representation of the network in which the two levels indicate the outgoing and incoming links to each node (\autoref{fig:explain_mm}b). Finding a matching in this alternative representation is equivalent to finding the set of links such that each node on the top level is matched to at most one node on the bottom level, and vice versa \autocite{West2001, Csardi2006a}.  

\begin{figure}
\centering
<<fig explain mm, echo = FALSE, warning = F, message = F, results = "asis", fig.height=1.6, fig.width=6.2>>=

sp_names <- c("a[1]", "a[2]", "a[3]", "p[1]", "p[2]")

adj_matrix <- c(0,0,0,1,0,
								0,0,0,1,1,
								0,0,0,0,0,
								0,0,1,0,0,
								0,0,1,0,0) %>%
	matrix(nrow = 5, byrow = T) %>%
	`rownames<-`(sp_names) %>%
	`colnames<-`(sp_names)

net <- adj_matrix %>% 
	igraph::graph_from_adjacency_matrix(mode = "directed") 
igraph::V(net)$type <- c(F, F, F, T, T)
igraph::E(net)$weight <- 1

layoutCoordinates <- cbind(c(0,1,2,0.5,1.5), 
													 c(1,1,1,0,0)) %>%
	`colnames<-`(c("x", "y"))

adj_list <- adj_matrix %>% 
	reshape2::melt() %>% 
	dplyr::filter(value > 0)

# Generate an edge path for each pair of connected nodes
n <- 17
allEdges <- lapply(1:nrow(adj_list), edgeMaker, len = n, curved = FALSE)
allEdges <- do.call(rbind, allEdges) %>%
	dplyr::filter(Sequence != n) %>%
	dplyr::mutate(Group = factor(Group),
				 type = Group)

new_lev <- c("m", "u", "m", "m", "u")
levels(allEdges$type) <- new_lev

nodes <- data.frame(layoutCoordinates) %>%
	dplyr::mutate(spe = sp_names,
								spe_c = c("m", "m", "u", "m", "u"), 
								pos = rep(c(0.3, -0.3), c(3,2)))

p1 <- ggplot(allEdges) +  # Pretty simple plot code
	geom_path(aes(x = x, y = y, group = Group, colour = type, size = type), 
						arrow = arrow(type = "closed", angle = 15, length = grid::unit(0.1, "inches"))) + # and taper
	geom_point(data = nodes,  # Add nodes
						 aes(x = x, y = y , fill = spe_c), size = 5, pch = 21,
						 colour = "black") + 
	geom_text(data = nodes, aes(x = x, y = y + pos, label = spe), size = 3, parse = T, family = "Times") +
	scale_fill_manual(values = c("#636363", "white")) + 
	scale_colour_manual(values = c("#636363", "#bdbdbd")) +
	my_theme + xlab("") + ylab("") + 
  	xlim(c(-0.09, 2.09)) + ylim(c(-0.48, 1.48)) +
 theme(plot.margin=unit(c(4,4,-4,-4),"mm")) +
	scale_size_manual(values = c(0.5, 0.5)) +
  ggtitle("a) directed network")
	
net <- digraph_bipartite(net)
adj_matrix <- net %>% igraph::as_adjacency_matrix(sparse = F, type = "upper")
layoutCoordinates <- cbind(rep(0:4, 2), rep(c(1,0), each = 5)) %>%
	`colnames<-`(c("x", "y"))

adj_list <- adj_matrix %>% 
	reshape2::melt() %>% 
	dplyr::filter(value > 0)

# Generate an edge path for each pair of connected nodes
n <- 100
allEdges <- lapply(1:nrow(adj_list), edgeMaker, len = n, curved = FALSE)
allEdges <- do.call(rbind, allEdges) %>%
	dplyr::filter(Sequence != n,
								Sequence != 1) %>%
	dplyr::mutate(Group = factor(Group),
				 type = Group)

new_lev <- c("m", "m", "u", "m", "u")
levels(allEdges$type) <- new_lev

nodes <- data.frame(layoutCoordinates) %>%
	dplyr::mutate(spe = rep(sp_names, 2),
								spe_l = c(paste0(sp_names, " %->% phantom(0)"), paste0(sp_names, " %<-% phantom(0)")),
								spe_c = c(c("m", "m", "u", "m", "u"), rep("u",5)), 
								pos = rep(c(0.3, -0.3), each = 5))

p2 <- ggplot(allEdges) +  # Pretty simple plot code
	geom_path(aes(x = x, y = y, group = Group, colour = type, size = type)) + # and taper
	geom_point(data = nodes,  # Add nodes
						 aes(x = x, y = y, fill = spe_c), size = 5, pch = 21,
						 colour = "black") + 
	geom_text(data = nodes, aes(x = x + 0.08, y = y + pos, label = spe_l), parse = T, size = 3, family = "Times") +
	# coord_flip()  + scale_x_reverse() + scale_y_reverse() +
	scale_fill_manual(values = c("#636363", "white")) + 
	scale_colour_manual(values = c("#636363", "#bdbdbd")) +
	xlim(c(-0.12, 4.12)) + ylim(c(-0.48, 1.48)) +
	my_theme + xlab("") + ylab("") +
	scale_size_manual(values = c(0.5, 0.5)) +
  ggtitle("b) alternative bipartite representation")

multiplot(p1, p2, layout = matrix(nrow = 1, c(1,1,1,2,2,2,2,2)))
@
\caption{\label{fig:explain_mm}  One of the possible maximum matchings of a network (dark grey links) defines a set matched ($p_1$, $p_2$, and $a_3$) and unmatched nodes ($a_1$ and $a_2$). The minimum number of species neccessary to control this network equates to the number of unmatched nodes $n_d = 2$. Superior nodes (dark grey circles) drive the dynamics of other species and are therefore important for the controlability of the network because they either require external input or because the are part of the chain that transmit the external imputs to other species.}
\end{figure}

Given a maximum matching, the link to network controllability has a relatively straightforward and intuitive basis. In control theory, a network is fully controlable when each node has a "superior", this is, an input that drives its dynamics. Matched nodes can thus be controled by the node pointing to it---its superior. Unmatched nodes on the other hand, have no superior in the network and must be directly controlled by external inputs \autocite{Liu2011}. In an ecological context, this is what we refer to as management interventions.

Systems that require a large number of external inputs are more difficult or costly to control. The \textit{manageability} of a community $m$ is therefore determined by the proportion $n_d$ of species on which we would need to apply management interventions in order to gain full control of the abundances of all species in the ecological community, $$m = 1- \frac{n_d}{s},$$ where $s$ is the total number of species in the community.

\subsection*{Weighting links}

Recall that our maximum matching algorithm requires a directed network in which a link between species $i$ and $j$ pointing to species $j$ indicates that the abundance of $j$ can be affected by the abundance of $i$. In ecological networks, establishing a directionality for the links between species is relatively straightforward when they represent resources or energy flow, however, interspecific effects---particularly in pollination networks---are not strictly directed. Nevertheless, the extent to which a pair of interacting species affect each other can be quantified by the magnitude of the mutual dependence \autocite{Bascompte2006}. As the dependencies are bidirectional, this assumption renders a bipartite network in which interacting pairs are connected by two directed links (\autoref{fig:explain_cd}b).

\begin{figure}
\centering
<<fig explain control direction, echo = FALSE, warning = F, message = F, results = "asis", fig.height=1.5, fig.width=6.2>>=
sp_names <- c("a[1]", "a[2]", "a[3]", "p[1]", "p[2]")

adj_matrix <- c(0,0,0,0,0,
								0,0,0,0,1,
								0,0,0,0,0,
								1,1,1,0,0, 
								0,0,1,0,0) %>%
	matrix(nrow = 5, byrow = T) %>%
	`rownames<-`(sp_names) %>%
	`colnames<-`(sp_names)

net <- adj_matrix %>% 
	igraph::graph_from_adjacency_matrix(mode = "directed") 
igraph::V(net)$type <- c(F, F, F, T, T)
igraph::E(net)$weight <- 1

layoutCoordinates <- cbind(c(0,1,2,0.5,1.5), 
													 c(1,1,1,0,0)) %>%
	`colnames<-`(c("x", "y"))

adj_list <- adj_matrix %>% 
	reshape2::melt() %>% 
	dplyr::filter(value > 0)

# Generate an edge path for each pair of connected nodes
n <- 17
allEdges <- lapply(1:nrow(adj_list), edgeMaker, len = n, curved = FALSE)
allEdges <- do.call(rbind, allEdges) %>%
	dplyr::filter(Sequence != n) %>%
	dplyr::mutate(Group = factor(Group),
				 type = Group)

new_lev <- c("m", "u", "m", "m", "u")
levels(allEdges$type) <- new_lev

nodes <- data.frame(layoutCoordinates) %>%
	dplyr::mutate(spe = sp_names,
								spe_c = c("m", "m", "u", "m", "u"), 
								pos = rep(c(0.3, -0.3), c(3,2)))

weights <- allEdges %>%
  dplyr::filter(Sequence == 12) %>%
  dplyr::mutate(weight = c(1, 2, 1, 1, 2))

p1 <- ggplot(allEdges) +  # Pretty simple plot code
	geom_path(aes(x = x, y = y, group = Group, size = type), colour = "#bdbdbd") + # and taper
	geom_point(data = nodes,  # Add nodes
						 aes(x = x, y = y ), size = 5, pch = 21,
						 colour = "black", fill = "white") + 
	# geom_text(data = nodes, aes(x = x, y = y + pos, label = spe), size = 3, parse = T, family = "Times") +
  geom_point(data = weights, aes(x = x, y= y), size = 2.5, alpha = 0.25, colour = "white") +
  geom_text(data = weights, aes(x = x, y= y, label = weight), size = 2.5, family = "Times") +
	scale_fill_manual(values = c("#636363", "white")) + 
	scale_colour_manual(values = c("#636363", "#bdbdbd")) +
	my_theme + xlab("") + ylab("") + 
  	xlim(c(-0.09, 2.09)) + ylim(c(-0.15, 1.15)) +
 theme(plot.margin=unit(c(4,4,-4,-4),"mm")) +
	scale_size_manual(values = c(0.5, 0.5)) +
  ggtitle("a) visitation frequency")

############################
sp_names <- c("a[1]", "a[2]", "a[3]", "p[1]", "p[2]")

adj_matrix <- c(0,0,0,1,0,
								0,0,0,1,1,
								0,0,0,1,1,
								1,1,1,0,0,
								0,1,1,0,0) %>%
	matrix(nrow = 5, byrow = T) %>%
	`rownames<-`(sp_names) %>%
	`colnames<-`(sp_names)

net_exp <- adj_matrix %>% 
	igraph::graph_from_adjacency_matrix(mode = "directed") 
igraph::V(net_exp)$type <- c(F, F, F, T, T)
igraph::E(net_exp)$weight <- 1

layoutCoordinates <- cbind(c(0,1,2,0.5,1.5), 
													 c(1,1,1,0,0)) %>%
	`colnames<-`(c("x", "y"))

adj_list <- adj_matrix %>% 
	reshape2::melt() %>% 
	dplyr::filter(value > 0)

# Generate an edge path for each pair of connected nodes
n <- 17
allEdges <- lapply(1:nrow(adj_list), edgeMaker, len = n, curved = FALSE)
allEdges <- do.call(rbind, allEdges) %>%
	dplyr::filter(Sequence != n) %>%
	dplyr::mutate(Group = factor(Group),
				 type = Group)

new_lev <- c("m", "u", "m", "u", "u", "u", "m", "u", "u", "m")
dir <- c("m", "m", "m", "m", "m", "u", "u", "u", "u", "u")
dir2 <- c("m", "u", "m", "u", "u", "u", "m", "m", "u", "m")
id <- 1:10
allEdges %<>% dplyr::mutate(dir = type,
                            dir2 = dir)
levels(allEdges$type) <- new_lev
levels(allEdges$dir) <- dir
levels(allEdges$dir2) <- dir2
allEdges %<>% 
  dplyr::mutate(dir = as.numeric(dir),
                dir2 = as.numeric(dir2),
                dir = plyr::mapvalues(dir, c(1,2), c(0.03, -0.03)),
                dir2 = plyr::mapvalues(dir2, c(1,2), c(0.03, -0.03)))

nodes <- data.frame(layoutCoordinates) %>%
	dplyr::mutate(spe = sp_names,
								spe_c = c("u", "m", "m", "m", "m"), 
								pos = rep(c(0.3, -0.3), c(3,2)))

# ggplot(allEdges) +  # Pretty simple plot code
# 	geom_path(aes(x = x + dir, y = y + dir2, group = Group, colour = type, size = type), 
# 						arrow = arrow(type = "closed", angle = 15, length = grid::unit(0.1, "inches")))

weights <- allEdges %>%
  dplyr::filter(Sequence == 12) %>%
  dplyr::mutate(weight = c("1", "0.5", "0.5", "0.5", "0.5", "0.25", "0.5", "0.25", "0.66", "0.33"))

p2 <- ggplot(allEdges) +  # Pretty simple plot code
	geom_path(aes(x = x + dir, y = y + dir2, group = Group, size = type), 
						arrow = arrow(type = "closed", angle = 15, length = grid::unit(0.1, "inches")), colour = "#bdbdbd") + # and taper
	geom_point(data = nodes,  # Add nodes
						 aes(x = x, y = y ), size = 5, pch = 21,
						 colour = "black", fill = "white") +  
	# geom_text(data = nodes, aes(x = x, y = y + pos, label = spe), size = 3, parse = T, family = "Times") +
  geom_point(data = weights, aes(x = x + dir*3, y= y), size = 2.5, alpha = 0.25, colour = "white") +
  geom_text(data = weights, aes(x = x + dir*3, y= y, label = weight), size = 2.5, family = "Times", parse = T) +
	scale_fill_manual(values = c("#636363", "white")) + 
	scale_colour_manual(values = c("#636363", "#bdbdbd")) +
	my_theme + xlab("") + ylab("") + 
  xlim(c(-0.09, 2.09)) + ylim(c(-0.15, 1.15)) +
 theme(plot.margin=unit(c(4,4,-4,-4),"mm")) +
	scale_size_manual(values = c(0.5, 0.5)) +
  ggtitle("b) mutual dependence")

####################################

sp_names <- c("a[1]", "a[2]", "a[3]", "p[1]", "p[2]")

adj_matrix <- c(0,0,0,0,0,
								0,0,0,1,1,
								0,0,0,0,0,
								1,1,1,0,0,
								0,0,1,0,0) %>%
	matrix(nrow = 5, byrow = T) %>%
	`rownames<-`(sp_names) %>%
	`colnames<-`(sp_names)

net <- adj_matrix %>% 
	igraph::graph_from_adjacency_matrix(mode = "directed") 
igraph::V(net)$type <- c(F, F, F, T, T)
igraph::E(net)$weight <- 1

layoutCoordinates <- cbind(c(0,1,2,0.5,1.5), 
													 c(1,1,1,0,0)) %>%
	`colnames<-`(c("x", "y"))

adj_list <- adj_matrix %>% 
	reshape2::melt() %>% 
	dplyr::filter(value > 0)

# Generate an edge path for each pair of connected nodes
n <- 17
allEdges <- lapply(1:nrow(adj_list), edgeMaker, len = n, curved = FALSE)
allEdges <- do.call(rbind, allEdges) %>%
	dplyr::filter(Sequence != n) %>%
	dplyr::mutate(Group = factor(Group),
				 type = Group)

# new_lev <- c("m", "u", "m", "m", "u")
# levels(allEdges$type) <- new_lev

nodes <- data.frame(layoutCoordinates) %>%
	dplyr::mutate(spe = sp_names,
								# spe_c = c("m", "m", "u", "m", "u"), 
								pos = rep(c(0.3, -0.3), c(3,2)))

weights <- allEdges %>%
  dplyr::filter(Sequence == 12) %>%
  dplyr::mutate(weight = c(0.75, 1, 0.5, 0.6, 1, 0.16)) 

p3 <- ggplot(allEdges) +  # Pretty simple plot code
	geom_path(aes(x = x, y = y, group = Group), size = 0.5,
						arrow = arrow(type = "closed", angle = 15, length = grid::unit(0.1, "inches")), colour = "#bdbdbd") + # and taper
	geom_point(data = nodes,  # Add nodes
						 aes(x = x, y = y ), size = 5, pch = 21,
						 colour = "black", fill = "white") + 
	# geom_text(data = nodes, aes(x = x, y = y + pos, label = spe), size = 3, parse = T, family = "Times") +
   geom_point(data = weights, aes(x = x, y= y), size = 2.5, alpha = 0.25, colour = "white") +
  geom_text(data = weights, aes(x = x, y= y, label = weight), size = 2.5, family = "Times") +
	scale_fill_manual(values = c("#636363", "white")) + 
	scale_colour_manual(values = c("#636363", "#bdbdbd")) +
	my_theme + xlab("") + ylab("") + 
  	xlim(c(-0.09, 2.09)) + ylim(c(-0.15, 1.15)) +
 theme(plot.margin=unit(c(4,4,-4,-4),"mm")) +
	# scale_size_manual(values = c(0.5, 0.5)) +
  ggtitle("c) interaction asymmetry")


###########################

multiplot(p1, p2, p3, cols = 3)

@
\caption{\label{fig:explain_cd} Mutualistic networks are usually described quantitatively by the relative number of visits between each plant and animal species (a). The mutual dependencies between interacting species (b) depend directly on the relative visitation frequency. The dependency of plant $i$ on pollinator $j$, $d_{ij}$, is the proportion of the visits coming from pollinator $j$ compared to all pollinator visits to plant $i$. Likewise, the dependency of pollinator $j$ on plant $i$, $d_{ji}$, is the ratio of the visits by pollinator $j$ to plant $i$ and all visits of pollinator $j$. Nevertheless, mutual dependencies in pollination networks tend to be highly assymetric. The relative differences of dependencies (c) then is a good indicator  }
\end{figure}

Nevertheless, mutual dependencies have been shown to be highly assymetric in natural communities \autocite{Bascompte2006}. In other words, if a plant species is largely dependent on a pollinator species, then the pollinator tends to depend only very weakly on the plant. This suggest that it may be possible to relax our initial assumption and simplify the network such that interacting species are connected by one directed link when mutual dependencies are highly assymetric (\autoref{fig:explain_cd}c). The extent to which a species $i$ affects species $j$ relative to the extent to which species $j$ affects species $i$ can then be summarised by the interaction asymmetry.

$$a(i,j) = \frac{\left | d_{ij}-d_{ji} \right |}{\textup{max}\left ( d_{ij}, d_{ji} \right )}$$

\subsection*{Relative species importance}

\todo[inline]{insert ecological motivation?}

The manageability of a community $m$ provides an indication of the magnitude of $n_d$ but not the identity of the species that compose this set. Moreover, maximum matchings are often not unique in for a given network and different sets of species of size $n_d$ could be used to control the network \autocite{Liu2011}. Species vary in terms of the frequency with which they are classified as superior nodes (\autoref{fig:explain_mm}), and this frequency provides an indication of their relative importance in driving the state of the community. 

We therefore call \textit{driver species} those that are identified as being a superior node in all\todo{check}  possible matchings, and consequently likely to have a disproportionate effect on the abbundances of other species in the community. Unlike unweighted networks, where a maximum matching is defined by its matching size (the number of matching links), a maximum matching in a weighted network is one whose links have the largest possible total weight among all possible matchings. This means that in weighted networks there is a number of matchings that have maximal size, but are not maximum matchings because their total weight is not maximal.

Consequently, we identified the driver species in each of the networks by computing all possible matchings in the network that have the same maximal size while allowing for some tolerance regarding the weight. We relax the matching weight requirement because empirical intreaction strengths, from which we calculate dependencies, are stochastic to some extent and depend on the sampling method and intensity. To compute all the matchings with maximal size, we first generated the network's line graph---an alternative representation in which nodes are the interactions of the original network and links represent common ending points. We then calculated the complement of the line graph---a graph in which nodes are adjacent if and only if they are not adjacent in the line graph. All possible maximum matchings can be found by enumerating all cliques of size $1-n_d$ in this complement graph \autocite{West2001, Csardi2006a}. 

\section*{Methods}

In the last section we outlined the theoretical and computational underpinings of our approach. Now we illustrate its empirical application using ten pairs of plant-pollinator communities for which we calculated their manageability and the relative importance of species. Each network pair was composed by a community invaded by a plant and a community effectively free of the invasive species (Table S1). The networks were constructed from previously published visitation data collected from pollination communities in Bristol, UK \autocite{Lopezaraiza-Mikel2007} and in Cap de Creus National Park, Spain \autocite{Bartomeus2008}. In the four British uninvaded communities, the non-invaded plots were obtained by experimentally removing all the flowers of the invasive species \textit{Impatients grandulifera}. In contrast, the Spanish uninvaded communities were obtained from plots that had not yet been colonised by either of the invasive species \textit{Carpobrotus affine acinaciformis} or \textit{Opuntia stricta}. The structure of these networks was determined using visitation frequency which has been shown to be an appropriate surrogate for inter-specific effects in pollination networks \autocite{Vazquez2005, Bascompte2006}. To examine the importance of this decision, we also evaluated the effect of using pollinator efficiency or importance as alternative measures of species interactions \autocite{NeEman2010, Ballantyne2015}, and we found consistent results for all of these options(see Supplementary Information).

\subsection*{Community manageability}

We started by quantifying the manageability of the analysed pollination communities. To do that, we calculated the maximum matching of the corresponding pollination network, and estimated the minimum number of species that need directed intervecntions to fully control the species abbundances in the community. If a network had more than one component (two species are in different components if there exist no path between them) we analysed the largest one. Although understanding the distribution of manageability across ecological networks is an useful result in itself, we wanted to test wheter perturbations, like invasion status, have an impact on manageability values. As, naively one might expect to see a negative relationship between diversity and manageability \autocite{Menge1995}, we used a set of generalised linear models to investigate the effect of invasion status while controling for \textit{(i)} the total number of species, \textit{(ii)} plant richness, \textit{(iii)} polinators richness, \textit{(iv)} the ratio of plants to pollinators richness, and \textit{(v)} the study site. Competing models were assessed by comparing the Akaike Information Criterion corrected for small sample sizes (AICc).

Subsequently we explored the extent to which structural factors in the empirical networks influence their manageability. Previous studies found a direct link between a network's degree distribution and the number of nodes necessary to fully control it \autocite{Liu2011}, but this relationship has not been explored in weighted ecological networks. We therefore compared the manageability of the empirical networks to networks generated by three null models. One set of random visitation networks was generated by maintaining each species' degree (its number of interactions) while varying the number of visits per species. A second set of random networks mantained the species' strength (its total sum of visits) while varying their degrees. Randomisations were generated using vegan 2.3-3 \autocite{Oksansen2016}. Finally a three set of fully random networks maintained only the connectivity of the empirical network, but both degree and weight were allowed to vary. We then calculated the mutual dependences and interaction asymmetries of the random networks and calculated their manageability using the maximum matching algorithm. Finally we calculated the p-value of the manageability of each empirical network and the corresponding manageability of 999 randomisations.

The dependency asymetry plays a fundamental role in determining the direction of control in a two species interaction and therefore has the potential to structure the network matching. We therefore performed an additional randomisation in which we mantained the structure of network but randomised the direction of the interaction asymmetries. This is, we first calculated the assymetries for each community and then shuffled the direction of the link between species. Similar as in previouls null models, we calculated the p-value of the empirical manageability compared to that of the randomisations.

\subsection*{Relative importance of species}

Our third question is related to how different species differ on their importance for the population dynamics of the community. To quantify this importance we computed all possible matchings that have the same size as the maximum matchings and in each network. We then calculated the frequency to which each species is deemed to be a superior node in matchings with a weight equal or larger to 0.5 times the weight of the maximum matchings. We choose this threshold as it provided a high agreement between the relative importance of species calculated by weighting interactions with the mutial dependencies or the depndence asymmetry as well as between the network is quantified by visitation or pollination efficiency. Nevertheless, the choice of the threshold only had a negligible impact on the results (Supplementary information). 

The number of maximal matchings increasses exponentially with the number of links and nodes in a network. When we use mutual dependecies, the large number of links in the most diverse communities renders the computation unfeasible. Taking this limitation into account we compared the relative network manageability obtained when using assimetries or when using mutual dependencies for eleven networks---for which the number of matchings was smaller than $4\times 10^{10}$. Results from a paired Spearman correlation test, the weighted correlation coefficient $r_{w2}$---which gives more weight to higer ranks \autocite{PintoDaCosta2015}, and the Jaccard similarity of the driver species in both approaches, suggested a high similarity in relative ranks. Therefore, we used the results from the assymetries, rather than mutiual dependences, to further investigate the factors that determine species' relative importance.

We then asked the question of whether some species-level structural properties can predict the relative importance of species. Here, we used a Generalised Linear Mixed-Effects model to evaluate the effect on the species' relative importance of a suite of structural measures. We included measures of centrality (degree and eigen-centrality) which have been found to be strong predictors of importance in a coextintion context\todo{add ref}; measures related to network robustness (contribution to nestedness) as nestedness has been proposed as one of the key properties that promote stability in mutualistic networks \autocite{Saavedra2011}; and measures of strength of association and depedency (visitation and dependency strength) as their skewed distribution is characteristic of plant-pollinator networks and determine the extent of interspecific effects. All metrics were calculated using bipartite 2.06 \autocite{Dormann2008}. To allow for variation among different ecological communities, this factor was included as a random effect \autocite{Bates2015a}. Candidate models were compared using AIC and the relative importance of the explanatory variables was evaluated using the sum of Akaike weights over candidate models that accounted for 95\% of the evidence \autocite{Burnham2003, Bates2014, Barton2016}. 

Invasive species have been shown to have disproportionate effects on the communities they invade. So we examined the extent to which invasive species tend to be driver species---species whith the maximum importance. As our invasive species were plants, we compared the relative importance of invasive species to those of other plants in the community and to which degree they differ when accounting for the structural factors that determine their importance\todo{needs to be developed once the results section is rewritten}. 

All analysis were performed in R 3.2.2 \autocite{RCoreTeam2015}.

\section*{Results}

\subsection*{Manageability}

<<n_driver, echo = FALSE, warning = F, message = F>>=
# find n_driver
n_driver <- a_m %>%
  dplyr::inner_join(meta) %>%
  dplyr::filter(count == "visitation") %>%
  dplyr::mutate(n_sp = n_pla + n_pol, 
                n_dr = n_sp - n_matched,
                n_dr_p = n_dr / n_sp)

src_bi_w <- n_driver %>%
  dplyr::filter(type == "z-bi" | type == "weight",
                study != "ballantyne") %>%
  dplyr::select(net_name, type, n_dr_p) %>%
  tidyr::spread(type, n_dr_p) %$%
  cor.test(weight, `z-bi`, method = "spearman")

# # Wilcoxon signed rank test invasive vs non invasive
# wt <- n_driver %>%
#   dplyr::select(site, inv, n_dr_p) %>%
#   dplyr::filter(!is.na(inv)) %>%
#   dplyr::mutate(n_dr_p = qlogis(n_dr_p)) %>%
#   tidyr::spread(inv, n_dr_p) %>%
#   dplyr::select(-site) %>%
#   as.matrix()
n_driver %<>%
  dplyr::filter(!is.na(inv))
# wt <-  wilcox.test(x = wt[, 1], y = wt[, 2], paired = T)


n_driver_wb <- dplyr::filter(n_driver, 
                             type == "z-bi" | type == "weight")

# Models
m0 <- glm(cbind(n_dr, n_matched) ~ n_pla * n_pol + study + inv + type,
          data = n_driver_wb,
          family = "binomial")
m_nr <- glm(cbind(n_dr, n_matched) ~ I(n_pla/n_pol) + study + inv + type,
          data = n_driver_wb,
          family = "binomial")
m8 <- glm(cbind(n_dr, n_matched) ~ I(n_pla/n_pol) + inv + type,
          data = n_driver_wb,
          family = "binomial")
m9 <- glm(cbind(n_dr, n_matched) ~ I(n_pla/n_pol) + study + type,
          data = n_driver_wb,
          family = "binomial")
m1 <- glm(cbind(n_dr, n_matched) ~ I(n_pla/n_pol) + type,
          data = n_driver_wb,
          family = "binomial")
m2 <- glm(cbind(n_dr, n_matched) ~ study + type,
          data = n_driver_wb,
          family = "binomial")
m3 <- glm(cbind(n_dr, n_matched) ~ I(n_pla + n_pol) + type,
          data = n_driver_wb,
          family = "binomial")
m4 <- glm(cbind(n_dr, n_matched) ~ n_pla + type,
          data = n_driver_wb,
          family = "binomial")
m5 <- glm(cbind(n_dr, n_matched) ~ n_pol + type,
          data = n_driver_wb,
          family = "binomial")
m6 <- glm(cbind(n_dr, n_matched) ~ inv + type,
          data = n_driver_wb,
          family = "binomial")
m7 <- glm(cbind(n_dr, n_matched) ~ study + inv + type,
          data = n_driver_wb,
          family = "binomial")
@

We found that if we were to control the dynamics of the whole community, we would need to control between \Sexpr{round(min(dplyr::filter(n_driver, type == "z-bi")$n_dr_p)*100)} and \Sexpr{round(max(dplyr::filter(n_driver, type == "z-bi")$n_dr_p)*100)}\% (mean \Sexpr{round(mean(dplyr::filter(n_driver, type == "z-bi")$n_dr_p)*100)}\%) of the species in the community if we were to harness bidirectional links between species, and between \Sexpr{round(min(dplyr::filter(n_driver, type == "weight")$n_dr_p)*100)} and \Sexpr{round(max(dplyr::filter(n_driver, type == "weight")$n_dr_p)*100)}\% (mean \Sexpr{round(mean(dplyr::filter(n_driver, type == "weight")$n_dr_p)*100)}\%) if we only take into account the strongest dependence. This corresponds to manageabilities between \Sexpr{round(min(1-dplyr::filter(n_driver, type == "z-bi")$n_dr_p), digits = 2)} to \Sexpr{round(max(1-dplyr::filter(n_driver, type == "z-bi")$n_dr_p), digits = 2)} and \Sexpr{round(min(1-dplyr::filter(n_driver, type == "weight")$n_dr_p), digits = 2)} to \Sexpr{round(max(1-dplyr::filter(n_driver, type == "weight")$n_dr_p), digits = 2)} respectively (Table S1). Despite different absolute values of manageability between these assuptions, the relative manageability of different communities was mantained (Spearman rank correlation \Sexpr{round(src_bi_w$estimate, digits = 2)}, $p = \Sexpr{as.numeric(format(src_bi_w$p.value, digits = 2))}$). In addition, the ratio of plant to pollinator species richness is positively correlated with manageability ($Pr(>\chi^2) = \Sexpr{as.numeric(format(anova(m8, m6, test = "LRT")$`Pr(>Chi)`[2], digits = 2))}$). Similarly, invaded communities tend to be more difficult to manage than uninvaded ones ($Pr(>\chi^2) = \Sexpr{as.numeric(format(anova(m8, m1, test = "LRT")$`Pr(>Chi)`[2], digits = 2))}$). In constrast, measures of biodiversity (like plant or pollinator richness) or the location of the study did not have a significant effect on the manageability (\autoref{fig:n_driver_explanatory}, Table S3).  

\begin{figure}
\centering
<<fig explaining n_driver, echo = FALSE, warning = F, message = F, results = "asis", fig.height=2.2, fig.width=3.245>>=
p <- predict(m8, type = "response", se.fit = F)

n_driver_wb %>%
  dplyr::mutate(fit = predict(m8, type = "response", se.fit = T)$fit,
                se =  predict(m8, type = "response", se.fit = T)$se) %>%
  dplyr::filter(type == "z-bi" | type == "weight") %>% 
  ggplot(aes(x = n_pla/n_pol, y = 1-n_dr_p)) +
  geom_line(aes(y = 1-fit, colour = type, linetype = inv), size = 0.5) + 
  geom_point(aes(fill = type, shape = inv), show.legend = T, size = 1.25) +
  ylab("manegeability") + 
  xlab("plant / pollinator richness") +
  scale_fill_manual(values = c("#ffffff", "#bdbdbd"),
                      name = "direction of control", 
                      labels = c("asymmetry", "mutual dependence")) +
  scale_colour_manual(values = c("black", "#bdbdbd"),
                      name = "direction of control", 
                      labels = c("asymmetry", "mutual dependence")) + 
  scale_shape_manual(values = c(21, 23), 
                     name = "invasion status", 
                     labels = c("invaded", "non invaded")) +
  scale_linetype_manual(values = c(1, 12), 
                        name = "invasion status", 
                        labels = c("invaded", "non invaded")) +
  fer_theme +
  theme(plot.margin = grid::unit(c(5, 1, 2, 0), "mm"), 
        legend.position = "none", 
        # legend.title = element_blank(),
        legend.key = element_rect(fill = "white", 
                                  colour = "white"),
        legend.key.size = grid::unit(4, "mm"),
        legend.background = element_rect(colour = "black", size = 0.2),
        legend.box = "horizontal",
        legend.direction = "vertical") 
@
\caption{\label{fig:n_driver_explanatory} The relative manageability of a plant-pollinator community is largely influenced by the ratio of plant to pollinator species richness and to a smaller extent to the status of invasion. Invaded communities (circles, dashed lines) having larger levels of manageability. White and grey points correspond to manageabilities calculated using mutual dependences and interaction asymmetry respectively.}
\end{figure}

<<randomisations z_scores, echo = FALSE, warning= FALSE, message = FALSE>>=
r <- r_w %>%
  dplyr::bind_rows(dplyr::mutate(r_d, type = "weight")) %>%
  dplyr::inner_join(meta) %>%
  dplyr::filter(study != "ballantyne") %>%
  dplyr::mutate(n_dr = n_pla + n_pol - n_matched)

# non-parametric
z_scores <- r$method %>%
  unique() %>%
  plyr::ldply(function(x){
    n_driver %>%
      dplyr::mutate(type = stringr::str_replace(type, "-", "_")) %>%
      dplyr::filter(type == "weight" | type == "z_bi") %>%
      dplyr::mutate(method = x)
  }) %>%
  dplyr::bind_rows(r) %>%
  dplyr::filter(!(type == "z_bi" & method == "r0")) %>%
  dplyr::group_by(net_name, method, type) %>%
  dplyr::mutate(z_r = rank(n_dr, na.last = NA),
                z_r = z_r/n(),
                z_s = qlogis(z_r),
                z_s = replace(z_s, (is.infinite(z_s) & z_s > 0) | z_s > qlogis(0.999), qlogis(0.999)),
                z_s = replace(z_s, is.infinite(z_s) & z_s < 0, qlogis(0.001))) %>%
  dplyr::filter(is.na(sim))

@

The manageability of empirical networks varied little when compared to network randomisations that maintained the species strength or species degree. This result is consistent regardless of whether we consider mutual dependences or the interaction asymmetry. Contrastingly, empirical networks have smaller manageabilities than network randomisations in which the direction of the dependencies is altered but the structure is maintained. 

\begin{figure}
\centering
<<fig randomisations, echo = FALSE, warning = F, message = F, fig.height=2.2, fig.width=3.245>>=

# z_scores <- r %>%
#   dplyr::group_by(net_name, method) %>%
#   dplyr::summarise(mu = mean(n_dr, na.rm = T),
#                    sigma = sd(n_dr, na.rm = T)) %>%
#   dplyr::inner_join(n_driver) %>%
#   dplyr::group_by() %>%
#   dplyr::mutate(z_s = (n_dr - mu)/sigma)

z_scores_method_order <- unique(z_scores$method)

z_scores %>%
  dplyr::group_by() %>%
  dplyr::mutate(method = factor(method, levels = z_scores_method_order),
                m_n = as.numeric(method),
                m_n = replace(m_n, m_n == 3, 3.5)) %>%
  ggplot(aes(x = method, y = -1 * z_s)) +
  geom_rect(aes(xmin = 0.5, xmax = 3.5, ymin = -Inf, ymax = qlogis(0.025)), fill = "#f0f0f0") +
  geom_rect(aes(xmin = 0.5, xmax = 3.5, ymin = Inf, ymax = qlogis(0.975)), fill = "#f0f0f0") +

  # geom_hline(yintercept = c(-0), linetype = 2, alpha = 0.7, size = 0.25) + 
  geom_vline(aes(xintercept = 2.5), alpha = 0.6, size = 0.25) +
   geom_hline(yintercept = 0, size = 0.25, linetype = 2, colour = "grey30") +
  geom_boxplot(aes(fill = type), size = 0.3,
               colour = "grey10", outlier.shape = 21, outlier.size = 1) +
  # geom_point(aes(y = 9, colour = sign <= 0.05), shape = 8, size = 1) +
  scale_fill_manual(values = c("white", "#bdbdbd")) +
  scale_x_discrete(labels = rev(c("random\nassymetry", "maintain vis. strength\nrandomise degree", "maintain vis. degree\nrandomise strength")), expand = c(0,0)) + 
  scale_y_continuous(breaks = qlogis(c(0.001, 0.025, 0.5, 0.975,0.999)), 
                     labels = plogis(qlogis(c(0.001, 0.025, 0.5, 0.975,0.999)))) + 
  xlab("") +
    coord_flip() +
  ylab("rank of empirical manageability") + 
  fer_theme +
  theme(
        legend.position = "none",
				plot.margin = grid::unit(c(2, 1, 2, 0), "mm"), 
				# panel.grid.minor.x = element_blank(),
				panel.grid.minor.y = element_blank())

@
\caption{\label{fig:randomisations} The manageability of empirical networks was compared to network randomisations using a normalised rank. The shaded areas in light grey ($< 0.025$ and $> 0.975$) suggest a significant difference between the empirical network and its randomisations. The empirical manageability is much smaller than those of randomisations in which the direction of assymmetries has been randomised. In contrast the manageability of network in which the visitation strength or degree was mantained was not different to the manageability of the empirical networks. Dark grey and white boxplots represent manageabilities obtained using mutual dependencies and asymmetries respectively.}
\end{figure}

\subsection*{Driver species}

<<rel importance, echo = FALSE, warning = F, message = F>>=
d_sp <- driver %>%
  plyr::ldply(function(x) {
    get_frequencies(x) %>%
      dplyr::mutate(type = attr(x, "type"),
                    scaled = attr(x, "scaled"))
  })

d_sp_bi <- driver_bi %>%
  get_frequencies() %>%
      dplyr::mutate(type = "z_bi",
                    scaled = FALSE)

d_sp <- dplyr::bind_rows(d_sp, d_sp_bi) %>%
  dplyr::inner_join(meta)
# d freq is the best proxy seems to be consistent with the invasive species being at the top rank for the bidirectional links
# d_sp %>%
#   dplyr::filter(inv, type == "z_bi") %>%
#   dplyr::group_by(net_name, threshold) %>% 
#   dplyr::mutate(d_freq_rank = rank(-d_freq, ties.method = "min")) %>%
#   dplyr::filter(species %in% c("p_4", "p_25"))
# 

correlations <- expand.grid(type = c("asymmetry", "max_dep"),
            scaled = c(TRUE, FALSE)) %>%
  plyr::ddply(c("type", "scaled"), function(x){
    d_sp %>%
      dplyr::filter(count == "visitation", 
                    study != "ballantyne") %>% 
      plyr::ddply(c("net_name", "threshold"), function(y){
        u <- y %>% 
          dplyr::filter(type == "z_bi" | 
                          (type == x$type & scaled == x$scaled)) %>%
          dplyr::group_by(type) %>%
          dplyr::mutate(d_freq_rank = rank(-d_reim)) %>%
          dplyr::select(species, type, d_freq_rank) %>%
          tidyr::spread(type, d_freq_rank) %>%
          `class<-`("data.frame")
        
        
        
        if(ncol(u) == 3) {
          a <- sets::as.set(u[u[, 2] == min(u[, 2]), 1])
          b <- sets::as.set(u[u[, 3] == min(u[, 3]), 1])
          c(rw2(u[,2], u[,3]), rw2(rank(-u[,2]), rank(-u[,3])), cor(u[,2], u[,3], method = "spearman"), sets::set_similarity(a, b))
        } 
        else c(NA, NA, NA, NA)
          
      })
  })

corr_imp <- expand.grid(type = c("asymmetry", "max_dep"),
            scaled = c(TRUE, FALSE)) %>%
  plyr::ddply(c("type", "scaled"), function(x){
    d_sp %>%
      dplyr::filter(study == "ballantyne") %>% 
      plyr::ddply(c("threshold"), function(y){
        u <- y %>% 
          dplyr::filter((type == "z_bi" & count == "importance") |
                          (type == x$type & scaled == x$scaled & count == "visitation")) %>%
          dplyr::group_by(type) %>%
          dplyr::mutate(d_freq_rank = rank(-d_reim)) %>%
          dplyr::select(species, type, d_freq_rank) %>%
          tidyr::spread(type, d_freq_rank) %>%
          `class<-`("data.frame")
        
        if(ncol(u) == 3) rw2(u[,2], u[,3])
        else NA
          
      })
  })

# correlations %>%
#   ggplot(aes(x = threshold, y = V1, colour = interaction(type, scaled))) +
#   geom_line(aes(linetype = net_name)) +
#   geom_smooth(se = F)

# 
# corr_imp %>%
#   ggplot(aes(x = threshold, y = V1, colour = interaction(type, scaled))) +
#   geom_line()

# d_sp %>%
#   dplyr::group_by(net_name, type, scaled) %>%
#   dplyr::mutate(importance = rank(-d_reim, ties.method = "min"),
#                 importance = importance / max(importance)) %>%
#   dplyr::filter(type == "z_bi" |
#                   (type == "asymmetry" & scaled == F)) %>%
#   ggplot(aes(x = net_name, y = importance)) +
#   geom_boxplot(aes(fill = interaction(type, scaled)))

@

Species vary widely on the degree of their importance for network manageability. Our method to calculate the relative importance of species relies on calculating all possible maximum matchings. The number of matchings increasses exponentially with the number of links and nodes in a network. When we use mutual dependecies, there are two links between each interacting species, and we were only able to find the importance of different species in the eleven smallest networks. For the remaining nine networks, the number of maximum matchings is much larger than $4\times 10^{10}$ and the computation of the species relative importance became unfeasible. 

Nevertheless, we were able to find the relative importance of species in the single link version of the networks where links were weighted by the assymetry. For the networks in which we were able to calculate the importance using mutual dependencies, we found a strong correlation between both approaches (Spearman's rank correlation ranged between $\rho = [\Sexpr{round(min(dplyr::filter(correlations, threshold == 0.5, type == "asymmetry", scaled == T)$V3, na.rm = T), digits = 2)}, \Sexpr{round(max(dplyr::filter(correlations, threshold == 0.5, type == "asymmetry", scaled == T)$V3, na.rm = T), digits = 2)}]$, median $\tilde{\rho} = \Sexpr{round(median(dplyr::filter(correlations, threshold == 0.5, type == "asymmetry", scaled == T)$V3, na.rm = T), digits = 2)})$. Indeed, when using the weighted rank correlation coefficient $r_{w2}$, we found that the agreement was stronger for highly ranked species than for lowly ranked species ($\tilde{r_{w2}} = \Sexpr{round(median(dplyr::filter(correlations, threshold == 0.5, type == "asymmetry", scaled == T)$V1, na.rm = T), digits = 2)}$ versus $\tilde{r_{w2}} = \Sexpr{round(median(dplyr::filter(correlations, threshold == 0.5, type == "asymmetry", scaled == T)$V2, na.rm = T), digits = 2)}$). Moreover both approaches identified a highly similar set of driver species (Jaccard similarity $J = [\Sexpr{round(min(dplyr::filter(correlations, threshold == 0.5, type == "asymmetry", scaled == T)$V4, na.rm = T), digits = 2)}, \Sexpr{round(max(dplyr::filter(correlations, threshold == 0.5, type == "asymmetry", scaled == T)$V4, na.rm = T), digits = 2)}]$, $\tilde{J} = \Sexpr{round(median(dplyr::filter(correlations, threshold == 0.5, type == "asymmetry", scaled == T)$V4, na.rm = T), digits = 2)})$ 
 
<<importance, echo = FALSE, warning = F, message = F, results = "hide">>=
glmer.glmulti<-function(formula,data,random="",...){
  glmer(paste(deparse(formula, width.cutoff = 500),random),data=data,...)
}

setMethod('getfit', 'glmerMod', function(object, ...) {
  summ <- coef(summary(object))
  summ1 <- summ[,1:2,drop=FALSE]
  ## if (length(dimnames(summ)[[1]])==1) {
  ##     summ1 <- matrix(summ1, nr=1,
  ##                     dimnames=list(c("(Intercept)"),
  ##                     c("Estimate","Std. Error")))
  ## }
  cbind(summ1, df=rep(times =10000,length(fixef(object))))
})


imp <- mod %>% 
  coef.glmulti(select = 0.95) %>%
  as.data.frame() %>%
  dplyr::add_rownames("factor") %>%
  dplyr::mutate(pare = grepl("(", factor, fixed =T),
                factor = plyr::mapvalues(factor, 
                                         c("de", "n", "vi", "eig_cen", 
                                           "guildpol"),
                                         c("dependency strength", 
                                           "contribution to nestedness",
                                           "visitation strength",
                                           "eigen-centrality", 
                                           "guild (pollinator)"))) %>% 
  dplyr::arrange(-pare, -Importance, -Estimate, factor) %>% 
  dplyr::select(-pare)

print_table <- . %>%
  # dplyr::mutate(factor = paste0("$", factor, "$")) %>%
  magrittr::set_names(c("factor", "est.", "var", "No. mod.", "imp.", "C.I.")) %>% 
  dplyr::select(-var) %>%
  kable(format = "latex", align = "c", booktabs = T, digits = 2, escape = F, linesep = "") 
@

<<species, echo = FALSE, warning = F, message = F, fig.height=4.4, fig.width=3.1>>=
data <- mo
net <- "./data/V2.0/networks" %>%
	read_networks()
# pred <- expand.grid(de = c(seq(min(data$de), max(data$de), length = 20000), mean(data$de)),
#             n = c(seq(min(data$n), max(data$n), length = 2), mean(data$n)),
#             vi = c(seq(min(data$vi), max(data$vi), length = 2), mean(data$vi)), 
#             eig_cen = mean(data$eig_cen, na.rm = T), 
#             guild = "pla") %>%
#   dplyr::mutate(q = predict.glmulti(mod, 
#                                     select = 0.95, 
#                                     newdata = ., 
#                                     re.form = NA)$averages %>%
#                   as.vector(), 
#                 p = plogis(q)) %>%
#   dplyr::mutate(de = de * attr(data$de, "scaled:scale") + attr(data$de, "scaled:center"),
#                 vi = vi * attr(data$vi, "scaled:scale") + attr(data$vi, "scaled:center"),
#                 n = n * attr(data$n, "scaled:scale") + attr(data$n, "scaled:center"))
#   # dplyr::filter(de == mean(data$de)) %>%
#   
# p1 <- pred %>%
#   dplyr::filter(vi == unique(vi)[3]) %>%
#   ggplot(aes(x = de, y = p)) +
#   geom_line(aes(colour = as.factor(n), group = as.factor(n)), size = 1) +
#   scale_colour_manual(name = "contribution to nestedness",
#                       labels = c("max.", "mean", "min"),
#                       values = c("#cccccc", "#969696", "#525252")) +
#   # scale_x_continuous(expand = c(0,0)) +
#   scale_y_continuous(limits = c(0,1)) +
#   scale_x_log10() + 
#   # xlab("degree") +
#   # ylab("strength of dependencies") +
#   stat_contour(colour = "black", size = 0.75) +
#   fer_theme + theme(panel.grid = element_blank(), legend.position = "top") 
# 
# p2 <- pred %>%
#   dplyr::filter(n == unique(n)[3]) %>%
#   ggplot(aes(x = de, y = p)) +
#   geom_line(aes(colour = as.factor(vi), group = as.factor(vi)), size = 1) +
#   # scale_fill_gradient(name = "relative\nimportance", high = "#f0f0f0", low = "#525252") +
#   # scale_x_continuous(expand = c(0,0)) +
#   scale_y_continuous(limits = c(0,1)) +
#   scale_x_log10() + 
#   # xlab("degree") +
#   # ylab("strength of dependencies") +
#   stat_contour(colour = "black", size = 0.75) +
#   fer_theme + theme(panel.grid = element_blank(), legend.position = "top")
# 

guild <- c("pla", "pol") %>%
  plyr::ldply(function(y){
    o <- lapply(net, function(x) igraph::V(x)[igraph::V(x)$type == y]$name) %>%
      unlist() %>% unique()
    data.frame(guild = y, species = o)
  })

invasive_sp <- dplyr::filter(meta, inv) %>%
  dplyr::mutate(species = plyr::mapvalues(invader, 
                                          c("car", "op", "imp"),
                                          c("p_4", "p_25", "Impatiens glandulifera")), 
                invasive = T) %>%
  dplyr::select(net_name, species, invasive)

connected_sp <- data %>% dplyr::select(net_name, species) %>% 
  dplyr::mutate(connected = T)

s_p_s <- s_p %>%
  dplyr::full_join(invasive_sp) %>% 
  dplyr::mutate(invasive = replace(invasive, is.na(invasive), FALSE)) %>% 
  dplyr::inner_join(guild) %>%
  dplyr::inner_join(meta) %>%
  dplyr::filter(study != "ballantyne") %>%
  dplyr::inner_join(connected_sp)

dd <- data %>% lapply(as.vector) %>% as.data.frame()
dd <- s_p_s %>%
  dplyr::select(net_name, species, invasive, connected) %>%
  dplyr::inner_join(dd) %>%
  dplyr::mutate(pp = predict(mod, select = 0.95, newdata = ., re.form = NA)$averages,
                pp = as.vector(pp),
                pp = plogis(pp),
                de2 = de * attr(data$de, "scaled:scale") + attr(data$de, "scaled:center"))


# 
# d <- s_p_s %>%
#   dplyr::rename(n = nestedcontribution, 
#                 de = d_strength, 
#                 vi = v_strength) %>%
#   dplyr::select(de, n, vi, eig_cen, guild)
# 
# d %>% s_p_s %>%
#   dplyr::select(guild)
# 
# pp <-  predict(mod, newdata = d, select = 0.95, re.form = NA)$averages
# 
# species <- s_p_s %>%
#   dplyr::mutate(pp = plogis(as.vector(pp)))

trans <- function(x, orig){
  x * attr(orig, "scaled:scale") + attr(orig, "scaled:center")
}

b_trans <- function(x, orig){
  (x - attr(orig, "scaled:center")) / attr(orig, "scaled:scale")
}

# juju <- function(x) 10^x

# 
# pred2 <- expand.grid(de = b_trans(exp(c(seq(log(trans(min(data$de), data$de)),
#                                 log(trans(max(data$de), data$de)), 
#                                 length = 500))), data$de),
#             n = c(seq(min(data$n), max(data$n), length = 500)),
#             vi = mean(data$vi), 
#             eig_cen = mean(data$eig_cen, na.rm = T), 
#             guild = "pla") %>%
#   dplyr::mutate(q = predict.glmulti(mod, 
#                                     select = 0.95, 
#                                     newdata = ., 
#                                     re.form = NA)$averages %>%
#                   as.vector(), 
#                 p = plogis(q)) %>%
#   dplyr::mutate(de = de * attr(data$de, "scaled:scale") + attr(data$de, "scaled:center"),
#                 vi = vi * attr(data$vi, "scaled:scale") + attr(data$vi, "scaled:center"),
#                 n = n * attr(data$n, "scaled:scale") + attr(data$n, "scaled:center"))
# 
# p3 <- pred2 %>%
#   ggplot() +
#   geom_tile(aes(fill = p, x = de, y = n, z = p)) + 
#   scale_x_log10(expand = c(0,0)) +
#   scale_y_continuous(expand = c(0,0)) +
#   scale_fill_continuous(limits = c(0,1), low = "#ffffff", high = "#636363") +
#  
#   geom_point(data = s_p_s, aes(x = d_strength, y = nestedcontribution, shape = guild, colour = invasive), size = 1) +
#    # stat_contour(aes(x = de, y = n, z = p), 
#                # colour = "black", size = 0.5, bins = 5) +
#   fer_theme + 
#   scale_shape_manual(values = c(21, 22)) +
#   scale_color_manual(values = c("#525252","#e41a1c")) + 
#   theme(panel.grid = element_blank(), legend.position = "none",
# 				plot.margin = grid::unit(c(0, 0, 2, 0), "mm")) +
#   xlab("dependency strength") +
#   ylab("contribution to nestedness")
# 
# 
# pred3 <- expand.grid(de = b_trans(exp(c(seq(log(trans(min(data$de), data$de)),
#                                 log(trans(max(data$de), data$de)), 
#                                 length = 500))), data$de),
#             n = c(mean(data$n)),
#             vi = b_trans(exp(c(seq(log(trans(min(data$vi), data$vi)),
#                                 log(trans(max(data$vi), data$vi)),
#                                 length = 500))), data$vi),
#             # vi = seq(min(data$vi), max(data$vi), length.out = 500),
#             eig_cen = mean(data$eig_cen, na.rm = T), 
#             guild = "pla") %>%
#   dplyr::mutate(q = predict.glmulti(mod, 
#                                     select = 0.95, 
#                                     newdata = ., 
#                                     re.form = NA)$averages %>%
#                   as.vector(), 
#                 p = plogis(q)) %>%
#   dplyr::mutate(de = de * attr(data$de, "scaled:scale") + attr(data$de, "scaled:center"),
#                 vi = vi * attr(data$vi, "scaled:scale") + attr(data$vi, "scaled:center"),
#                 n = n * attr(data$n, "scaled:scale") + attr(data$n, "scaled:center"))
# 
# p4 <- pred3 %>%
#   ggplot() +
#   geom_tile(aes(x = de, y = vi, z = p, fill = p)) + 
#   scale_x_log10(expand = c(0,0)) +
#   scale_y_log10(expand = c(0,0)) +
#   scale_fill_continuous(limits = c(0,1), low = "#ffffff", high = "#636363", name = "") +
#   geom_point(data = s_p_s, aes(x = d_strength, y = v_strength, shape = guild, colour = invasive), size = 1, show.legend = F) +
#   # geom_contour(aes(x = de, y = vi, z = p), colour = "black", size = 0.5, bins = 5) +
#   fer_theme + theme(panel.grid = element_blank(), legend.position = "top",
# 				plot.margin = grid::unit(c(5, 0, -2, 0), "mm"),
# 				legend.key.height = grid::unit(3, "mm"),
# 				legend.key.width = grid::unit(6, "mm")) +
#   scale_shape_manual(values = c(21, 22)) +
#   scale_color_manual(values = c("#525252","#e41a1c")) + 
#   xlab("") +
#   ylab("visitation strength")
# 
# ratio <- function(x){
#   o <- round(x * 1000)
#   rep(c(1,2), times = c(o, 1000-o)) %>%
#     matrix(ncol = 1)
# }

# 
# pred4 <- expand.grid(de = b_trans(exp(c(seq(log(trans(min(data$de), data$de)),
#                                 log(trans(max(data$de), data$de)), 
#                                 length = 500))), data$de),
#             n = mean(data$n),
#             vi = c(-1, 0, 1),
#             # vi = seq(min(data$vi), max(data$vi), length.out = 500),
#             eig_cen = mean(data$eig_cen, na.rm = T), 
#             guild = "pla") %>%
#   dplyr::filter(!(n == max(data$n) & vi == min(data$vi)),
#                 !(n == min(data$n) & vi == max(data$vi))) %>%
#   dplyr::mutate(q = predict.glmulti(mod, 
#                                     select = 0.95, 
#                                     newdata = ., 
#                                     re.form = NA)$averages %>%
#                   as.vector(), 
#                 p = plogis(q)) %>%
#   dplyr::mutate(de = de * attr(data$de, "scaled:scale") + attr(data$de, "scaled:center"),
#                 vi = vi * attr(data$vi, "scaled:scale") + attr(data$vi, "scaled:center"),
#                 n = n * attr(data$n, "scaled:scale") + attr(data$n, "scaled:center"))
# 
# pred4 %>%
#   ggplot(aes(x = de, y = p)) +
#   geom_line(aes(colour = as.factor(n), linetype = as.factor(vi))) + 
#   scale_x_log10(expand = c(0,0)) +
#   fer_theme
# 
# 

pred4 <- data.frame(de = rep(b_trans(exp(c(seq(log(trans(min(data$de), data$de)),
                                log(trans(max(data$de), data$de)),
                                length = 500))), data$de),3),
            n = rep(c(-1,0,1), each = 500),
            vi = rep(c(-1,0,1), each = 500),
            type = rep(c("exp", "mean", "exp"), each = 500),
            # vi = seq(min(data$vi), max(data$vi), length.out = 500),
            eig_cen = mean(data$eig_cen, na.rm = T),
            guild = "pla") %>%
  dplyr::filter(!(n == 2 & vi == -2),
                !(n == -2 & vi == 2)) %>%
  dplyr::mutate(q = predict.glmulti(mod,
                                    select = 0.95,
                                    newdata = .,
                                    re.form = NA)$averages %>%
                  as.vector(),
                p = plogis(q)) %>%
  dplyr::mutate(de = de * attr(data$de, "scaled:scale") + attr(data$de, "scaled:center"),
                vi = vi * attr(data$vi, "scaled:scale") + attr(data$vi, "scaled:center"),
                n = n * attr(data$n, "scaled:scale") + attr(data$n, "scaled:center"))




# multiplot(p4, p3, layout = ratio(0.57))

@

Although plants showed significantly higher levels of importance for network control than pollinators (Mann-Withney-Wilcoxon test, $p \Sexpr{fix_small_pvalue(wilcox.test(pp ~ guild, data = dd, alternative = "greater")$p.value)}$), this difference can be largely explained by the strength of dependency of the species (the sum of the dependencies for a given species). Indeed, when averaging over the set of GLMMs that accounted at least 95\% of the evidencee based on AICc, we found that the strength of dependency  is the single most important factor determining the relative importance of species for network control (\autoref{table:driver_model}\todo{consider moving the table to thes supplementary}, \autoref{fig:driver_model_alt}). Contrastingly, the number of visits a species receives (or performs) and its contribution to nestedness have only a marginal effect on its relative importance for network control. In addition, in the ten communities that were invaded, invasive species were invariably classified as a driver species. 

\begin{table}
\centering
\small
<<table importance 1, echo = FALSE, warning = F, message = F, results = "asis">>=
print_table(imp)
@
\caption{\label{table:driver_model} The strength of dependency, contribution to nestedness and visitation strength had a significative effect on all the models that accounted for 95\% of the evidence based on AICc. Coeficient estimates were avaraged following \textcite{Buckland1997a}; confidence intervals were calculated following \textcite{Lukacs2010}.}
\end{table}

\begin{figure}
\centering
<<fig species alt, echo = FALSE, warning = F, message = F, fig.height=2.2, fig.width=3.1>>=
pred4 %>%
  ggplot() +
  geom_line(aes(x = de, y = p, linetype = type, colour = type, group = interaction(n, vi)), show.legend = F, size = 0.5) +
  scale_x_log10(expand = c(0,0)) +
   geom_point(data = dplyr::arrange(dd, invasive), aes(x = de2, y = pp, fill = invasive, shape = guild, size = invasive), show.legend = F) +
    scale_shape_manual(values = c(21, 23)) +
  scale_size_manual(values = c(1,1.5)) +
  scale_fill_manual(values = c("white","#e41a1c")) + 
  scale_color_manual(values = c("#525252", "black")) +
  scale_linetype_manual(values = c(2, 1)) +
  xlab("dependency strength") +
  ylab("relative importance") +
  fer_theme
@
\caption{\label{fig:driver_model_alt} Dependency strength is the single most important factor explaining the importance of species for network control. Visitation levels and contribution to nestedness had a significant albeit small effect on the importance (dashed lines correspond to \textpm one standard deviation on these factors). Invasive species (red) were invariably classified as driver species (those having the maximum importance for network control.}
\end{figure}

\section*{Discussion}

We found that 

Therefore, full controlability of ecological networks---being able to steer the ecosystem into any desired ecosystem state---would require a  This characteristics render ecological networks unlikely to be able to visist every possible system state   other closed systems, ecological networks 

The controllability of ecological networks is not a concept limited to control theory. Controllability in the ecological context can be seen as a direct meassure of the mimimum number of species whose abbundance would need to be directly regulated to achieve full network control. While we are far away from 

\section*{Acknoledgements}

The authors thank Dr. Takeuki Uno for the insight provided to find the set of all maximum matching algorithms, and Bernat Bramon, Matthew Hutchinson and Marilia Gaiarsa for feedback in early stages of the project. EFC acknowledges the support from the University of Canterbury Doctoral Scholarship, the University of Canterbury Meadow Mushroooms Postgraduate Scholarship, a travel grant from the European Space Agency and a Rutherford Discovery Fellowship (to DBS). DBS ackloledges the support of a Rutherford Discovery Scholarship, administered by the Royal Society of New Zealand.


\printbibliography

\end{document}