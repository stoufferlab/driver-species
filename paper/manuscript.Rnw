\documentclass[a4paper,10pt]{article}
\usepackage[margin=22.5mm]{geometry}

% abstract + title + authors 
\usepackage{abstract}
\renewcommand{\abstractnamefont}{\normalfont\bfseries}
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} 
\usepackage{titlesec}
\usepackage{authblk}
\usepackage{datetime}
\newdateformat{usvardate}{
\monthname[\THEMONTH] \ordinal{DAY}, \THEYEAR}

% keywords
\providecommand{\keywords}[1]{\textbf{\textit{Keywords---}} #1}

% math
\usepackage{amssymb}
\usepackage{newtxmath}
\usepackage{xfrac}
 
% manuscript looking document
\usepackage{setspace}
\usepackage{lineno,xcolor}
\setlength{\parskip}{0.5em}

% comments
\usepackage[draft, textsize = scriptsize, color = gray]{todonotes}

% graphics
\usepackage{graphicx}
\usepackage{float}
\usepackage{sidecap}
\sidecaptionvpos{figure}{t}
\usepackage[font=small]{caption}
\usepackage{subfig}
\usepackage{caption}

% table
\usepackage{booktabs}

% box
\usepackage{tcolorbox}

% references & links
\usepackage[
backend=bibtex,
style= authoryear,
citestyle = authoryear,
url=false,
doi=true,
isbn=false
]{biblatex}
\addbibresource{references.bib}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    citecolor=magenta,
    linkcolor=magenta
}
\usepackage{doi}
\begin{document}
\renewcommand*{\bibfont}{\small}
% line numbers
\linenumbers
\setlength\linenumbersep{15pt}
\renewcommand\linenumberfont{\normalfont\footnotesize\sffamily\color{gray}}

\doublespacing
%\onehalfspacing

% title
% Article title
  \title{
  {\LARGE \textsc{Biotic invasions reduce the manageability of mutualistic networks}}}

% Authors and Affiliations
  \author{\large E. Fernando Cagua}
  \author{\large Kate L. Wootton}
  \author{\large Daniel B. Stouffer}
  \affil{\normalsize Center of Integrative Ecology, School of Biological Sciences, University of Canterbury}
 \date{}
 
\maketitle

Alternative title:

\textsc{Network manageability in the context of species invasion}


<<libraries, echo = FALSE, warning = F, message = F>>=
library(magrittr)
library(knitr)
library(ggplot2)
library(glmulti)
library(Hmisc)
library(lme4)
opts_knit$set (root.dir=normalizePath('../'))
@

<<auxiliary functions, echo = FALSE, warning = F, message = F>>=
"./code/V2.0/functions" %>% 
	list.files(full.names = T) %>%
	plyr::l_ply(source)
@

<<plot theme, echo = FALSE, warning = F, message = F>>=
fer_theme <- theme_bw() +
	theme(text = element_text(family = "Times"),
	      title = element_text(size = 7.5, hjust = 0),
	      legend.title = element_text(size = 9),
	      legend.text = element_text(size = 8),
				axis.text = element_text(size = 8),
				axis.title = element_text(size = 9, hjust = 0.5), 
				strip.text = element_text(size = 9, hjust = 0), 
				strip.background = element_blank(),
				plot.margin = grid::unit(c(5, 0, 2, 0), "mm"))
@

<<read data and results, echo = FALSE, warning = F, message = F>>=
net <- "./data/V2.0/networks" %>%
	read_networks()
meta <- readr::read_csv("data/ntw_info.csv") %>% dplyr::tbl_df() %>%
	dplyr::rename(count = method)
n_matched <- readRDS("./data/V2.0/n_matched.rds")
a_m <- readRDS("./data/V2.0/n_matched_all_types.rds") 
r_w <- readRDS("./data/V2.0/random_weights.rds") %>% dplyr::tbl_df() %>%
  dplyr::rename_("net_name" = ".id")
r_d <- readRDS("./data/V2.0/random_directions.rds") %>% dplyr::tbl_df() %>%
  dplyr::rename_("net_name" = ".id")
s_p <- readRDS("./data/V2.0/species_properties.rds") %>% dplyr::tbl_df()
# mod <- readRDS("./data/V2.0/species_models.rds")
driver <- c("./data/V2.0/matching_frequency") %>% 
  list.files(full.names = T) %>%
  lapply(list.files, full.names = T) %>% 
  unlist() %>% 
  lapply(read_allRDS)
prop <- expand.grid(c("asymmetry", "max_dep"), 
                    c("scaled_FALSE", "scaled_TRUE")) %>% plyr::alply(1)
driver <- mapply(function(x, y){
  attr(x, "type") <- as.character(y[,1])
  attr(x, "scaled") <- stringr::str_split(as.character(y[,2]), "_") %>% unlist() %>% extract(2) %>% as.logical()
  return(x)
}, driver, prop)
driver_bi <- "./data/V2.0/matching_frequency_bi" %>% 
  read_allRDS()
mod <- readRDS("./data/V2.0/detailed_species_models.rds")
mo <- readRDS("./data/V2.0/detailed_species_models_data.rds")
@



\section*{Introduction}

Complex systems, such as ecological communities, are characterised by non-linear relationships in which the whole is greater than the sum of its parts \todo{add refs}. This complex systems approach has led to the development of a rich suite of analytical and simulation tools with which to understand the role of species when embedded in an intricate network of interactions\todo{add refs}. However, in contrast to other types of complex systems like neural, intra-organizational, or trust neworks, ecological networks do not have a hierarchical or distributed structure but rather tend to be closed systems in which resources recirculate\todo{add ref}. As such, ecosystems contain multiple feedbacks that allow them to self-regulate and, therefore, function relatively independent from external stimulation\todo{add ref}. This complex propertes have hindered, or at least complicated, our ability to find management solutions to the many problems ecological communities face. A framework that allow us to explain, predict, and manage ecological communities, particularly when they are faced with perturbations, needs to be able to account for their complex structure, and the dynamics that determine the state of each species---and the community as a whole. Control theory might be a good candidate framework as it is designed to deal with determining and supervising the behavior of a dynamical system and is well equiped to deal with the many feedbacks presents in ecological communities\todo{add ref}. 

Research stemming from control theory has established a strong link between the structure of complex networks and their controlability, and that, in principle, it is possible to alter a ecological community's composition by modifying the abundances of only a few species \autocite{Liu2011, Cornelius2013}. Based on this work, it has been suggested that the degree distribution of ecological networks makes them inherently difficult to control \autocite{Liu2011, Ruths2014}. This theoretical result is in agreement with many examples in which the management and restoration of ecological communities is more challenging than aticipated. For instance, biotic invasions, as a major drivers of global change, can induce dramatic changes on the patterns of interactions that determine the structure of ecological networks \autocite{Baxter2004, Tylianakis2008, Ehrenfeld2010a}. The difficulties of returning invaded communities to a predisturbance state can be evidenced by the limited amount of success of restoration projects \autocite{Suding2004, Rodewald2015, Smith2016}. Although it is a double challenge, understanding how differences in network structure before and after the invasion impact our ability to manage them is a first step towards an informed recovery. 

A control theoretical approach not only might provide insight to conservation but also for ecological science: by explicitly taking into account the extent to which changes in the abbundances of one species may ripple trough the community, applying control theory to ecological networks can provide an indication of which species are important from a dynamic perspective, and therefore crucial when attempting to alter (or maintain) the ecosystem state. Nevertheless, although it has been prevoiously used to highlight the disproportionate influence that humans have on marine food-webs \autocite{Isbell2013}, control theory has has rarely been aplied in an ecological context. One reason might be that the control of complex networks is still a young field and the tools necessary to account for variation on the strength of interspecific effects, which are characteristic of ecological networks, are not there.

Here, we expand previous theory of the control of complex systems and use a set of ten paired invaded and uninvaded plant-pollinator communities to investigate the link between network structure and our ability to manage them. We focus on biotic invasions because they can produce tractable changes in the structure of ecological networks. These changes can be particularly pronounced in mutualistic networks of plants and pollinators where biotic invasions have been shown to modify the strength of species interactions and the degree of network nestedness and connectivity \autocite{Olesen2002, Aizen2008, Bartomeus2008, Vila2009, Traveset2013}. In addition plant-pollinator networks provide an ideal framework to answer these questions. On one hand, community networks that quantify relative levels of interaction are readily available. On the other, the bipartite nature of pollination networks makes it is possible to simplify assumptions of how these interactions translate into interspecific effects. Specifically we ask two key questions framed in the context of a plant invasion. First, we quantify the manageability of pollination communities. Second, we ask whether some species are more important than others at driving the population dynamics of the community and which factors determine this importance. 

\iffalse

\section*{Theory of community manageability}

\subsection*{Maximum matching}

The number of nodes necessary to fully control a complex network can be calculated by counting the number of unmatched nodes in the network's maximum matching \autocite{Liu2011}. In a directed network, a given matching is a subset of links in which no two links share a common starting node or a common ending node; a node is matched if it is the ending node of one of the links in the matching (\autoref{fig:explain_mm}a). A matching is then maximum if bith \textit{(i)} the number of matched links---known as matching size---is maximal and \textit{(ii)} the sum of the weights of the matched links---known as matching weight---is the largest possible among all possible matchings of that size \autocite{West2001}. To find the maximum matching, we used an alternative bipartite representation of the network in which the two levels indicate the outgoing and incoming links to each node (\autoref{fig:explain_mm}b). Finding a matching in this alternative representation is equivalent to finding a set of links such that each node on the top level is matched to at most one node on the bottom level, and vice versa \autocite{West2001, Csardi2006a}.  

\begin{figure}
\centering
<<fig explain mm, echo = FALSE, warning = F, message = F, results = "asis", fig.height=1.6, fig.width=6.2>>=

sp_names <- c("a[1]", "a[2]", "a[3]", "p[1]", "p[2]")

adj_matrix <- c(0,0,0,1,0,
								0,0,0,1,1,
								0,0,0,0,0,
								0,0,1,0,0,
								0,0,1,0,0) %>%
	matrix(nrow = 5, byrow = T) %>%
	`rownames<-`(sp_names) %>%
	`colnames<-`(sp_names)

net <- adj_matrix %>% 
	igraph::graph_from_adjacency_matrix(mode = "directed") 
igraph::V(net)$type <- c(F, F, F, T, T)
igraph::E(net)$weight <- 1

layoutCoordinates <- cbind(c(0,1,2,0.5,1.5), 
													 c(1,1,1,0,0)) %>%
	`colnames<-`(c("x", "y"))

adj_list <- adj_matrix %>% 
	reshape2::melt() %>% 
	dplyr::filter(value > 0)

# Generate an edge path for each pair of connected nodes
n <- 17
allEdges <- lapply(1:nrow(adj_list), edgeMaker, len = n, curved = FALSE)
allEdges <- do.call(rbind, allEdges) %>%
	dplyr::filter(Sequence != n) %>%
	dplyr::mutate(Group = factor(Group),
				 type = Group)

new_lev <- c("m", "u", "m", "m", "u")
levels(allEdges$type) <- new_lev

nodes <- data.frame(layoutCoordinates) %>%
	dplyr::mutate(spe = sp_names,
								spe_c = c("m", "m", "u", "m", "u"), 
								pos = rep(c(0.3, -0.3), c(3,2)))

p1 <- ggplot(allEdges) +  # Pretty simple plot code
	geom_path(aes(x = x, y = y, group = Group, colour = type, size = type), 
						arrow = arrow(type = "closed", angle = 15, length = grid::unit(0.1, "inches"))) + # and taper
	geom_point(data = nodes,  # Add nodes
						 aes(x = x, y = y , fill = spe_c), size = 5, pch = 21,
						 colour = "black") + 
	geom_text(data = nodes, aes(x = x, y = y + pos, label = spe), size = 3, parse = T, family = "Times") +
	scale_fill_manual(values = c("#636363", "white")) + 
	scale_colour_manual(values = c("#636363", "#bdbdbd")) +
	my_theme + xlab("") + ylab("") + 
  	xlim(c(-0.09, 2.09)) + ylim(c(-0.48, 1.48)) +
 theme(plot.margin=unit(c(4,4,-4,-4),"mm")) +
	scale_size_manual(values = c(0.5, 0.5)) +
  ggtitle("a) directed network")
	
net <- digraph_bipartite(net)
adj_matrix <- net %>% igraph::as_adjacency_matrix(sparse = F, type = "upper")
layoutCoordinates <- cbind(rep(0:4, 2), rep(c(1,0), each = 5)) %>%
	`colnames<-`(c("x", "y"))

adj_list <- adj_matrix %>% 
	reshape2::melt() %>% 
	dplyr::filter(value > 0)

# Generate an edge path for each pair of connected nodes
n <- 100
allEdges <- lapply(1:nrow(adj_list), edgeMaker, len = n, curved = FALSE)
allEdges <- do.call(rbind, allEdges) %>%
	dplyr::filter(Sequence != n,
								Sequence != 1) %>%
	dplyr::mutate(Group = factor(Group),
				 type = Group)

new_lev <- c("m", "m", "u", "m", "u")
levels(allEdges$type) <- new_lev

nodes <- data.frame(layoutCoordinates) %>%
	dplyr::mutate(spe = rep(sp_names, 2),
								spe_l = c(paste0(sp_names, " %->% phantom(0)"), paste0(sp_names, " %<-% phantom(0)")),
								spe_c = c(c("m", "m", "u", "m", "u"), rep("u",5)), 
								pos = rep(c(0.3, -0.3), each = 5))

p2 <- ggplot(allEdges) +  # Pretty simple plot code
	geom_path(aes(x = x, y = y, group = Group, colour = type, size = type)) + # and taper
	geom_point(data = nodes,  # Add nodes
						 aes(x = x, y = y, fill = spe_c), size = 5, pch = 21,
						 colour = "black") + 
	geom_text(data = nodes, aes(x = x + 0.08, y = y + pos, label = spe_l), parse = T, size = 3, family = "Times") +
	# coord_flip()  + scale_x_reverse() + scale_y_reverse() +
	scale_fill_manual(values = c("#636363", "white")) + 
	scale_colour_manual(values = c("#636363", "#bdbdbd")) +
	xlim(c(-0.12, 4.12)) + ylim(c(-0.48, 1.48)) +
	my_theme + xlab("") + ylab("") +
	scale_size_manual(values = c(0.5, 0.5)) +
  ggtitle("b) alternative bipartite representation")

multiplot(p1, p2, layout = matrix(nrow = 1, c(1,1,1,2,2,2,2,2)))
@
\caption{\label{fig:explain_mm} Finding a maximum matching in a complex network. a) We start with a directed network  in which the direction of the link represent the direction of control. This is, a link from $a_1$ to $p_1$ indicates that the state of $p_1$ (density/abbundances in an ecological context) are influenced by the state of $a_1$. b) To facilitate the computation of the maximum matching, we used an alternative undirected bipartite representation of the directed network in which each node in (a) is represented by two nodes that indicate the outgoing and incoming links. One of the possible maximum matchings of a network (dark grey links) defines a set matched ($p_1$, $p_2$, and $a_3$) and unmatched nodes ($a_1$ and $a_2$). The minimum number of species neccessary to control this network equates to the number of unmatched nodes $n_d = 2$. Superior nodes (dark grey circles) drive the dynamics of other species and are therefore important for the controlability of the network because they either require external input or because the are part of the chain that transmit the external imputs to other species.}
\end{figure}

Given a maximum matching, the link to network controllability has a relatively straightforward and intuitive basis. In control theory, a network is fully controlable when each node has a ``superior'', that is, an input that drives its dynamics. Matched nodes can thus be controled by the node pointing to it. Unmatched nodes, on the other hand, have no superior in the network and must be directly controlled by external inputs \autocite{Liu2011}. In an ecological context, this is what we refer to as management interventions.

Systems that require a large number of external inputs are more difficult or costly to control. Therefore, the manageability $m$ of a community can be approximated by the proportion of species on which we would need to apply management interventions in order to gain full control of the abundances of \textit{all} species in the ecological community, $$m = 1- \frac{n_d}{s},$$ where $n_d$ is the proportion of species needed to gain full control and $s$ is the total number of species in the community.

\subsection*{Weighting \& directing links}

Recall that our maximum matching algorithm requires a directed network in which a link between species $i$ and $j$ pointing to species $j$ indicates that the abundance of $j$ can be affected by the abundance of $i$. This implies that we need first to establish a directionality for the links between species that in consistent with the dynamics of the comunity. In some ecological networks, establishing a directionality is relatively straightforward when they represent resources or energy flow. Interspecific effects in pollination networks, however, are not strictly directed. Nevertheless, the extent to which a pair of interacting species affect each other can be quantified by the magnitude of the mutual dependence \autocite{Bascompte2006}. 

The dependency of plant $i$ on pollinator $j$, $d_{ij}$, is the proportion of the visits coming from pollinator $j$ compared to all pollinator visits to plant $i$. Likewise, the dependency of pollinator $j$ on plant $i$, $d_{ji}$, is the ratio of the visits by pollinator $j$ to plant $i$ and all visits of pollinator $j$. As the dependencies are bidirectional, adopting this assumption generates a weighted bipartite network in which interacting pairs are connected by two directed links (\autoref{fig:explain_cd}b). 

Mutual dependencies have been shown to be highly assymetric in natural communities \autocite{Bascompte2006}. In other words, if a plant species is largely dependent on a pollinator species, then the pollinator tends to depend only very weakly on the plant. This suggest that it may be possible to relax this initial assumption and simplify the network further such that interacting species are only connected by one directed link when mutual dependencies are assymetric (\autoref{fig:explain_cd}c). The extent to which a species $i$ affects species $j$ relative to the extent to which species $j$ affects species $i$ can then be summarised by the interaction asymmetry $$a(i,j) = \frac{\left | d_{ij}-d_{ji} \right |}{\textup{max}\left ( d_{ij}, d_{ji} \right )}$$

Employing an unidrectional interaction asymmetry, as a surrogate of bidirectional mutual dependences, dramatically reduces the number of links in the network. Which damatically simplifies the computation of of all posible maximum matchings in a network.

\begin{figure}
\centering
<<fig explain control direction, echo = FALSE, warning = F, message = F, results = "asis", fig.height=1.5, fig.width=6.2>>=
sp_names <- c("a[1]", "a[2]", "a[3]", "p[1]", "p[2]")

adj_matrix <- c(0,0,0,0,0,
								0,0,0,0,1,
								0,0,0,0,0,
								1,1,1,0,0, 
								0,0,1,0,0) %>%
	matrix(nrow = 5, byrow = T) %>%
	`rownames<-`(sp_names) %>%
	`colnames<-`(sp_names)

net <- adj_matrix %>% 
	igraph::graph_from_adjacency_matrix(mode = "directed") 
igraph::V(net)$type <- c(F, F, F, T, T)
igraph::E(net)$weight <- 1

layoutCoordinates <- cbind(c(0,1,2,0.5,1.5), 
													 c(1,1,1,0,0)) %>%
	`colnames<-`(c("x", "y"))

adj_list <- adj_matrix %>% 
	reshape2::melt() %>% 
	dplyr::filter(value > 0)

# Generate an edge path for each pair of connected nodes
n <- 17
allEdges <- lapply(1:nrow(adj_list), edgeMaker, len = n, curved = FALSE)
allEdges <- do.call(rbind, allEdges) %>%
	dplyr::filter(Sequence != n) %>%
	dplyr::mutate(Group = factor(Group),
				 type = Group)

new_lev <- c("m", "u", "m", "m", "u")
levels(allEdges$type) <- new_lev

nodes <- data.frame(layoutCoordinates) %>%
	dplyr::mutate(spe = sp_names,
								spe_c = c("m", "m", "u", "m", "u"), 
								pos = rep(c(0.3, -0.3), c(3,2)))

weights <- allEdges %>%
  dplyr::filter(Sequence == 12) %>%
  dplyr::mutate(weight = c(1, 2, 1, 1, 2))

p1 <- ggplot(allEdges) +  # Pretty simple plot code
	geom_path(aes(x = x, y = y, group = Group, size = type), colour = "#bdbdbd") + # and taper
	geom_point(data = nodes,  # Add nodes
						 aes(x = x, y = y ), size = 5, pch = 21,
						 colour = "black", fill = "white") + 
	# geom_text(data = nodes, aes(x = x, y = y + pos, label = spe), size = 3, parse = T, family = "Times") +
  geom_point(data = weights, aes(x = x, y= y), size = 2.5, alpha = 0.25, colour = "white") +
  geom_text(data = weights, aes(x = x, y= y, label = weight), size = 2.5, family = "Times") +
	scale_fill_manual(values = c("#636363", "white")) + 
	scale_colour_manual(values = c("#636363", "#bdbdbd")) +
	my_theme + xlab("") + ylab("") + 
  	xlim(c(-0.09, 2.09)) + ylim(c(-0.15, 1.15)) +
 theme(plot.margin=unit(c(4,4,-4,-4),"mm")) +
	scale_size_manual(values = c(0.5, 0.5)) +
  ggtitle("a) visitation frequency")

############################
sp_names <- c("a[1]", "a[2]", "a[3]", "p[1]", "p[2]")

adj_matrix <- c(0,0,0,1,0,
								0,0,0,1,1,
								0,0,0,1,1,
								1,1,1,0,0,
								0,1,1,0,0) %>%
	matrix(nrow = 5, byrow = T) %>%
	`rownames<-`(sp_names) %>%
	`colnames<-`(sp_names)

net_exp <- adj_matrix %>% 
	igraph::graph_from_adjacency_matrix(mode = "directed") 
igraph::V(net_exp)$type <- c(F, F, F, T, T)
igraph::E(net_exp)$weight <- 1

layoutCoordinates <- cbind(c(0,1,2,0.5,1.5), 
													 c(1,1,1,0,0)) %>%
	`colnames<-`(c("x", "y"))

adj_list <- adj_matrix %>% 
	reshape2::melt() %>% 
	dplyr::filter(value > 0)

# Generate an edge path for each pair of connected nodes
n <- 17
allEdges <- lapply(1:nrow(adj_list), edgeMaker, len = n, curved = FALSE)
allEdges <- do.call(rbind, allEdges) %>%
	dplyr::filter(Sequence != n) %>%
	dplyr::mutate(Group = factor(Group),
				 type = Group)

new_lev <- c("m", "u", "m", "u", "u", "u", "m", "u", "u", "m")
dir <- c("m", "m", "m", "m", "m", "u", "u", "u", "u", "u")
dir2 <- c("m", "u", "m", "u", "u", "u", "m", "m", "u", "m")
id <- 1:10
allEdges %<>% dplyr::mutate(dir = type,
                            dir2 = dir)
levels(allEdges$type) <- new_lev
levels(allEdges$dir) <- dir
levels(allEdges$dir2) <- dir2
allEdges %<>% 
  dplyr::mutate(dir = as.numeric(dir),
                dir2 = as.numeric(dir2),
                dir = plyr::mapvalues(dir, c(1,2), c(0.03, -0.03)),
                dir2 = plyr::mapvalues(dir2, c(1,2), c(0.03, -0.03)))

nodes <- data.frame(layoutCoordinates) %>%
	dplyr::mutate(spe = sp_names,
								spe_c = c("u", "m", "m", "m", "m"), 
								pos = rep(c(0.3, -0.3), c(3,2)))

# ggplot(allEdges) +  # Pretty simple plot code
# 	geom_path(aes(x = x + dir, y = y + dir2, group = Group, colour = type, size = type), 
# 						arrow = arrow(type = "closed", angle = 15, length = grid::unit(0.1, "inches")))

weights <- allEdges %>%
  dplyr::filter(Sequence == 12) %>%
  dplyr::mutate(weight = c("1", "0.5", "0.5", "0.5", "0.5", "0.25", "0.5", "0.25", "0.66", "0.33"))

p2 <- ggplot(allEdges) +  # Pretty simple plot code
	geom_path(aes(x = x + dir, y = y + dir2, group = Group, size = type), 
						arrow = arrow(type = "closed", angle = 15, length = grid::unit(0.1, "inches")), colour = "#bdbdbd") + # and taper
	geom_point(data = nodes,  # Add nodes
						 aes(x = x, y = y ), size = 5, pch = 21,
						 colour = "black", fill = "white") +  
	# geom_text(data = nodes, aes(x = x, y = y + pos, label = spe), size = 3, parse = T, family = "Times") +
  geom_point(data = weights, aes(x = x + dir*3, y= y), size = 2.5, alpha = 0.25, colour = "white") +
  geom_text(data = weights, aes(x = x + dir*3, y= y, label = weight), size = 2.5, family = "Times", parse = T) +
	scale_fill_manual(values = c("#636363", "white")) + 
	scale_colour_manual(values = c("#636363", "#bdbdbd")) +
	my_theme + xlab("") + ylab("") + 
  xlim(c(-0.09, 2.09)) + ylim(c(-0.15, 1.15)) +
 theme(plot.margin=unit(c(4,4,-4,-4),"mm")) +
	scale_size_manual(values = c(0.5, 0.5)) +
  ggtitle("b) mutual dependence")

####################################

sp_names <- c("a[1]", "a[2]", "a[3]", "p[1]", "p[2]")

adj_matrix <- c(0,0,0,0,0,
								0,0,0,1,1,
								0,0,0,0,0,
								1,1,1,0,0,
								0,0,1,0,0) %>%
	matrix(nrow = 5, byrow = T) %>%
	`rownames<-`(sp_names) %>%
	`colnames<-`(sp_names)

net <- adj_matrix %>% 
	igraph::graph_from_adjacency_matrix(mode = "directed") 
igraph::V(net)$type <- c(F, F, F, T, T)
igraph::E(net)$weight <- 1

layoutCoordinates <- cbind(c(0,1,2,0.5,1.5), 
													 c(1,1,1,0,0)) %>%
	`colnames<-`(c("x", "y"))

adj_list <- adj_matrix %>% 
	reshape2::melt() %>% 
	dplyr::filter(value > 0)

# Generate an edge path for each pair of connected nodes
n <- 17
allEdges <- lapply(1:nrow(adj_list), edgeMaker, len = n, curved = FALSE)
allEdges <- do.call(rbind, allEdges) %>%
	dplyr::filter(Sequence != n) %>%
	dplyr::mutate(Group = factor(Group),
				 type = Group)

# new_lev <- c("m", "u", "m", "m", "u")
# levels(allEdges$type) <- new_lev

nodes <- data.frame(layoutCoordinates) %>%
	dplyr::mutate(spe = sp_names,
								# spe_c = c("m", "m", "u", "m", "u"), 
								pos = rep(c(0.3, -0.3), c(3,2)))

weights <- allEdges %>%
  dplyr::filter(Sequence == 12) %>%
  dplyr::mutate(weight = c(0.75, 0.5, 0.5, 0.6, 0.5, 0.16)) 

p3 <- ggplot(allEdges) +  # Pretty simple plot code
	geom_path(aes(x = x, y = y, group = Group), size = 0.5,
						arrow = arrow(type = "closed", angle = 15, length = grid::unit(0.1, "inches")), colour = "#bdbdbd") + # and taper
	geom_point(data = nodes,  # Add nodes
						 aes(x = x, y = y ), size = 5, pch = 21,
						 colour = "black", fill = "white") + 
	# geom_text(data = nodes, aes(x = x, y = y + pos, label = spe), size = 3, parse = T, family = "Times") +
   geom_point(data = weights, aes(x = x, y= y), size = 2.5, alpha = 0.25, colour = "white") +
  geom_text(data = weights, aes(x = x, y= y, label = weight), size = 2.5, family = "Times") +
	scale_fill_manual(values = c("#636363", "white")) + 
	scale_colour_manual(values = c("#636363", "#bdbdbd")) +
	my_theme + xlab("") + ylab("") + 
  	xlim(c(-0.09, 2.09)) + ylim(c(-0.15, 1.15)) +
 theme(plot.margin=unit(c(4,4,-4,-4),"mm")) +
	# scale_size_manual(values = c(0.5, 0.5)) +
  ggtitle("c) interaction asymmetry")


###########################

multiplot(p1, p2, p3, cols = 3)

@
\caption{\label{fig:explain_cd} Different ways to depict quantitative mutualistic networks. a) Pollination networks are usually described by the number of visits between each plant and animal species. b) Given visitation data the mutual dependencies between interacting species depend directly on the relative visitation frequency. c) The relative differences of dependencies---the interaction asymmetry---then provides a mean to simplify the interspecific effects.}
\end{figure}

\subsection*{Relative importance}

The manageability of a community $m$ provides an indication of the magnitude of $n_d$ but not the identity of the species that compose this set. Moreover, maximum matchings are often not unique in for a given network and different sets of species of size $n_d$ could be used to control the network \autocite{Liu2011}. Species vary in terms of the frequency with which they are classified as superior nodes (\autoref{fig:explain_mm}), and this frequency provides an indication of their relative importance in driving the state of the community. Ecologically, these distinctions are crucial because resources are limited and therefore ecological inteventions should be focused on species that might provide the largest impact. We therefore call \textit{driver species} those that are identified as being a superior node in all possible matchings, and consequently likely to have the most disproportionate effect on the abundances of other species in their community.

As previously described, unlike unweighted networks, where a maximum matching is defined solely by its matching size, a maximum matching in a weighted network is one whose links have the largest possible total weight among all possible matchings. This means that in weighted networks there is a number of matchings that have maximal size, but are not maximum matchings because their total weight is not maximal. One alternative to calculate the species importance, and identify the driver species, would be to consider only maximum matchings. However empirical intreaction strengths, from which we calculate dependencies, are to some extent stochastic and depend on the sampling method and intensity. We therefore relaxed the matching weight requirement computed all possible matchings in the network that have the same maximal size while allowing for some tolerance regarding the weight. To compute all the matchings with maximal size, we first generated the network's line graph---an alternative representation in which nodes are the links of the original network and links represent common ending points\todo{add ref}. We then calculated the complement of the line graph: a graph in which nodes are connected if and only if they are not connected in the line graph. All possible matchings of maximal size can be found by enumerating all cliques of size $1-n_d$ in this complement graph \autocite{West2001, Csardi2006a}. 

\section*{Methods}

In the last section we outlined the theoretical and computational underpinings of our approach. Now we illustrate its empirical application using ten pairs of plant-pollinator communities for which we explored their manageability and the relative importance of their constituent species. The networks were constructed from previously published visitation data collected from pollination communities in Bristol, UK \autocite{Lopezaraiza-Mikel2007} and in Cap de Creus National Park, Spain \autocite{Bartomeus2008}. Notably, each network pair was composed of a community invaded by a plant and a community ``free'' of the invasive species (Table S1). In the four British uninvaded communities, the non-invaded plots were obtained by experimentally removing all the flowers of the invasive species \textit{Impatients grandulifera}. In contrast, the Spanish uninvaded communities were obtained from plots that had not yet been colonised by either of the invasive species \textit{Carpobrotus affine acinaciformis} or \textit{Opuntia stricta}. The structure of these networks was determined using visitation frequency which has been shown to be an appropriate surrogate for interspecific effects in pollination networks \autocite{Vazquez2005, Bascompte2006}. To examine whether this decision would influence our results, we also evaluated the effect of using pollinator efficiency or importance as alternative measures of species interactions \autocite{NeEman2010, Ballantyne2015}, and we found quantitatively results for all of these options(see Supplementary Information).

All analysis were performed in R 3.2.2 \autocite{RCoreTeam2015}.

\subsection*{Community manageability}

Given the different networks, we started by quantifying their manageability. To do that, we calculated the maximum matching of the corresponding pollination network, and estimated the minimum number of species that need directed intervecntions to fully control the species abbundances in the community. If a network had more than one component (two species are in different components if there exists no path between them), we only analysed the largest one. Although understanding the variability of manageability across ecological networks is an useful result itself, we also wanted to test whether perturbations, like invasion status, have an impact on manageability values. We therefore used a set of generalised linear models (with binomial error structure) to investigate the effect of invasion status while controling for factors related to species richness---as naively one might expect to see a negative relationship between diversity and manageability \autocite{Menge1995}. Coovariates inlcuded the total number of species, plant richness, polinators richness, the ratio of plants to pollinators richness, and the study site. We assessed competing models by comparing the Akaike Information Criterion corrected for small sample sizes (AICc).

We next explored the extent to which structural properties of the empirical networks influence their manageability. Previous research indicates a direct link between a network's degree distribution and the number of nodes necessary to fully control it \autocite{Liu2011}, but the strength and applicability of this relationship has not been tested for in weighted ecological networks. We therefore compared the manageability of the empirical networks to networks generated by three null models which varied in terms of the constraints they impose. The first set of random visitation networks maintain the connectivity of the empirical network, but both degree and weight were allowed to vary. A second set set was generated by maintaining each species' degree (its number of interactions) while varying the number of visits per species. Finally a third set of random networks mantained the species' strength (its total sum of visits) while varying their degrees. Randomisations were generated using vegan 2.3-3 \autocite{Oksansen2016}. After generating the randomized networks under these three schemes, we then calculated the mutual dependences and interaction asymmetries and determined their manageability using the maximum matching algorithm. Finally we calculated the p-value of the manageability of each empirical network and the corresponding manageability of 999 randomisations.

The dependency asymetry plays a fundamental role in determining the direction of control in a two species interaction and therefore has the potential to structure the network matching. We therefore performed an additional randomisation in which we mantained the structure of network but randomised the direction of the interaction asymmetries. This is, we first calculated the assymetries for each community and then shuffled the direction of the link between species. Similar as in previouls null models, we calculated the p-value of the empirical manageability compared to that of the randomisations.

\subsection*{Relative importance of species}

Our second key question is related to how different species differ in their importance for the population dynamics of the community. To quantify this importance in each network, we computed all possible matchings that have the same size as the networks' maximum matching. We then calculated the frequency to which each species is deemed to be a superior node in matchings with a weight greater or equal to 0.5 times the weight of the maximum matching. We choosed this threshold as it provided a high agreement between networks quantified by visitation and pollination efficiency as well as between our weighting/directionality assumptions (mutual dependences and inetraction asymmetries). Note that the choice of this threshold had a negligible impact on the results (Supplementary information). 

We observed that the number of maximal matchings increasses exponentially with the number of links and nodes in a network. Unfortunately, this implies that the large number of links in the most diverse communities renders the computation unfeasible when we use mutual dependecies. Taking this limitation into account, we compared the relative network manageability obtained when using assimetries or when using mutual dependencies for eleven of the twenty networks---for which the number of matchings was smaller than $4\times 10^{10}$. The comparison was performed using paired Spearman correlation test, a weighted correlation coefficient $r_{w2}$---which gives more weight to higer ranks \autocite{PintoDaCosta2015}, and a Jaccard similarity of the driver species in both approaches. All three approaches suggested a high similarity in relative ranks. Therefore, we used the results from the assymetries, rather than mutual dependences, to further investigate the factors that determine species' relative importance.

Given the species frequency obtained using the interaction asymmetries, we then asked the question of whether some species-level structural properties can predict the relative importance of species. To do so, we used a generalised linear mixed-effects model (GLMM) to evaluate the relationship between the species' relative importance and a suite of structural measures. We specifically included measures of centrality (degree and eigen-centrality) which have been found to be strong predictors of importance in a coextintion context\todo{add ref}; measures related to network robustness (contribution to nestedness) as nestedness has been proposed as one of the key properties that promote stability in mutualistic networks \autocite{Saavedra2011}; and measures of strength of association and depedence (visitation and dependency strength), as their skewed distribution is characteristic of plant-pollinator networks and determine the extent of interspecific effects. All metrics were calculated using the R package bipartite 2.06 \autocite{Dormann2008}. We allowed for variation among different communities by including the network identity as a random effect \autocite{Bates2015a}. Candidate models were compared using AICc and the relative importance of the explanatory variables was evaluated using the sum of Akaike weights over candidate models that accounted for 95\% of the evidence \autocite{Burnham2003, Bates2014, Barton2016}. 

Invasive species have been shown to have disproportionate effects on the communities they invade\todo{add ref}. So we lastly examined the extent to which invasive species tend to be driver species---species whith the maximum importance---and to which extent their importance could be explained by the factors previously described. To do so, as our invasive species were plants, we first used a Mann-Withney U test to compare the relative importance of invasive species to those of other plants in the community. We then examined the residuals of the GLMM to investigate if invasive species' importance is larger or smaller than expected given their network structural properies. 

\section*{Results}

\subsection*{Community manageability}

<<n_driver, echo = FALSE, warning = F, message = F>>=
# find n_driver
n_driver <- a_m %>%
  dplyr::inner_join(meta) %>%
  dplyr::filter(count == "visitation") %>%
  dplyr::mutate(n_sp = n_pla + n_pol, 
                n_dr = n_sp - n_matched,
                n_dr_p = n_dr / n_sp)

src_bi_w <- n_driver %>%
  dplyr::filter(type == "z-bi" | type == "weight",
                study != "ballantyne") %>%
  dplyr::select(net_name, type, n_dr_p) %>%
  tidyr::spread(type, n_dr_p) %$%
  cor.test(weight, `z-bi`, method = "spearman")

# # Wilcoxon signed rank test invasive vs non invasive
# wt <- n_driver %>%
#   dplyr::select(site, inv, n_dr_p) %>%
#   dplyr::filter(!is.na(inv)) %>%
#   dplyr::mutate(n_dr_p = qlogis(n_dr_p)) %>%
#   tidyr::spread(inv, n_dr_p) %>%
#   dplyr::select(-site) %>%
#   as.matrix()
n_driver %<>%
  dplyr::filter(!is.na(inv))
# wt <-  wilcox.test(x = wt[, 1], y = wt[, 2], paired = T)


n_driver_wb <- dplyr::filter(n_driver, 
                             type == "z-bi" | type == "weight")

# Models
m0 <- glm(cbind(n_dr, n_matched) ~ n_pla * n_pol + study + inv + type,
          data = n_driver_wb,
          family = "binomial")
m_nr <- glm(cbind(n_dr, n_matched) ~ I(n_pla/n_pol) + study + inv + type,
          data = n_driver_wb,
          family = "binomial")
m8 <- glm(cbind(n_dr, n_matched) ~ I(n_pla/n_pol) + inv + type,
          data = n_driver_wb,
          family = "binomial")
m9 <- glm(cbind(n_dr, n_matched) ~ I(n_pla/n_pol) + study + type,
          data = n_driver_wb,
          family = "binomial")
m1 <- glm(cbind(n_dr, n_matched) ~ I(n_pla/n_pol) + type,
          data = n_driver_wb,
          family = "binomial")
m2 <- glm(cbind(n_dr, n_matched) ~ study + type,
          data = n_driver_wb,
          family = "binomial")
m3 <- glm(cbind(n_dr, n_matched) ~ I(n_pla + n_pol) + type,
          data = n_driver_wb,
          family = "binomial")
m4 <- glm(cbind(n_dr, n_matched) ~ n_pla + type,
          data = n_driver_wb,
          family = "binomial")
m5 <- glm(cbind(n_dr, n_matched) ~ n_pol + type,
          data = n_driver_wb,
          family = "binomial")
m6 <- glm(cbind(n_dr, n_matched) ~ inv + type,
          data = n_driver_wb,
          family = "binomial")
m7 <- glm(cbind(n_dr, n_matched) ~ study + inv + type,
          data = n_driver_wb,
          family = "binomial")
@

The studyed networks had levels of manageability between \Sexpr{round(min(1-dplyr::filter(n_driver, type == "z-bi")$n_dr_p), digits = 2)} and \Sexpr{round(max(1-dplyr::filter(n_driver, type == "z-bi")$n_dr_p), digits = 2)} (mean \Sexpr{round(mean(1-dplyr::filter(n_driver, type == "z-bi")$n_dr_p), digits = 2)}) when we considered bidirectional links weighted by the mutual dependences. This was in strong agreement  to the results obtained using the dependence asymmetry in which manageability ranged between \Sexpr{round(min(1-dplyr::filter(n_driver, type == "weight")$n_dr_p), digits = 2)} and \Sexpr{round(max(1-dplyr::filter(n_driver, type == "weight")$n_dr_p), digits = 2)} (Spearman rank correlation \Sexpr{round(src_bi_w$estimate, digits = 2)}, $p = \Sexpr{as.numeric(format(src_bi_w$p.value, digits = 2))}$). In addition we found that even when controling for diversity, invaded communities had were more difficult to manage than uninvaded ones. Out of the explored factors---total number of species, plant richness, pollinator richness and the ratio of plant to pollinator richness---only the ratio of plants to pollinator was retained in the final model (as determined by the AICc; \autoref{fig:n_driver_explanatory}, Table S3).

\begin{figure}
\centering
<<fig explaining n_driver, echo = FALSE, warning = F, message = F, results = "asis", fig.height=1.7, fig.width=3.245>>=

par_res <- as.data.frame(residuals(m8, "partial"))
names(par_res) <- paste0(make.names(names(par_res)), "_res")
par_res %<>%
  dplyr::bind_cols(m8$data) %>%
  dplyr::mutate(res_res = residuals(m8, "response"), 
                res_wor = residuals(m8, "working"))

par_res %>%
  ggplot(aes(x = inv, y = inv_res)) +
  # facet_wrap(~type) +
  geom_boxplot(size = 0.3,
               colour = "grey10", outlier.shape = 21, outlier.size = 1) +
  fer_theme +
  scale_x_discrete(labels = c("un-invaded", "invaded"), name = "") +
  ylab("adjusted manageability") +
  coord_flip() +
  theme(
        legend.position = "none",
				plot.margin = grid::unit(c(2, 1, 2, 0), "mm"), 
				# panel.grid.minor.x = element_blank(),
				panel.grid.minor.y = element_blank())

# p <- predict(m8, type = "response", se.fit = F)
# 
# n_driver_wb %>%
#   dplyr::mutate(fit = predict(m8, type = "response", se.fit = T)$fit,
#                 se =  predict(m8, type = "response", se.fit = T)$se) %>%
#   dplyr::filter(type == "z-bi" | type == "weight") %>% 
#   ggplot(aes(x = n_pla/n_pol, y = 1-n_dr_p)) +
#   geom_line(aes(y = 1-fit, colour = type, linetype = inv), size = 0.5) + 
#   geom_point(aes(fill = type, shape = inv), show.legend = T, size = 1.25) +
#   ylab("manegeability") + 
#   xlab("plant / pollinator richness") +
#   scale_fill_manual(values = c("#ffffff", "#bdbdbd"),
#                       name = "direction of control", 
#                       labels = c("asymmetry", "mutual dependence")) +
#   scale_colour_manual(values = c("black", "#bdbdbd"),
#                       name = "direction of control", 
#                       labels = c("asymmetry", "mutual dependence")) + 
#   scale_shape_manual(values = c(21, 23), 
#                      name = "invasion status", 
#                      labels = c("invaded", "non invaded")) +
#   scale_linetype_manual(values = c(1, 12), 
#                         name = "invasion status", 
#                         labels = c("invaded", "non invaded")) +
#   fer_theme +
#   theme(plot.margin = grid::unit(c(5, 1, 2, 0), "mm"), 
#         legend.position = "none", 
#         # legend.title = element_blank(),
#         legend.key = element_rect(fill = "white", 
#                                   colour = "white"),
#         legend.key.size = grid::unit(4, "mm"),
#         legend.background = element_rect(colour = "black", size = 0.2),
#         legend.box = "horizontal",
#         legend.direction = "vertical") 
@
\caption{\label{fig:n_driver_explanatory} Invaded communities have lower levels of manageability than uninvaded communities even when controling for the ratio of plant to pollinator richness. Adjusted manageability corrsponds to the partial working residuals of the invasion status.}
\end{figure}

<<randomisations z_scores, echo = FALSE, warning= FALSE, message = FALSE>>=
r <- r_w %>%
  dplyr::bind_rows(dplyr::mutate(r_d, type = "weight")) %>%
  dplyr::inner_join(meta) %>%
  dplyr::filter(study != "ballantyne") %>%
  dplyr::mutate(n_dr = n_pla + n_pol - n_matched)

# non-parametric
z_scores <- r$method %>%
  unique() %>%
  plyr::ldply(function(x){
    n_driver %>%
      dplyr::mutate(type = stringr::str_replace(type, "-", "_")) %>%
      dplyr::filter(type == "weight" | type == "z_bi") %>%
      dplyr::mutate(method = x)
  }) %>%
  dplyr::bind_rows(r) %>%
  dplyr::filter(!(type == "z_bi" & method == "r0")) %>%
  dplyr::group_by(net_name, method, type) %>%
  dplyr::mutate(z_r = rank(n_dr, na.last = NA),
                z_r = z_r/n(),
                z_s = qlogis(z_r),
                z_s = replace(z_s, (is.infinite(z_s) & z_s > 0) | z_s > qlogis(0.999), qlogis(0.999)),
                z_s = replace(z_s, is.infinite(z_s) & z_s < 0, qlogis(0.001))) %>%
  dplyr::filter(is.na(sim))

@

The manageability of empirical networks was, in general, not significantly different to the manageability of network randomisations that maintain the degree or the strength of individual species (\autoref{fig:randomisations}). However when comparing the empirical network to less constrained randomisations that maintained the original connectance but in which species had different degrees and strengths, we found that empirical networks tend to have smaller values of manageability. This pattern is even more marked when we maintained the network structure but randomised only the direction of the asymmetries (\autoref{fig:randomisations}).

\begin{figure}
\centering
<<fig randomisations, echo = FALSE, warning = F, message = F, fig.height=2.7, fig.width=3.245>>=

# z_scores <- r %>%
#   dplyr::group_by(net_name, method) %>%
#   dplyr::summarise(mu = mean(n_dr, na.rm = T),
#                    sigma = sd(n_dr, na.rm = T)) %>%
#   dplyr::inner_join(n_driver) %>%
#   dplyr::group_by() %>%
#   dplyr::mutate(z_s = (n_dr - mu)/sigma)

z_scores_method_order <- unique(z_scores$method)

z_scores %>%
  dplyr::group_by() %>%
  dplyr::mutate(method = factor(method, levels = z_scores_method_order),
                m_n = as.numeric(method),
                m_n = replace(m_n, m_n == 3, 3.5)) %>%
  dplyr::filter(!method %in% c("r00_both", "r00_ind")) %>%
  ggplot(aes(x = method, y = -1 * z_s)) +
  geom_rect(aes(xmin = 0.5, xmax = 4.5, ymin = -Inf, ymax = qlogis(0.025)), fill = "#f0f0f0") +
  geom_rect(aes(xmin = 0.5, xmax = 4.5, ymin = Inf, ymax = qlogis(0.975)), fill = "#f0f0f0") +

  # geom_hline(yintercept = c(-0), linetype = 2, alpha = 0.7, size = 0.25) + 
  geom_vline(aes(xintercept = 3.5), alpha = 0.6, size = 0.25) +
   geom_hline(yintercept = 0, size = 0.25, linetype = 2, colour = "grey30") +
  geom_boxplot(aes(fill = type), size = 0.3,
               colour = "grey10", outlier.shape = 21, outlier.size = 1) +
  # geom_point(aes(y = 9, colour = sign <= 0.05), shape = 8, size = 1) +
  scale_fill_manual(values = c("white", "#bdbdbd")) +
  scale_x_discrete(
    labels = rev(c("random\nassymetry", "maintain\nconnectance", "maintain vis. strength\nrandomise degree", "maintain vis. degree\nrandomise strength")),
    expand = c(0,0)) +
  scale_y_continuous(breaks = qlogis(c(0.001, 0.025, 0.5, 0.975,0.999)), 
                     labels = plogis(qlogis(c(0.001, 0.025, 0.5, 0.975,0.999)))) + 
  xlab("") +
    coord_flip() +
  ylab("rank of empirical manageability") + 
  fer_theme +
  theme(
        legend.position = "none",
				plot.margin = grid::unit(c(2, 1, 2, 0), "mm"), 
				# panel.grid.minor.x = element_blank(),
				panel.grid.minor.y = element_blank())

@
\caption{\label{fig:randomisations} The manageability of empirical networks was compared to network randomisations using a normalised rank. The shaded areas in light grey ($< 0.025$ and $> 0.975$) suggest a significant difference between the empirical network and its randomisations. The empirical manageability is much smaller than those of randomisations in which the direction of assymmetries has been randomised. In contrast the manageability of network in which the visitation strength or degree was mantained was not different to the manageability of the empirical networks. Dark grey and white boxplots represent manageabilities obtained using mutual dependencies and asymmetries respectively.}
\end{figure}

\subsection*{Relative importance of species}

<<rel importance, echo = FALSE, warning = F, message = F>>=
d_sp <- driver %>%
  plyr::ldply(function(x) {
    get_frequencies(x) %>%
      dplyr::mutate(type = attr(x, "type"),
                    scaled = attr(x, "scaled"))
  })

d_sp_bi <- driver_bi %>%
  get_frequencies() %>%
      dplyr::mutate(type = "z_bi",
                    scaled = FALSE)

d_sp <- dplyr::bind_rows(d_sp, d_sp_bi) %>%
  dplyr::inner_join(meta)
# d freq is the best proxy seems to be consistent with the invasive species being at the top rank for the bidirectional links
# d_sp %>%
#   dplyr::filter(inv, type == "z_bi") %>%
#   dplyr::group_by(net_name, threshold) %>% 
#   dplyr::mutate(d_freq_rank = rank(-d_freq, ties.method = "min")) %>%
#   dplyr::filter(species %in% c("p_4", "p_25"))
# 

correlations <- expand.grid(type = c("asymmetry", "max_dep"),
            scaled = c(TRUE, FALSE)) %>%
  plyr::ddply(c("type", "scaled"), function(x){
    d_sp %>%
      dplyr::filter(count == "visitation", 
                    study != "ballantyne") %>% 
      plyr::ddply(c("net_name", "threshold"), function(y){
        u <- y %>% 
          dplyr::filter(type == "z_bi" | 
                          (type == x$type & scaled == x$scaled)) %>%
          dplyr::group_by(type) %>%
          dplyr::mutate(d_freq_rank = rank(-d_reim)) %>%
          dplyr::select(species, type, d_freq_rank) %>%
          tidyr::spread(type, d_freq_rank) %>%
          `class<-`("data.frame")
        
        
        
        if(ncol(u) == 3) {
          a <- sets::as.set(u[u[, 2] == min(u[, 2]), 1])
          b <- sets::as.set(u[u[, 3] == min(u[, 3]), 1])
          c(rw2(u[,2], u[,3]), rw2(rank(-u[,2]), rank(-u[,3])), cor(u[,2], u[,3], method = "spearman"), sets::set_similarity(a, b))
        } 
        else c(NA, NA, NA, NA)
          
      })
  })

corr_imp <- expand.grid(type = c("asymmetry", "max_dep"),
            scaled = c(TRUE, FALSE)) %>%
  plyr::ddply(c("type", "scaled"), function(x){
    d_sp %>%
      dplyr::filter(study == "ballantyne") %>% 
      plyr::ddply(c("threshold"), function(y){
        u <- y %>% 
          dplyr::filter((type == "z_bi" & count == "importance") |
                          (type == x$type & scaled == x$scaled & count == "visitation")) %>%
          dplyr::group_by(type) %>%
          dplyr::mutate(d_freq_rank = rank(-d_reim)) %>%
          dplyr::select(species, type, d_freq_rank) %>%
          tidyr::spread(type, d_freq_rank) %>%
          `class<-`("data.frame")
        
        if(ncol(u) == 3) rw2(u[,2], u[,3])
        else NA
          
      })
  })

# correlations %>%
#   ggplot(aes(x = threshold, y = V1, colour = interaction(type, scaled))) +
#   geom_line(aes(linetype = net_name)) +
#   geom_smooth(se = F)

# 
# corr_imp %>%
#   ggplot(aes(x = threshold, y = V1, colour = interaction(type, scaled))) +
#   geom_line()

# d_sp %>%
#   dplyr::group_by(net_name, type, scaled) %>%
#   dplyr::mutate(importance = rank(-d_reim, ties.method = "min"),
#                 importance = importance / max(importance)) %>%
#   dplyr::filter(type == "z_bi" |
#                   (type == "asymmetry" & scaled == F)) %>%
#   ggplot(aes(x = net_name, y = importance)) +
#   geom_boxplot(aes(fill = interaction(type, scaled)))

@

We found a strong agreement between relative species' importance in the 11 networks for which we were able to calulate it using both mutual dependencies and asymmetries (Spearman's rank correlation ranged between $\rho = [\Sexpr{round(min(dplyr::filter(correlations, threshold == 0.5, type == "asymmetry", scaled == T)$V3, na.rm = T), digits = 2)}, \Sexpr{round(max(dplyr::filter(correlations, threshold == 0.5, type == "asymmetry", scaled == T)$V3, na.rm = T), digits = 2)}]$, median $\tilde{\rho} = \Sexpr{round(median(dplyr::filter(correlations, threshold == 0.5, type == "asymmetry", scaled == T)$V3, na.rm = T), digits = 2)})$. Indeed, when using the weighted rank correlation coefficient $r_{w2}$, we found that the agreement was stronger for highly ranked species than for lowly ranked species ($\tilde{r_{w2}} = \Sexpr{round(median(dplyr::filter(correlations, threshold == 0.5, type == "asymmetry", scaled == T)$V1, na.rm = T), digits = 2)}$ versus $\tilde{r_{w2}} = \Sexpr{round(median(dplyr::filter(correlations, threshold == 0.5, type == "asymmetry", scaled == T)$V2, na.rm = T), digits = 2)}$). Moreover both approaches identified a highly similar set of driver species (Jaccard similarity $J = [\Sexpr{round(min(dplyr::filter(correlations, threshold == 0.5, type == "asymmetry", scaled == T)$V4, na.rm = T), digits = 2)}, \Sexpr{round(max(dplyr::filter(correlations, threshold == 0.5, type == "asymmetry", scaled == T)$V4, na.rm = T), digits = 2)}]$, $\tilde{J} = \Sexpr{round(median(dplyr::filter(correlations, threshold == 0.5, type == "asymmetry", scaled == T)$V4, na.rm = T), digits = 2)})$. Therefore we employed the relative rankings obtained using asymmetries in the following analyses.  
 
<<importance, echo = FALSE, warning = F, message = F, results = "hide">>=
glmer.glmulti<-function(formula,data,random="",...){
  glmer(paste(deparse(formula, width.cutoff = 500),random),data=data,...)
}

setMethod('getfit', 'glmerMod', function(object, ...) {
  summ <- coef(summary(object))
  summ1 <- summ[,1:2,drop=FALSE]
  ## if (length(dimnames(summ)[[1]])==1) {
  ##     summ1 <- matrix(summ1, nr=1,
  ##                     dimnames=list(c("(Intercept)"),
  ##                     c("Estimate","Std. Error")))
  ## }
  cbind(summ1, df=rep(times =10000,length(fixef(object))))
})


imp <- mod %>% 
  coef.glmulti(select = 0.95) %>%
  as.data.frame() %>%
  dplyr::add_rownames("factor") %>%
  dplyr::mutate(pare = grepl("(", factor, fixed =T),
                factor = plyr::mapvalues(factor, 
                                         c("de", "n", "vi", "eig_cen", 
                                           "guildpol"),
                                         c("dependency strength", 
                                           "contribution to nestedness",
                                           "visitation strength",
                                           "eigen-centrality", 
                                           "guild (pollinator)"))) %>% 
  dplyr::arrange(-pare, -Importance, -Estimate, factor) %>% 
  dplyr::select(-pare)

print_table <- . %>%
  # dplyr::mutate(factor = paste0("$", factor, "$")) %>%
  magrittr::set_names(c("factor", "est.", "var", "No. mod.", "imp.", "C.I.")) %>% 
  dplyr::select(-var) %>%
  kable(format = "latex", align = "c", booktabs = T, digits = 2, escape = F, linesep = "") 
@

<<species, echo = FALSE, warning = F, message = F, fig.height=4.4, fig.width=3.1>>=
data <- mo
net <- "./data/V2.0/networks" %>%
	read_networks()
# pred <- expand.grid(de = c(seq(min(data$de), max(data$de), length = 20000), mean(data$de)),
#             n = c(seq(min(data$n), max(data$n), length = 2), mean(data$n)),
#             vi = c(seq(min(data$vi), max(data$vi), length = 2), mean(data$vi)), 
#             eig_cen = mean(data$eig_cen, na.rm = T), 
#             guild = "pla") %>%
#   dplyr::mutate(q = predict.glmulti(mod, 
#                                     select = 0.95, 
#                                     newdata = ., 
#                                     re.form = NA)$averages %>%
#                   as.vector(), 
#                 p = plogis(q)) %>%
#   dplyr::mutate(de = de * attr(data$de, "scaled:scale") + attr(data$de, "scaled:center"),
#                 vi = vi * attr(data$vi, "scaled:scale") + attr(data$vi, "scaled:center"),
#                 n = n * attr(data$n, "scaled:scale") + attr(data$n, "scaled:center"))
#   # dplyr::filter(de == mean(data$de)) %>%
#   
# p1 <- pred %>%
#   dplyr::filter(vi == unique(vi)[3]) %>%
#   ggplot(aes(x = de, y = p)) +
#   geom_line(aes(colour = as.factor(n), group = as.factor(n)), size = 1) +
#   scale_colour_manual(name = "contribution to nestedness",
#                       labels = c("max.", "mean", "min"),
#                       values = c("#cccccc", "#969696", "#525252")) +
#   # scale_x_continuous(expand = c(0,0)) +
#   scale_y_continuous(limits = c(0,1)) +
#   scale_x_log10() + 
#   # xlab("degree") +
#   # ylab("strength of dependencies") +
#   stat_contour(colour = "black", size = 0.75) +
#   fer_theme + theme(panel.grid = element_blank(), legend.position = "top") 
# 
# p2 <- pred %>%
#   dplyr::filter(n == unique(n)[3]) %>%
#   ggplot(aes(x = de, y = p)) +
#   geom_line(aes(colour = as.factor(vi), group = as.factor(vi)), size = 1) +
#   # scale_fill_gradient(name = "relative\nimportance", high = "#f0f0f0", low = "#525252") +
#   # scale_x_continuous(expand = c(0,0)) +
#   scale_y_continuous(limits = c(0,1)) +
#   scale_x_log10() + 
#   # xlab("degree") +
#   # ylab("strength of dependencies") +
#   stat_contour(colour = "black", size = 0.75) +
#   fer_theme + theme(panel.grid = element_blank(), legend.position = "top")
# 

guild <- c("pla", "pol") %>%
  plyr::ldply(function(y){
    o <- lapply(net, function(x) igraph::V(x)[igraph::V(x)$type == y]$name) %>%
      unlist() %>% unique()
    data.frame(guild = y, species = o)
  })

invasive_sp <- dplyr::filter(meta, inv) %>%
  dplyr::mutate(species = plyr::mapvalues(invader, 
                                          c("car", "op", "imp"),
                                          c("p_4", "p_25", "Impatiens glandulifera")), 
                invasive = T) %>%
  dplyr::select(net_name, species, invasive)

connected_sp <- data %>% dplyr::select(net_name, species) %>% 
  dplyr::mutate(connected = T)

s_p_s <- s_p %>%
  dplyr::full_join(invasive_sp) %>% 
  dplyr::mutate(invasive = replace(invasive, is.na(invasive), FALSE)) %>% 
  dplyr::inner_join(guild) %>%
  dplyr::inner_join(meta) %>%
  dplyr::filter(study != "ballantyne") %>%
  dplyr::inner_join(connected_sp)

dd <- data %>% lapply(as.vector) %>% as.data.frame()
dd <- s_p_s %>%
  dplyr::select(net_name, species, invasive, connected) %>%
  dplyr::inner_join(dd) %>%
  dplyr::mutate(pp = predict(mod, select = 0.95, newdata = ., re.form = NA)$averages,
                pp = as.vector(pp),
                pp = plogis(pp),
                de2 = de * attr(data$de, "scaled:scale") + attr(data$de, "scaled:center"))


# 
# d <- s_p_s %>%
#   dplyr::rename(n = nestedcontribution, 
#                 de = d_strength, 
#                 vi = v_strength) %>%
#   dplyr::select(de, n, vi, eig_cen, guild)
# 
# d %>% s_p_s %>%
#   dplyr::select(guild)
# 
# pp <-  predict(mod, newdata = d, select = 0.95, re.form = NA)$averages
# 
# species <- s_p_s %>%
#   dplyr::mutate(pp = plogis(as.vector(pp)))

trans <- function(x, orig){
  x * attr(orig, "scaled:scale") + attr(orig, "scaled:center")
}

b_trans <- function(x, orig){
  (x - attr(orig, "scaled:center")) / attr(orig, "scaled:scale")
}

# juju <- function(x) 10^x

# 
# pred2 <- expand.grid(de = b_trans(exp(c(seq(log(trans(min(data$de), data$de)),
#                                 log(trans(max(data$de), data$de)), 
#                                 length = 500))), data$de),
#             n = c(seq(min(data$n), max(data$n), length = 500)),
#             vi = mean(data$vi), 
#             eig_cen = mean(data$eig_cen, na.rm = T), 
#             guild = "pla") %>%
#   dplyr::mutate(q = predict.glmulti(mod, 
#                                     select = 0.95, 
#                                     newdata = ., 
#                                     re.form = NA)$averages %>%
#                   as.vector(), 
#                 p = plogis(q)) %>%
#   dplyr::mutate(de = de * attr(data$de, "scaled:scale") + attr(data$de, "scaled:center"),
#                 vi = vi * attr(data$vi, "scaled:scale") + attr(data$vi, "scaled:center"),
#                 n = n * attr(data$n, "scaled:scale") + attr(data$n, "scaled:center"))
# 
# p3 <- pred2 %>%
#   ggplot() +
#   geom_tile(aes(fill = p, x = de, y = n, z = p)) + 
#   scale_x_log10(expand = c(0,0)) +
#   scale_y_continuous(expand = c(0,0)) +
#   scale_fill_continuous(limits = c(0,1), low = "#ffffff", high = "#636363") +
#  
#   geom_point(data = s_p_s, aes(x = d_strength, y = nestedcontribution, shape = guild, colour = invasive), size = 1) +
#    # stat_contour(aes(x = de, y = n, z = p), 
#                # colour = "black", size = 0.5, bins = 5) +
#   fer_theme + 
#   scale_shape_manual(values = c(21, 22)) +
#   scale_color_manual(values = c("#525252","#e41a1c")) + 
#   theme(panel.grid = element_blank(), legend.position = "none",
# 				plot.margin = grid::unit(c(0, 0, 2, 0), "mm")) +
#   xlab("dependency strength") +
#   ylab("contribution to nestedness")
# 
# 
# pred3 <- expand.grid(de = b_trans(exp(c(seq(log(trans(min(data$de), data$de)),
#                                 log(trans(max(data$de), data$de)), 
#                                 length = 500))), data$de),
#             n = c(mean(data$n)),
#             vi = b_trans(exp(c(seq(log(trans(min(data$vi), data$vi)),
#                                 log(trans(max(data$vi), data$vi)),
#                                 length = 500))), data$vi),
#             # vi = seq(min(data$vi), max(data$vi), length.out = 500),
#             eig_cen = mean(data$eig_cen, na.rm = T), 
#             guild = "pla") %>%
#   dplyr::mutate(q = predict.glmulti(mod, 
#                                     select = 0.95, 
#                                     newdata = ., 
#                                     re.form = NA)$averages %>%
#                   as.vector(), 
#                 p = plogis(q)) %>%
#   dplyr::mutate(de = de * attr(data$de, "scaled:scale") + attr(data$de, "scaled:center"),
#                 vi = vi * attr(data$vi, "scaled:scale") + attr(data$vi, "scaled:center"),
#                 n = n * attr(data$n, "scaled:scale") + attr(data$n, "scaled:center"))
# 
# p4 <- pred3 %>%
#   ggplot() +
#   geom_tile(aes(x = de, y = vi, z = p, fill = p)) + 
#   scale_x_log10(expand = c(0,0)) +
#   scale_y_log10(expand = c(0,0)) +
#   scale_fill_continuous(limits = c(0,1), low = "#ffffff", high = "#636363", name = "") +
#   geom_point(data = s_p_s, aes(x = d_strength, y = v_strength, shape = guild, colour = invasive), size = 1, show.legend = F) +
#   # geom_contour(aes(x = de, y = vi, z = p), colour = "black", size = 0.5, bins = 5) +
#   fer_theme + theme(panel.grid = element_blank(), legend.position = "top",
# 				plot.margin = grid::unit(c(5, 0, -2, 0), "mm"),
# 				legend.key.height = grid::unit(3, "mm"),
# 				legend.key.width = grid::unit(6, "mm")) +
#   scale_shape_manual(values = c(21, 22)) +
#   scale_color_manual(values = c("#525252","#e41a1c")) + 
#   xlab("") +
#   ylab("visitation strength")
# 
# ratio <- function(x){
#   o <- round(x * 1000)
#   rep(c(1,2), times = c(o, 1000-o)) %>%
#     matrix(ncol = 1)
# }

# 
# pred4 <- expand.grid(de = b_trans(exp(c(seq(log(trans(min(data$de), data$de)),
#                                 log(trans(max(data$de), data$de)), 
#                                 length = 500))), data$de),
#             n = mean(data$n),
#             vi = c(-1, 0, 1),
#             # vi = seq(min(data$vi), max(data$vi), length.out = 500),
#             eig_cen = mean(data$eig_cen, na.rm = T), 
#             guild = "pla") %>%
#   dplyr::filter(!(n == max(data$n) & vi == min(data$vi)),
#                 !(n == min(data$n) & vi == max(data$vi))) %>%
#   dplyr::mutate(q = predict.glmulti(mod, 
#                                     select = 0.95, 
#                                     newdata = ., 
#                                     re.form = NA)$averages %>%
#                   as.vector(), 
#                 p = plogis(q)) %>%
#   dplyr::mutate(de = de * attr(data$de, "scaled:scale") + attr(data$de, "scaled:center"),
#                 vi = vi * attr(data$vi, "scaled:scale") + attr(data$vi, "scaled:center"),
#                 n = n * attr(data$n, "scaled:scale") + attr(data$n, "scaled:center"))
# 
# pred4 %>%
#   ggplot(aes(x = de, y = p)) +
#   geom_line(aes(colour = as.factor(n), linetype = as.factor(vi))) + 
#   scale_x_log10(expand = c(0,0)) +
#   fer_theme
# 
# 

pred4 <- data.frame(de = rep(b_trans(exp(c(seq(log(trans(min(data$de), data$de)),
                                log(trans(max(data$de), data$de)),
                                length = 500))), data$de),3),
            n = rep(c(-1,0,1), each = 500),
            vi = rep(c(-1,0,1), each = 500),
            type = rep(c("exp", "mean", "exp"), each = 500),
            # vi = seq(min(data$vi), max(data$vi), length.out = 500),
            eig_cen = mean(data$eig_cen, na.rm = T),
            guild = "pla") %>%
  dplyr::filter(!(n == 2 & vi == -2),
                !(n == -2 & vi == 2)) %>%
  dplyr::mutate(q = predict.glmulti(mod,
                                    select = 0.95,
                                    newdata = .,
                                    re.form = NA)$averages %>%
                  as.vector(),
                p = plogis(q)) %>%
  dplyr::mutate(de = de * attr(data$de, "scaled:scale") + attr(data$de, "scaled:center"),
                vi = vi * attr(data$vi, "scaled:scale") + attr(data$vi, "scaled:center"),
                n = n * attr(data$n, "scaled:scale") + attr(data$n, "scaled:center"))




# multiplot(p4, p3, layout = ratio(0.57))

@

Although plants showed significantly higher levels of importance than pollinators (Mann-Withney-Wilcoxon test, $p \Sexpr{fix_small_pvalue(wilcox.test(pp ~ guild, data = dd, alternative = "greater")$p.value)}$), this difference can be largely explained by the strength of dependency of the species (the sum of the dependencies for a given species). Indeed, when averaging over the set of GLMMs that accounted at least 95\% of the evidencee based on AICc, we found that the strength of dependency  is the single most important factor determining the relative importance of species for network control (\autoref{table:driver_model}\todo{consider moving the table to thes supplementary}, \autoref{fig:driver_model_alt}). In contrast, the number of visits a species makes (or receives) and its contribution to nestedness have only a marginal effect on its relative importance.

<<invasive species differ?, echo = FALSE, warning = F, message = F, results = "hide">>=
for_invasive <- dd %>%
  dplyr::mutate(prediction = as.vector(predict.glmulti(mod, select = 0.95, newdata = .)$averages), 
                predictionp = plogis(prediction), 
                res = d_reim - predictionp) %>%
  dplyr::filter(guild == "pla")

inv_test <- wilcox.test(d_reim ~ invasive, data = for_invasive, alternative = "less")
t.test(dplyr::filter(for_invasive, invasive)$res)
@

In addition, in the ten communities that were invaded, invasive species were invariably classified as a driver species. In general, the relative importance of invasive species was significantly larger than those of the other plants in the studied communities (Mann-Whitney U Test, $p =  \Sexpr{fix_small_pvalue(inv_test$p.value)}$). However this difference can be fully explained by the explanatory variables in our model as all the residuals for the invasive species were virtually zero.  

\begin{table}
\centering
\small
<<table importance 1, echo = FALSE, warning = F, message = F, results = "asis">>=
print_table(imp)
@
\caption{\label{table:driver_model} The strength of dependency, contribution to nestedness and visitation strength had a significative effect on all the models that accounted for 95\% of the evidence based on AICc. Coeficient estimates were avaraged following \textcite{Buckland1997a}; confidence intervals were calculated following \textcite{Lukacs2010}.}
\end{table}

\begin{figure}
\centering
<<fig species alt, echo = FALSE, warning = F, message = F, fig.height=2.2, fig.width=3.1>>=
pred4 %>%
  ggplot() +
  geom_line(aes(x = de, y = p, linetype = type, colour = type, group = interaction(n, vi)), show.legend = F, size = 0.5) +
  scale_x_log10(expand = c(0,0)) +
   geom_point(data = dplyr::arrange(dd, invasive), aes(x = de2, y = pp, fill = invasive, shape = guild, size = invasive), show.legend = F) +
    scale_shape_manual(values = c(21, 23)) +
  scale_size_manual(values = c(1,1.5)) +
  scale_fill_manual(values = c("white","#e41a1c")) + 
  scale_color_manual(values = c("#525252", "black")) +
  scale_linetype_manual(values = c(2, 1)) +
  xlab("dependency strength") +
  ylab("relative importance") +
  fer_theme
@
\caption{\label{fig:driver_model_alt} Dependency strength is the single most important factor explaining the importance of species for network control. Visitation levels and contribution to nestedness had a significant albeit small effect on the importance (dashed lines correspond to \textpm one standard deviation on these factors). Invasive species (red) were invariably classified as driver species (those having the maximum importance for network control.}
\end{figure}

<<interact with invasive , echo = FALSE, warning = F, message = F, results = "asis">>=

dd_inv <- dd %>%
  dplyr::filter(net_name %in% invasive_sp$net_name) %>%
  plyr::ddply("net_name", function(x){
    inv <- invasive_sp$species[invasive_sp$net_name == x$net_name[1]]
    if(length(inv) == 0){
      x %>% 
      dplyr::mutate(int_inv = "none")
    } else{
      interacting <- igraph::adjacent_vertices(net[[x$net_name[1]]], inv)[[1]] %>% names
      x %>% 
        dplyr::mutate(int_inv = species %in% interacting)
    }
  })

# dd_inv %>%
#   # dplyr::group_by(net_name, int_inv) %>%
#   # dplyr::summarise(int_inv_d_reim_mean = mean(d_reim)) %>%
#     ggplot(aes(x = int_inv, y = d_reim)) +
#   geom_boxplot()

dd_inv_t <- dd_inv %>%
  dplyr::group_by(net_name, int_inv) %>%
  dplyr::summarise(int_inv_d_reim_mean = mean(d_reim)) %>%
  tidyr::spread(int_inv, int_inv_d_reim_mean)


dd_inv_test <- wilcox.test(dd_inv_t[, 3][[1]], dd_inv_t[, 2][[1]], paired = F)

@

No significant difference on importance between pollinators interacting with invasive species or not.

\fi

\section*{Discussion}

Our results reveal that invasive mutualists are driver species in the communities they invade. As driver species, they occupy a dominant role in which changes on their abbundance have the potential to cascade trough the community and in turn affect the abbundances of several other species in the community. They achieve that by alterning the distribution of the strength of mutual dependencies and the interaction asymmetries---which constitute the foundations of the structure of mutualistic networks \autocite{Vazquez2004, Bascompte2006}. Furthermore, these structural differences caused by invasive species at a community level are reflected in a potential decrease in our ability to alter the state of the community. 

We confirm previous studies that suggested that in contrast with other kind of complex networks, the structure of ecological networks renders them remarkably difficult to control \autocite{Liu2011, Ruths2014}. In a hypothetical situation in which the goal were to regulate the abbundances of all species in a pollination community, our results suggest that we would need to directly intervene the abbundances of at least 40-90\% of those species. Fully controling an ecological community is out of the question, as designing and implementating the management interventions needed is currently impractical. Nevertheless, the ``manageability'' of an ecological community, which is related to the number of species that would require a directed intervention, can provide a simple, straightforward, and theoretically-informed indication of the degree to which the community is self-regulated and therefore how difficult it might be to modify its state. 

Asymmertic depedences have previously found to be related to the stability and persistence of pollination networks \autocite{Memmott2004, Vazquez2004, Lever2014, Astegiano2015}. Here, we demonstrate that the manageability of mutualistic networks is also governed by the asymetric nature of mutual dependeces. Indeed, our empirical networks have markedly lower levels of manageability compared to randomisations in which the visitation network was unchanged, but the patterns of dependence were broken by randomising the direction of the asymmetries. However, consistent with previous results \autocite{Liu2011}, we show that the manageability of empirical networks was indistinguishable from that of networks with a random structure (in terms of modularity and nestedness for example) but that maintained the degree or strength of each species in the community. This suggest that the asymmetries at the species (specialization-generalization asymmetries) and the link level (interaction's dependence asymmetries) appear to be sufficiently defined by the distribution of species degree and strength \autocite{Melian2002}. Furthermore, we found that invasive species, by altering the patterns of assymetry, reduce the manageability of their communities. This result is in agreement with previous studies that suggest that invasors erode native pollination webs by ursurpating interactions and exarcerbate the asymmerties in the network, which in turn might increasse the stability of the community \autocite{Aizen2008, Bartomeus2008}. 

The changes on the asymmetries found in the invaded networks are not only reflected in the manageability at a community level: invaders were found to be driver species in every single community in which they were present. Invasive plants have usually been found to be super-generalists thus playing a central role in their networks \autocite{Vila2009, Palacio2016}. Nevertheless, we found that dependence strength, rather than generalism or other metrics of centrality, explains best the importance of species for the community dynamics. Specifically, driver species tend to be those whose interaction partners are collectively more dependent on them than the other way arround. However, the influence of dependence strength was held regardless of wheter the species was invasive or not, which corroborates previous observations that suggest that exotic species, although having different traits\todo{add cite}, are not inherently different to their native counterparts, but are rather governed by the same rules of niche and competition that determine species coexistence \autocite{Stouffer2014}. Invasive species have been shown to have the ability to transform the structure of ecological communities \autocite{Aizen2008, Albrecht2014}, our results suggest that they also may have the ability to heavily influence the abbundances of other species in the ecosystem.

Because of their effects on other species in the community, driver species might be natural candidates for management interventions. For instance, despite inconsistent outcomes, our results suggest that current restoration approaches that focus on direct eradication of invasive species might indeed be an effective way to modify ecosystem state. Nevertheless, our results also indicate that removals must be executed with caution as invaded commmunities tend to be dependent on them and therefore vulnerable to their erradication \autocite{Traveset2013, Albrecht2014}. Although useful for identifying conservation priorities, our approach is different to previous attempts to quantify species importance that concentrate on measures of centrality, position, coextintion or uniqueness \autocite{Jordan2006,Jordan2009, Lai2012, McDonald-Madden2016}. Instead the concept of driver species is more akin to the original concept of keystone species, which illustrated how changes on the abbundance of a key species in turn affect the abbundances of other members of the community \autocite{Paine1969, Paine1995}. However, while the keystone species were traditionally identified by infering the effects of a perturbation on a community's population dynamics \autocite{Mills1993}, the driver species concept operates the other way round, and uses the communuty dynamics, underpinned by the interspecific effects, to infer the effects of a perturbation. While it is challenging to quantify the dependence of species in an ecological community, an experimental approach to identofy dynamically important species might be even more difficult\todo{add cite}. 

Here we ilustrate how a control theoretic approach can be used to study the effect on mutualistic communities of a major driver of global change, however it can be easily extended to understand the structural effects of other kind of preturbations and species interactions. Moreover, we see great potential by explicitly integrating control theory with dynamics models of species densities \autocite{Cornelius2013, Gibson2016}. From an ecological perspective, it can provide key insight on determining the relationship between controlability and species coexistence, as well as determining the trade-offs between persistence at the species and the community level. From a conservation perspective, a combined approach can be useful, not only to idetify ideal targets for management interventions, but also to design informed, rather than hopeful, interventions that achieve restoration goals.

\section*{Acknoledgements}

The authors thank Dr. Takeuki Uno for the insight provided to find the set of all maximum matching algorithms, and Jason Tylianakis, Bernat Bramon, Matthew Hutchinson, and Marilia Gaiarsa for feedback in early stages of the project. EFC acknowledges the support from the University of Canterbury Doctoral Scholarship, the University of Canterbury Meadow Mushroooms Postgraduate Scholarship, a New Zealand International Doctoral Research Scholarship, and a travel grant from the European Space Agency. DBS ackloledges the support of a Marsden Fast-Start grant and a Rutherford Discovery Fellowship, administered by the Royal Society of New Zealand.


\printbibliography

\end{document}