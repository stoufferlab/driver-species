---
title: "The manageability of pollination networks in an invasion context"
subtitle: "Supporting Information"
author: "E. Fernando Cagua, Kate L. Wootton, Daniel B. Stouffer"
classoption: a4paper
csl: ecology-letters.csl
output:
  bookdown::pdf_document2:
    fig_crop: no
    keep_tex: yes
  html_document: default
  word_document: default
header-includes:
- \usepackage{setspace}
- \usepackage{float}
- \renewcommand{\thefigure}{S\arabic{figure}}
- \renewcommand{\thetable}{S\arabic{table}}
- \usepackage{booktabs}
- \usepackage[tableposition=top]{caption} 
documentclass: artikel1
bibliography: references.bib
nocite: | 
  @Lopezaraiza-Mikel2007, @Bartomeus2008
---

\doublespacing

```{r libraries, echo = F, include = F}
library(igraph)
library(magrittr)
library(dplyr)
library(latex2exp)
library(ggplot2)
library(RColorBrewer)

"../code/functions" %>% 
	list.files(full.names = T) %>%
	plyr::l_ply(source)

"../code/plotting_functions" %>% 
	list.files(full.names = T) %>%
	plyr::l_ply(source)
 
mutate_cond <- function(.data, condition, ..., envir = parent.frame()) {
  condition <- eval(substitute(condition), .data, envir)
  .data[condition, ] <- .data[condition, ] %>% dplyr::mutate(...)
  .data
}

```

```{r load data, include = F}
net <- "../data/processed/networks" %>%
	read_networks()
meta <- readr::read_csv("../data/ntw_info.csv") %>% dplyr::tbl_df() %>%
	dplyr::rename(count = method)
n_driver <- readRDS("../data/processed/n_driver.rds")
manag_models <- readRDS("../data/processed/models_manageability.rds")
src_bi_w <- readRDS("../data/processed/manageability_bi_vs_weight.rds")
r_w <- readRDS("../data/processed/random_weights.rds") %>% dplyr::tbl_df() %>%
  dplyr::rename_("net_name" = ".id")
r_d <- readRDS("../data/processed/random_directions.rds") %>% dplyr::tbl_df() %>%
  dplyr::rename_("net_name" = ".id")
a_m <- readRDS("../data/processed/n_matched_all_types.rds") 

prop <- expand.grid(c("asymmetry", "max_dep"), 
                    c("scaled_FALSE", "scaled_TRUE")) %>% plyr::alply(1)
driver <- c("../data/processed/matching_frequency") %>% 
  list.files(full.names = T) %>%
  lapply(list.files, full.names = T) %>% 
  unlist() %>% 
  lapply(read_allRDS)
driver <- mapply(function(x, y){
  attr(x, "type") <- as.character(y[,1])
  attr(x, "scaled") <- stringr::str_split(as.character(y[,2]), "_") %>% unlist() %>% extract(2) %>% as.logical()
  return(x)
}, driver, prop)
driver_bi <- "../data/processed/matching_frequency_bi" %>% 
  read_allRDS()

n_matched <- readRDS("../data/processed/n_matched.rds")

```

```{r plot theme, echo = FALSE, warning = F, message = F}
fer_theme <- theme_bw() +
	theme(text = element_text(family = "Helvetica"),
	      title = element_text(size = 7, hjust = 0),
	      legend.title = element_text(size = 8),
	      legend.text = element_text(size = 7),
				axis.text = element_text(size = 7),
				axis.title = element_text(size = 8, hjust = 0.5), 
				strip.text = element_text(size = 8, hjust = 0), 
				strip.background = element_blank(),
				plot.margin = grid::unit(c(5, 0.5, 2, 0), "mm"),
				panel.grid = element_blank())
```

```{r example networks, include = F, message = F, warning = F, }

sp_names_fancy <- c(TeX("$p_1$"), TeX("$p_2$"), TeX("$p_3$"), TeX("$a_1$"), TeX("$a_2$"))
sp_names_fancy_b <- c(TeX("$\\mathbf{p_1}$"), TeX("$\\mathbf{p_2}$"), TeX("$\\mathbf{p_3}$"), TeX("$\\mathbf{a_1}$"), TeX("$\\mathbf{a_2}$"))

sp_names <- c("p1", "p2", "p3", "a1", "a2")

adj_matrix <- c(0,0,0,1,0,
								0,0,0,2,5,
								0,0,0,0,0,
								0,0,1,0,0,
								0,0,1,0,0) %>%
	matrix(nrow = 5, byrow = T)

example_net <- adj_matrix %>% 
	graph_from_adjacency_matrix(mode = "undirected", weighted = TRUE) 
igraph::V(example_net)$type <- c(F, F, F, T, T)
igraph::V(example_net)$name <- sp_names

base_net <- example_net
bi_net <- example_net %>%
	keep_largest_component() %>%
	bipartite_digraph(type = "z-bi", weight.type = "asymmetry") 
as_net <- example_net %>%
	keep_largest_component() %>%
	bipartite_digraph(type = "weight", weight.type = "asymmetry")

fam <- "Helvetica"
# layout is based on the bidirectional network
set.seed(1)

lay <- bi_net %>%
	layout_nicely()
v_c <- "white"
l_c <- "black"
l_s <- 0.9
ma <- c(0,0,0,0)
label_pos_x <- -1
label_pos_y <- 1

pal <- RColorBrewer::brewer.pal(5, "PuOr")


# BIDIRECTIONAL MATCHINGS


as_mat <- bi_net %>%
	digraph_bipartite() %>% 
	max_bipartite_match()

as_all_mat <- bi_net %>%
	digraph_bipartite(type = "z-bi") %>%
	igraph::make_line_graph() %>%
	igraph::complementer() %>% 
	igraph::max_cliques(min = as_mat$matching_size) %>%
	rev()

text_pos_x <- 0.5
text_pos_y <- -0.7

base_bi_net <- bi_net
E(bi_net)$weight <- round(E(bi_net)$weight, 1)

nets <- 1:length(as_all_mat) %>%
	plyr::llply(function(x){
		
		igraph::E(bi_net)$matched <- 2
		igraph::E(bi_net)$matched[as_all_mat[[x]]] <- 4
		
		igraph::E(bi_net)$matched_col <- 1
		igraph::E(bi_net)$matched_col[as_all_mat[[x]]] <- 5
		
		igraph::V(bi_net)$matched <- 2
		igraph::V(bi_net)$matched[igraph::V(bi_net)$name %in%
																ends(bi_net, as_all_mat[[x]])[, 2]] <- 4
		
		igraph::V(bi_net)$matched_border <- 1
		igraph::V(bi_net)$matched_border[igraph::V(bi_net)$name %in%
																ends(bi_net, as_all_mat[[x]])[, 2]] <- 5
		
		igraph::V(bi_net)$superior <- 1
		igraph::V(bi_net)$superior[igraph::V(bi_net)$name %in%
																ends(bi_net, as_all_mat[[x]])[, 1]] <- 2
		
		igraph::V(bi_net)$superior_shape <- "circle"
		igraph::V(bi_net)$superior_shape[igraph::V(bi_net)$name %in%
																ends(bi_net, as_all_mat[[x]])[, 1]] <- "square"
		
		names_fancy <- sp_names_fancy
		# names_fancy[igraph::V(bi_net)$name %in%
		# 														ends(bi_net, as_all_mat[[x]])[, 1]] <-
		# 	sp_names_fancy_b[igraph::V(bi_net)$name %in%
		# 														ends(bi_net, as_all_mat[[x]])[, 1]]
		
		matching_weight <- sum(E(bi_net)$weight[as_all_mat[[x]]])
		
		n_edges <- length(igraph::E(bi_net))
		has_cycles <- igraph::E(bi_net)[setdiff(1:n_edges, as_all_mat[[x]])] %>%
			igraph::delete_edges(bi_net, .) %>% 
			igraph::is_dag() %>%
			magrittr::not()
		
		list(
			bi_net = bi_net,
			names_fancy = names_fancy,
			as_mat = as_mat, 
			as_all_mat = as_all_mat[[x]], 
			matching_weight = matching_weight,
			has_cycles = has_cycles
		)
	
})

nets <- nets[order(!unlist(lapply(nets, function(x) x$has_cycles)), unlist(lapply(nets, function(x) x$matching_weight)), decreasing = T)]
```


# Finding a complex network's matchings

Our approach to find the minumum number of driver nodes relies on finding maximum matchings and maximum cardinality matchings. 

We start with a directed network in which the direction of the link represents the direction of control (Figure \@ref(fig:fig-direction-of-control)a). 
We then construct an alternative representation of the directed network in which each node of the directed network is represented by two nodes that indicate their outgoing and incoming links respectively (Figure \@ref(fig:fig-direction-of-control)b). 
Finding a maximum matching in this alternative representation is equivalent to finding the largest possible set of edges in which one node on the left-hand side is connected to at most one node on the right-hand side. 
To find the maximum matching we use the push-relabel algorithm implemented in `max_bipartite_matching` in the R package igraph 1.0.1 [@Csardi2006a]. 
Once we have the matching (shown in the Figure \@ref(fig:fig-direction-of-control)b) it is then easy to identify the roles of each node in this representation: nodes on the left-hand side that are connected to a matched (purple) link are superior while those connected to a matched link on the right-hand side are matched. 
This information can then be mapped back to the original representation to identify the control paths and the driver nodes in the network (Figure \@ref(fig:fig-direction-of-control)c). 
Figure \@ref(fig:fig-direction-of-control)d, e, and f ilustrate this approach for a network with bidirectional links.

```{r fig-direction-of-control, echo = F, message = F, warning = F, fig.width = 6.2, fig.height = 3.4, results = "hide", fig.cap = "**Finding a maximum matching in a complex network**. (a & d) Directed networks that indicate the direction of control between species. (b & e) Alternative bipartite representations of the directed networks. (c & f) The matchings in the bipartite representation mapped back to the original network."}
# par(mfrow=c(2,2), mar=c(0,0,0,0))
bi_sp_names_fancy <- c( TeX("$p_1^-$"), TeX("$p_2^-$"), TeX("$p_3^-$"), TeX("$a_1^-$"), TeX("$a_2^-$"), TeX("$p_1^+$"), TeX("$p_2^+$"), TeX("$p_3^+$"), TeX("$a_1^+$"), TeX("$a_2^+$"))

bi_sp_names_fancy_b <- c( TeX("$p_1^-$"), TeX("$p_2^-$"), TeX("$p_3^-$"), TeX("$a_1^-$"), TeX("$a_2^-$"), TeX("$\\mathbf{p_1^+}$"), TeX("$\\mathbf{p_2^+}$"), TeX("$\\mathbf{p_3^+}$"), TeX("$\\mathbf{a_1^+}$"), TeX("$\\mathbf{a_2^+}$"))


# par(mfrow=c(2,3), mar= c(0,0,0,0))
layout(matrix(c(1,2,3,4, 5, 6, 7, 7, 7), 3, 3, byrow = TRUE),
  	heights=c(8,8,2))
par( mar=c(0,0,0,0))
# ASYMMETRY
as_net %>% 
	plot(layout = lay, 
			 vertex.color = v_c, 
			 vertex.size = 35,
			 vertex.label = sp_names_fancy,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 edge.label = round(E(.)$weight,1), 
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s,
			 edge.curved = F,
			 edge.arrow.size = 0.5,
			 margin = ma)

text(label_pos_x, label_pos_y, "(a)", adj = c(0,0), font = 2, cex = 0.9)


as_mat <- as_net %>%
	digraph_bipartite() %>% 
	max_bipartite_match()

as_all_mat <- as_net %>%
	digraph_bipartite() %>%
	igraph::make_line_graph() %>%
	igraph::complementer() %>% 
	igraph::max_cliques(min = as_mat$matching_size) %>%
	rev()

text_pos_x <- 0.5
text_pos_y <- -0.7

base_as_net <- as_net
E(as_net)$weight <- round(E(as_net)$weight, 1)

bi_as_net <- as_net %>%
	digraph_bipartite() 

igraph::V(bi_as_net)$matched <- 2
igraph::V(bi_as_net)$matched[igraph::V(bi_as_net)$name %in%
														 	ends(bi_as_net, as_all_mat[[1]])[, 2]] <- 4
igraph::V(bi_as_net)$matched[1:5] <- NA

igraph::V(bi_as_net)$superior <- 30
igraph::V(bi_as_net)$superior[igraph::V(bi_as_net)$name %in%
														 	ends(bi_as_net, as_all_mat[[1]])[, 1]] <- 40
igraph::V(bi_as_net)$superior[6:10] <- 35

igraph::E(bi_as_net)$matched <- 2
igraph::E(bi_as_net)$matched[as_all_mat[[1]]] <- 4

igraph::E(bi_as_net)$matched_col <- 1
igraph::E(bi_as_net)$matched_col[as_all_mat[[1]]] <- 5
																 
bi_as_net %>%
	plot(layout = matrix(c(rep(c(-0.5, 0.9), each = 5), rep(seq(-0.8, 0.8, length.out = 5), 2)), ncol = 2), 
			 # vertex.size = igraph::V(.)$superior,
			 vertex.size = 30, 
			 vertex.label = c(bi_sp_names_fancy[6:10], bi_sp_names_fancy[1:5]),
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 # vertex.label.cex = igraph::V(.)$superior * 0.1 + 0.9,
			 # vertex.color = pal[igraph::V(.)$matched],
			 vertex.color = NA,
			 edge.color = pal[E(.)$matched_col],
			 edge.label = NA, 
			 edge.width = E(.)$matched/2,
			 edge.label.family = fam,
			 edge.label.color = igraph::E(.)$matched,
			 edge.label.cex = l_s,
			 edge.curved = F,
			 edge.arrow.size = 0.5,
			 margin = ma, 
			 rescale = F)

text(-0.95, 0.825, "(b)", adj = c(0,0), font = 2, cex = 0.9)

E(as_net)$matched <- 2
E(as_net)$matched[as_all_mat[[1]]] <- 4

E(as_net)$matched_col <- 1
E(as_net)$matched_col[as_all_mat[[1]]] <- 5

igraph::V(as_net)$matched <- 2
igraph::V(as_net)$matched[igraph::V(as_net)$name %in%
														ends(as_net, as_all_mat[[1]])[, 2]] <- 4

igraph::V(as_net)$matched_border <- 1
igraph::V(as_net)$matched_border[igraph::V(as_net)$name %in%
														ends(as_net, as_all_mat[[1]])[, 2]] <- 5

igraph::V(as_net)$superior <- 1
igraph::V(as_net)$superior[igraph::V(as_net)$name %in%
													 	ends(as_net, as_all_mat[[1]])[, 1]] <- 2

igraph::V(as_net)$superior_shape <- "circle"
igraph::V(as_net)$superior_shape[igraph::V(as_net)$name %in%
													 	ends(as_net, as_all_mat[[1]])[, 1]] <- "square"

names_fancy <- sp_names_fancy
# names_fancy[igraph::V(as_net)$name %in%
# 							ends(as_net, as_all_mat[[1]])[, 1]] <-
# 	sp_names_fancy_b[igraph::V(as_net)$name %in%
# 									 	ends(as_net, as_all_mat[[1]])[, 1]]

matching_weight <- sum(E(as_net)$weight[as_all_mat[[1]]])

as_net %>% 
	plot(layout = lay, 
			 vertex.size = 30,
			 vertex.shape = igraph::V(.)$superior_shape,
			 vertex.label = names_fancy,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 vertex.label.cex = igraph::V(.)$superior * 0.1 + 0.9,
			 # vertex.shape = igraph::V(.)$vertex.shape,
			 vertex.color = pal[igraph::V(.)$matched],
			 vertex.frame.color = pal[igraph::V(.)$matched_border],
			 edge.color = pal[E(.)$matched_col],
			 edge.label = NA, 
			 edge.width = E(.)$matched/2,
			 edge.label.family = fam,
			 edge.label.color = igraph::E(.)$matched,
			 edge.label.cex = l_s,
			 edge.curved = F,
			 edge.arrow.size = 0.5,
			 margin = ma) %>% 
	print()

text(label_pos_x, label_pos_y, "(c)", adj = c(0,0), font = 2, cex = 0.9)


bi_net %>% 
	plot(layout = lay, 
			 vertex.color = v_c, 
			 vertex.size = 35,
			 vertex.label = sp_names_fancy,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 edge.label = round(E(.)$weight,1), 
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s,
			 edge.curved = T,
			 edge.arrow.size = 0.5,
			 margin = ma)
text(label_pos_x, label_pos_y, "(d)", adj = c(0,0), font = 2, cex = 0.9)

i <- 1
bi_bi_net <- nets[[i]]$bi_net %>%
	digraph_bipartite(type = "z-bi")

igraph::E(bi_bi_net)$matched <- 2
igraph::E(bi_bi_net)$matched[nets[[i]]$as_all_mat] <- 4

igraph::E(bi_bi_net)$matched_col <- 1
igraph::E(bi_bi_net)$matched_col[nets[[i]]$as_all_mat] <- 5

igraph::V(bi_bi_net)$matched <- 2
igraph::V(bi_bi_net)$matched[igraph::V(bi_bi_net)$name %in%
														 	ends(bi_bi_net, nets[[i]]$as_all_mat)[, 1]] <- 4
igraph::V(bi_bi_net)$matched[6:10] <- NA

igraph::V(bi_bi_net)$superior <- 30
igraph::V(bi_bi_net)$superior[igraph::V(bi_bi_net)$name %in%
																ends(bi_bi_net, nets[[i]]$as_all_mat)[, 2]] <- 40
igraph::V(bi_bi_net)$superior[1:5] <- 35

bi_names_fancy <- bi_sp_names_fancy
bi_names_fancy[igraph::V(bi_bi_net)$name %in%
							 	ends(bi_bi_net, nets[[i]]$as_all_mat)[, 2]] <-
	bi_sp_names_fancy_b[igraph::V(bi_bi_net)$name %in%
												ends(bi_bi_net, nets[[i]]$as_all_mat)[, 2]]


bi_bi_net %>%
	plot(layout = matrix(c(rep(c(0.9,-0.5), each = 5), rep(seq(-0.8, 0.8, length.out = 5), 2)), ncol = 2), 
			 # vertex.size = igraph::V(.)$superior,
			 vertex.size = 30,
			 vertex.label = bi_sp_names_fancy, 
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 # vertex.color = pal[igraph::V(.)$matched],
			 vertex.color = NA, 
			 edge.color = pal[igraph::E(.)$matched_col],
			 # edge.label = round(E(.)$weight,1), 
			 edge.label.family = fam,
			 edge.width = E(.)$matched/2,
			 edge.label.color = l_c,
			 edge.label.cex = l_s,
			 edge.curved = F,
			 edge.arrow.size = 0.5,
			 margin =  ma, 
			 # asp = 0.5, 
			 rescale = F)

text(-0.95, 0.825, "(e)", adj = c(0,0), font = 2, cex = 0.9)

nets[[1]]$bi_net %>%
	plot(layout = lay, 
			 vertex.label = nets[[1]]$names_fancy,
			 vertex.shape = igraph::V(.)$superior_shape,
			 vertex.size = 30,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 vertex.color = pal[igraph::V(.)$matched],
			 vertex.frame.color = pal[igraph::V(.)$matched_border],
			 edge.color = pal[igraph::E(.)$matched_col],
			 # edge.label = round(E(.)$weight,1), 
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s,
			 edge.curved = T,
			 edge.arrow.size = 0.5,
			 edge.width = E(.)$matched/2,
			 margin = ma, 
			 # asp = 0.5, 
			 rescale = T)

text(label_pos_x, label_pos_y, "(f)", adj = c(0,0), font = 2, cex = 0.9)

## LEGEND 
plot.new()
legend(0.55, 0.8, legend = c("unmatched link", "matched link"), horiz = TRUE,
			 lty = 1, 
			 col = pal[c(1, 5)],
			 lwd = 2, cex = 0.9, xjust=0.5, yjust=0.8, bty = "n")

legend(0.89, 0.8, legend = c("unmatched node", "matched node"), horiz = TRUE,
			 pch = 21, 
			 pt.bg = pal[c(2, 4)],
			 col = pal[c(1,5)],
			 pt.cex = 2,
			 cex = 0.9, xjust=0.5, yjust=0.8, bty = "n")

legend(0.7, 0.35, legend = c("superior node", "non-superior node"),
			 horiz = TRUE,
			 pch = c(22, 21), 
			 # pt.bg = pal[c(2, 4)],
			 pt.cex = 2,
			 cex = 0.9, xjust=0.5, yjust=0.8, bty = "n")
```

The algorithm implemented in `max_bipartite_matching`, however, is only able to find **one** of the possibly many maximum matchings in a network. 
Though one maximum matching is enough to calculate *n~D~* and hence to provide indication of a communitie's manageability, it is not sufficient to estimate the role of individual species. 
To do that, we need to calculate all possible maximum matchings (or, equivalently, all maximal cardinality matchings in weighted networks like ours). 
To do this, we again start from the alternative bipartite representation in Figure \@ref(fig:fig-direction-of-control)b and assign an identity to each of the links in the network (shown as numbers in Figure \@ref(fig:fig-finding-all-matchings)a).
We will call this bipartite representation *B*. 
We then construct the line graph of the alternative bipartite representation *L(B)* (Figure \@ref(fig:fig-finding-all-matchings)b). 
Each node in *L(B)* represents a link in *B* and these are connected to each other only if and only if they share a common node in *B*. 
We then calculate the complement graph of *L(B)* and identify all the maximal cliques (Figure \@ref(fig:fig-finding-all-matchings)c). 
Here some extra definitions are neccessary. 
First, the complement of *L(B)*, *H*, is a graph with the same nodes as *L(B)* but that has a link between two given nodes if and only if there is not a link in *L(B)*. 
Second, a clique is a subset of nodes such that any two of them are linked. 
Lastly, a maximum clique is a clique such that there are no cliques with more nodes [@Gutin2013]. 
In this example, there are two maximum cliques: that one formed by 1, 3 and 5, and the one formed by 2, 3 and 5. 
The final step is then to map these cliques into the original network to obtain all possible maximum cardinality matchings as shown in Figure 1 in the main text.

```{r fig-finding-all-matchings, echo = F, message = F, warning = F, fig.width = 6.2, fig.height = 1.8, results = "hide", fig.cap = "**Finding all possible maximum cardinality matchings**. (a) Alternative bipartite representation of the directed network in Figure \\@ref(fig:fig-direction-of-control)a. (b) Line graph of the network in a. (c) Complement of the network in b. The two maximum cliques are shown in red and blue."}
layout(matrix(c(1,2,3,4, 5, 6), 2, 3, byrow = TRUE),
  	heights=c(8,1))
par( mar=c(0,0,0,0))


as_mat <- as_net %>%
	digraph_bipartite() %>% 
	max_bipartite_match()

as_all_mat <- as_net %>%
	digraph_bipartite() %>%
	igraph::make_line_graph() %>%
	igraph::complementer() %>% 
	igraph::max_cliques(min = as_mat$matching_size) %>%
	rev()

text_pos_x <- 0.5
text_pos_y <- -0.7

base_as_net <- as_net
E(as_net)$weight <- round(E(as_net)$weight, 1)

bi_as_net <- as_net %>%
	digraph_bipartite() 

igraph::V(bi_as_net)$matched <- 2
igraph::V(bi_as_net)$matched[igraph::V(bi_as_net)$name %in%
														 	ends(bi_as_net, as_all_mat[[1]])[, 2]] <- 4
igraph::V(bi_as_net)$matched[1:5] <- NA

igraph::V(bi_as_net)$superior <- 30
igraph::V(bi_as_net)$superior[igraph::V(bi_as_net)$name %in%
														 	ends(bi_as_net, as_all_mat[[1]])[, 1]] <- 40
igraph::V(bi_as_net)$superior[6:10] <- 35

igraph::E(bi_as_net)$matched <- 2
		igraph::E(bi_as_net)$matched[as_all_mat[[1]]] <- 4
# 																 
# bi_as_net %>%
# 	plot(layout = matrix(c(rep(c(-0.5, 0.9), each = 5), rep(seq(-0.8, 0.8, length.out = 5), 2)), ncol = 2), 
# 			 # vertex.size = igraph::V(.)$superior,
# 			 vertex.size = 30, 
# 			 vertex.label =  c(bi_sp_names_fancy[6:10], bi_sp_names_fancy[1:5]),
# 			 vertex.label.family = fam,
# 			 vertex.label.color = l_c,
# 			 # vertex.label.cex = igraph::V(.)$superior * 0.1 + 0.9,
# 			 # vertex.color = pal[igraph::V(.)$matched],
# 			 vertex.color = NA,
# 			 # edge.color = pal[E(.)$matched],
# 			 edge.label = NA, 
# 			 # edge.width = E(.)$matched/2,
# 			 edge.label.family = fam,
# 			 edge.label.color = igraph::E(.)$matched,
# 			 edge.label.cex = l_s,
# 			 edge.curved = F,
# 			 edge.arrow.size = 0.5,
# 			 margin = ma, 
# 			 rescale = F)
# 
# text(-0.95, 0.825, "a)", adj = c(0,0))

###

bi_as_net %>% 
	delete_vertices(c(1, 3, 7)) %>% 
	plot(vertex.size = 35, 
			 vertex.label = c(bi_sp_names_fancy[6:10], bi_sp_names_fancy[1:5])[-c(1,3,7)], 
			 vertex.color = "white", 
			 edge.label = 1:5,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s,
			 edge.curved = F,
			 edge.arrow.size = 0.5,
			 margin = ma, 
			 layout = layout_in_circle)

text(-1, 1, "(a)", adj = c(0,0), font = 2, cex = 0.9)

set.seed(2)
bi_as_net %>%
		igraph::make_line_graph() %>% 
	plot(vertex.size = 35, 
			 # vertex.label = c(bi_sp_names_fancy[6:10], bi_sp_names_fancy[1:5])[-c(1,3,7)], 
			 vertex.color = "white", 
			 # edge.label = 1:5,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s,
			 edge.curved = F,
			 edge.arrow.size = 0.5,
			 margin = ma, 
			 layout = layout_in_circle)

text(-1, 1, "(b)", adj = c(0,0), font = 2, cex = 0.9)


nam <- ends(bi_net, 1:length(igraph::E(bi_as_net)))

comp <- bi_as_net %>%
		igraph::make_line_graph() %>% 
		igraph::complementer() 


colo <- c("#d7191c", "grey70", "#d7191c", "#2b83ba", "grey70", "#2b83ba", "#814E6B")
vertices <- layout_in_circle(comp)
plot.new()
scaling_x <- 0.94
scaling_y <- 0.58
centring_x <- -0.01
centring_y <- 0.2
# polygon((vertices[c(1,3,5), 1] + 1)/2 * scaling_x + centring_x, (vertices[c(1,3,5), 2] + 1) /2 *scaling_y +centring_y, col = "#d7191c")
par(new = T)
comp %>%
	plot(vertex.size = 35, 
			 # vertex.label = c(bi_sp_names_fancy[6:10], bi_sp_names_fancy[1:5])[-c(1,3,7)], 
			 vertex.color = NA, 
			 # edge.label = 1:5,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 edge.color = colo, 
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s,
			 edge.curved = F,
			 edge.arrow.size = 0.5,
			 margin = ma, 
			 layout = layout_in_circle)



text(-1, 1, "(c)", adj = c(0,0), font = 2, cex = 0.9)

# 
# igraph::max_cliques(min = matching$matching_size, 
# 												max = matching$matching_size,
# 												file = temporary_file)
## Legends

plot.new()
text(0.5, 0.5, expression(paste(italic(B), ": bipartite representation")), adj = c(0.5,0.75))

plot.new()
text(0.5, 0.5, expression(paste(italic(L(B)), ": line graph of ", italic(B))), adj = c(0.5,0.75))

plot.new()
text(0.5, 0.5, expression(paste(italic(H), ": complement of ", italic(L(B)))) , adj = c(0.5,0.75))
```

In the main text, we show all maximum cardinality matchings for a simple example network. 
To further ilustrate our methodology, here we also show the approach for the smallest of our empirical networks, the uninvaded network at site 10 (Table S1; Figure \@ref(fig:fig-SA-exp)). 
The largest component of this network is composed of 16 species of which 2 are non-invasive plants and the rest are pollinators. 
The one-to-one relationship between matched and superior nodes implies that in order to achieve full network controllability, most pollinators would be unmatched, and hence driver species that require external intervention. 
At the same time, both plants in the community, *Heracleum sphpndylum* and *Rubus fructicosus*, and one of the pollinators, *Orthotylus/Lygocorus*, tend to be classified as superior nodes.

```{r fig-SA-exp, echo = F, message = F, warning = F, fig.width = 6.2, fig.height = 6.2, results = "hide", fig.cap = "**Illustration of the procedure with an empirical network**. (a) The initial visitation network. (b) The directed network in which the direction of control is determined based on the mutual dependences and assymetries. (c) One of the possible maximum matchings calculated using the procedures illustrated in the Figures \\@ref(fig:fig-direction-of-control) and \\@ref(fig:ig-finding-all-matchings)."}
par(mfrow=c(2,2), mar=c(0,0,0,0))
n <- keep_largest_component(net$SA_exp)
replace_names <- data.frame(sp_name = igraph::V(n)$name) %>%
	dplyr::mutate(sp_number = 1:nrow(.),
								sp_letter = letters[sp_number], 
								sp_name = stringr::str_replace(sp_name, "[0-9]", ""),
								sp_name = stringr::str_replace(sp_name, "\\?rutitarse", "rufitarse"))
set.seed(7)

la <- igraph::layout_nicely(n)
n %>%
	plot(vertex.color = v_c, 
			 vertex.size = 15,
			 vertex.label = replace_names$sp_letter,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 vertex.label.cex = 0.9,
			 edge.label = round(igraph::E(.)$weight,1), 
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s*0.8,
			 edge.curved = F,
			 edge.arrow.size = 0.5,
			 margin = ma, 
			 layout = la)
text(label_pos_x, label_pos_y, paste0("(", letters[1], ")"), adj = c(0,0), font = 2, cex = 0.8)

as_net <- n %>%
	bipartite_digraph(type = "weight", keep = "all", weight.type = "asymmetry", scale = F)
	
as_net %>%	
	plot(vertex.color = v_c, 
			 vertex.size = 15,
			 vertex.label = replace_names$sp_letter,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 vertex.label.cex = 0.9,
			 edge.label = round(igraph::E(.)$weight,2), 
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s*0.8,
			 edge.curved = F,
			 edge.arrow.size = 0.5,
			 margin = ma, 
			 layout = la)

text(label_pos_x, label_pos_y, paste0("(", letters[2], ")"), adj = c(0,0), font = 2, cex = 0.8)


as_mat <- as_net %>%
	digraph_bipartite() %>% 
	max_bipartite_match()

as_all_mat <- as_net %>%
	digraph_bipartite() %>%
	igraph::make_line_graph() %>%
	igraph::complementer() %>% 
	igraph::max_cliques(min = as_mat$matching_size) %>%
	rev()

text_pos_x <- 0.5
text_pos_y <- -0.7

base_as_net <- n
# E(as_net)$weight <- round(E(as_net)$weight, 1)

or <- as_all_mat %>%
	plyr::laply(function(x){
		sum(E(as_net)$weight[x])
	}) %>% order(decreasing = T)

as_all_mat <- as_all_mat[or]

1 %>%
	plyr::l_ply(function(x){
		
		E(as_net)$matched <- 2
		E(as_net)$matched[as_all_mat[[x]]] <- 4
		
		E(as_net)$matched_col <- 1
		E(as_net)$matched_col[as_all_mat[[x]]] <- 5
		
		igraph::V(as_net)$matched <- 2
		igraph::V(as_net)$matched[igraph::V(as_net)$name %in%
																ends(as_net, as_all_mat[[x]])[, 2]] <- 4
		igraph::V(as_net)$matched_border <- 1
		igraph::V(as_net)$matched_border[igraph::V(as_net)$name %in%
																ends(as_net, as_all_mat[[x]])[, 2]] <- 5
		
		igraph::V(as_net)$superior <- 1
		igraph::V(as_net)$superior[igraph::V(as_net)$name %in%
																ends(as_net, as_all_mat[[x]])[, 1]] <- 2
		
		igraph::V(as_net)$superior_shape <- "circle"
		igraph::V(as_net)$superior_shape[igraph::V(as_net)$name %in%
																ends(as_net, as_all_mat[[x]])[, 1]] <- "square"
		
		# names_fancy <- sp_names_fancy
		# names_fancy[igraph::V(as_net)$name %in%
		# 														ends(as_net, as_all_mat[[x]])[, 1]] <-
		# 	sp_names_fancy_b[igraph::V(as_net)$name %in%
		# 														ends(as_net, as_all_mat[[x]])[, 1]]
		# 
		matching_weight <- sum(E(as_net)$weight[as_all_mat[[x]]])
		
		as_net %>% 
			plot(layout = la, 
					 vertex.size = 15,
					 vertex.label = replace_names$sp_letter,
					 vertex.shape = igraph::V(.)$superior_shape,
					 vertex.label.family = fam,
					 vertex.label.color = l_c,
					 vertex.label.font = igraph::V(.)$superior,
					 vertex.label.cex = igraph::V(.)$superior * 0.1 + 0.9,
					 # vertex.shape = igraph::V(.)$vertex.shape,
					 vertex.color = pal[igraph::V(.)$matched],
					 vertex.frame.color = pal[igraph::V(.)$matched_border],
					 edge.color = pal[E(.)$matched_col],
					 edge.label = NA, 
					 edge.width = E(.)$matched/2,
					 edge.label.family = fam,
					 edge.label.color = igraph::E(.)$matched_col,
					 edge.label.cex = l_s,
					 edge.curved = F,
					 edge.arrow.size = 0.5,
					 margin = ma) %>% 
			print()
		
		igraph::V(as_net)$name <- sp_names
		
		text(label_pos_x, label_pos_y, paste0("(", letters[2+x], ")"), adj = c(0,0), font = 2, cex = 0.8)
		text(text_pos_x + 0.2, text_pos_y + 0.1, cex = 0.85,
				 paste0("D = ", length(igraph::V(as_net)) - as_mat$matching_size, "\n",
				 			 "matching size: ", as_mat$matching_size, "\n",
				 			 "matching weight: ", round(matching_weight, 1)))
})

plot.new()

legend(0.28, 0.95, legend = replace_names$sp_name, horiz = F, bty = "n", text.font = 3, cex = 0.8)
legend(0.2, 0.95, legend = replace_names$sp_letter, horiz = F, bty = "n", text.font = 2, cex = 0.8)

# library(grid)
# library(gridExtra)
# 
# ttt <- tableGrob(replace_names) 
# grid.newpage()
# grid.draw(ttt)

```


# Control profiles

@Ruths2014 proposed a heuristic-based method to provide insight of what might be required to control a network.
The method is based on the idea that the reasons behind a node being classified as a driver node can be precisely identified, and that the relative contribution of these reasons can be used to characterise the control profile of the network. 
Specifically, nodes can be deemed to be driver nodes for three reasons:

1. **Because it is a source node**. Source nodes are nodes that exclusively have outgoing links. Therefore, other nodes cannot control it, but instead, it must be externally controlled. 
2. **Because of an external dilation**. Dilations occur whenever a control signal needs to branch out in order to reach all nodes in a network. 
One kind of dilation, which arises due to a surplus of sink nodes (those that only have incoming links) is called external dilation. 
This concept might be easier to understand by looking at Figure \@ref(fig:fig-SA-exp)c. 
The source node *a* branches out into nine paths, but it can only control one of them. 
We say then, that the sink nodes *d* to *k* become driver nodes because of an external dilation.
3. **Because of an internal dilation**. The remaining dilations (those that do not arise from a surplus of sink nodes) are called internal dilations. 
Node *j* in Figure \@ref(fig:fig-SA-exp)c and the driver nodes in Figure \@ref(fig:fig-matchings-bidirectional) are examples of this category.

Mathematically, the number of driver nodes $N_D$ is the sum of the number of source nodes, the number of external dilation points, and the number of internal dilation points, $N_D = N_s + N_e + N_i$. 
A network can then be characterised by the relative proportion of the three kind of controls $$\eta_s + \eta_e + \eta_i = 1,$$ where $\eta_s = N_s/N_D$, $\eta_e = N_e/N_D$, and $\eta_i = N_i/N_D$. 
These terms can be calculated with relative ease.
$N_D$ can be calculated using a maximum matching algorithm. 
$N_s$ can be calculated by inspecting the network's degree distribution.
$N_e = max(0,N_t - N_s)$, where $N_t$ is the number of sink nodes in the network.
And we can solve for $N_i$ once we have all other information.

Applying this framework to our networks directed by the asymmetry we identify that they are all external dilation dominated (Figure \@ref(fig:fig-control-profiles)).
@Ruths2014 explains that "external-dilation-dominated networks exhibited strong aspects of top-down control". 
Because of the surplus of sink nodes, an external intervention that is applied to a source node will induce a correlated response among their subordinate species. 
For example, an increase in the abundance of *Heracleum sphondylum* (Figure \@ref(fig:fig-SA-exp)) is likely to induce an increase in the abundance of the pollinators it interacts with.
Therefore it can be expected that in order to fully control the network it is not sufficient to apply interventions to the source nodes. 

The control profile of our pollination networks provides additional justification to our decision to determine the importance of a species, not only by virtue of $f_D$, but also by $f_S$.
Many species that act like control sinks in our network, will be classified as a driver node, because they are necessary to *fully* control the dynamics of the community, as opposed to playing a central role influencing the abundance of other species in the community.

Using this approach also highlights the importance of appropiately selecting the direction of control (See Section 6). 
A network with bidirectional links weighted by the mutual dependences would have zero source nodes and zero sink nodes. 
Therefore, the control profile of such a network would have been completely uninformative, as it would just highlight that the proportion of internal dilations is $\eta_i = 1$.

```{r fig-control-profiles, echo = F, message = F, warning = F, fig.width = 6.2, fig.height = 2.6, results = "hide", fig.cap= "**Control profiles of the studied networks**. Following @Ruths2014, profiles are shown in a ternary plot in which the cornders correspond to points (1, 0, 0), (0, 1, 0), and (0, 0, 1) in the three-dimensional $(\\eta_s, \\eta_e, \\eta_i)$ space such that $\\eta_s + \\eta_e + \\eta_i = 1$, and $\\eta_s, \\eta_e$, and $\\eta_i > 0$."}
n_driver <- meta %>%
  dplyr::inner_join(n_matched) %>% 
  dplyr::mutate(n_driver = 1 - n_matched / (n_pla + n_pol))

profiles <- net %>%
	plyr::ldply(function(x){
		d <- x %>% 
			keep_largest_component() %>%
			bipartite_digraph(type = "weight",
												keep = "all",
												weight.type = "asymmetry", 
												scale = F)
		E(d)$weight <- 1
		out_degree <- igraph::degree(d, mode = "out") 
    in_degree <- igraph::degree(d, mode = "in") 
    n_sources <- sum(out_degree > 0 & in_degree == 0) 
    n_sinks <- sum(out_degree == 0 & in_degree > 0) 
    n_ext_dil <- max(0,n_sinks - n_sources) 
    n_sp <- length(igraph::V(d))
    data.frame(n_sources = n_sources, n_sinks = n_sinks,  
               n_ext_dil = n_ext_dil, n_sp = n_sp)
	}) %>%
	dplyr::rename(net_name = .id) %>%
	dplyr::mutate()

profiles %<>%
	dplyr::inner_join(n_driver) %>%
	dplyr::mutate(n_driver = n_sp - n_matched,
								n_int_dil = n_driver - n_sources - n_ext_dil,
								eta_s = n_sources / n_driver,
								eta_e = n_ext_dil / n_driver,
								eta_i = n_int_dil / n_driver)

library(ggtern) 

	
# p1 <- 
profiles %>%
 	dplyr::filter(!grepl("bal_bin", net_name)) %>%
 	ggplot(aes(x = eta_s, z = eta_e, y = eta_i)) + 
	geom_mask() +
  geom_point(fill = "gray70", shape = 21, size = 2, alpha = 0.7) + 
	coord_tern(expand = T) +
 	labs(x = "$\\eta_s$",
 			 y = "$\\eta_i$",
 			 z = "$\\eta_e$",
 			 Tarrow = "internal dilation",
 			 Rarrow = "external dilation",
 			 Larrow = "source") +
	fer_theme +
 	# tern_limit(0.2,0.2, 1) +
 	theme(panel.grid = element_line(colour = "grey90", size = 0.3),
 				plot.title = element_text(margin = margin(-14, 0, 0, 0)),
 				plot.margin = margin(t = -10),
 				plot.background = element_blank()) +
 	percent_custom("%") +
 	theme_nogrid_minor() +
 	theme_showarrows() +
 	theme_arrowlarge() +
 	theme_latex(TRUE) 
# 
# p2 <- profiles %>% 
# 	dplyr::filter(!grepl("bal_bin", net_name)) %>%
# 	ggplot(aes(eta_e, n_driver/n_sp)) +
# 	geom_point(shape = 21) +
# 	# scale_x_log10() + scale_y_log10() +
# 	geom_smooth(method = "lm", colour = "black", size = 0.5) +
# 	# scale_x_log10() +
# 	fer_theme +
# 	theme(plot.margin = margin(r = 2, t = 18, b = 21),
#  				plot.background = element_blank()) +
# 	xlab(expression(eta[s])) +
# 	ylab(expression(n[D]))
# 
# grid.arrange(grobs = list(
# 	grid::textGrob("(a)", x = 0, y = -2, gp = grid::gpar(font = 2, cex = 0.7), just = "left"),
# 	grid::textGrob("(b)", x = 0, y = -2, gp = grid::gpar(font = 2, cex = 0.7), just = "left"), 
# 	p1, p2), nrow = 2, heights = c(1,30), widths = c(1, 1.4))
```

# Properties of empirical networks

```{r calc-network-properties, echo = F, message = F}
net_prop <- net %>%
	plyr::ldply(function(x){
		x <- keep_largest_component(x)
		n_pla <- sum(igraph::V(x)$type == "pla")
		n_pol <- sum(igraph::V(x)$type == "pol")
		bipartite::networklevel(igraph::as_incidence_matrix(x, 
																												types = igraph::V(x)$type == "pla",
																												attr = "weight"),
														index = c("connectance", "web asymmetry", 
																			"ISA", 
																			"weighted NODF")) %>%
			as.list() %>% as.data.frame() %>%
			dplyr::mutate(n_sp = length(igraph::V(x))) %>%
			dplyr::mutate(n_pla = n_pla,
										n_pol = n_pol)
	})

library(xtable)

names(net_prop)[1] <- "net_name"

net_prop <- meta %>%
	dplyr::mutate(n_s_t = n_pla + n_pol) %>%
	dplyr::select(-n_pla, -n_pol) %>%
	dplyr::inner_join(net_prop)

```

The networks studied had species richness ranging between `r min(net_prop$n_s_t)` and `r max(net_prop$n_s_t)` (`r min(net_prop$n_sp)`-`r max(net_prop$n_sp)` when considering only the largest component in each network). 
As shown by the network asymmetry *AS* [@Bluthgen2007] the networks overall had a low ratio of plants to pollinators. 
Furthermore, networks had relatively low levels of nestedness [when measured using the quantitative version of the NODF index; @Almeida-Neto2011]. Details for each network can be found in Table S1.

```{r table-network-properties, results = "asis", echo = F, message = F, warning = F, fig.width = 6.2, fig.height = 4.8, sanitize = FALSE}

net_prop %>%
	dplyr::select(-net_name, -count, -net) %>%
	dplyr::filter(study != "ballantyne") %>%
	dplyr::arrange(study, site, inv) %>%
	mutate_cond(inv == FALSE, invader = "—") %>%
  dplyr::mutate(site = rep(1:dplyr::n_distinct(site), each = 2),
                inv = plyr::mapvalues(inv, c(TRUE, FALSE), c("yes", "no")),
                study = plyr::mapvalues(study, 
                                        c("bartomeus", "lopezaraiza"),
                                        c("Cap de Creus, Spain",
                                          "Bristol, United Kingdom"))) %>%
	dplyr::select(site, invader, n_s_t, n_sp, n_pla, n_pol, connectance, web.asymmetry, weighted.NODF, study) %>%
	dplyr::rename_("$R$" = "n_s_t",
								 "$n_p$" = "n_pla",
								 "$n_a$" = "n_pol",
								 "location" = "study",
								 "$n_s$" = "n_sp",
								 "$c$"= "connectance", 
								 "NODF" = "weighted.NODF",
								 # "$\\bar{a}$" = "interaction.strength.asymmetry",
								 "$AS$" = "web.asymmetry") %>%
	xtable::xtable(caption = "\\textbf{Properties of the analysed plant-pollinator communities}. Invasive plants were \\textit{Carpobrotus affine acinaciformis} (car), \\textit{Opuntia stricta} (op), and \\textit{Impatients grandulifera} (imp). All properties, with the exception of the networks' total species richness ($R$), correspond to the network's largest component. We show the number of species ($n_s$), the number of plants ($n_p$), the number of pollinators ($n_a$), the network connectance ($c$), the network assymetry ($AS$), and the network nestedness (NODF index). British networks were assembled by Lopezaraiza-Mikel et al. (2007), Spanish were networks assembled by Bartomeus et al. (2008).") %>%
	print(#floating.environment = "sidewaystable", 
		comment = FALSE, sanitize.text.function = function(x){x}, include.rownames = FALSE, caption.placement = "top", booktabs = T)

# knitr::kable(meta)
```

# Visitation as a proxy for species interdependence

Visitation frequency has been shown to be an appropriate surrogate for inter-specific effects in pollination networks [@Vazquez2005; @Bascompte2006]. 
Nevertheless visitation is not equivalent to pollen deposition and might be insufficient to reflect the dependences of plants on animals and vice versa [@Alarcon2010; @King2013]. 
We therefore investigated the effect of calculating the dependences using visitation or pollination effectiveness and importance---two metrics more proximate to plant reproductive success (Figure \@ref(fig:fig-visitation-vs-deposition-vs-importance)).
We did this by comparing *(i)* the manageability of the community and *(ii)* the percentage of interactions that maintained the direction of dependence. 
To do that, we used data collected by @Ballantyne2015 from a low diversity pollination community at a dry lowland heathland in Dorset, UK  (50° 43.7'N 2° 07.2'W). 
First, deposition networks were quantified using the mean single visit deposition---the number of conspecific pollen grains effectively deposited on a virgin stigma during a single visit by a particular animal [@NeEman2010; @King2013; @Ballantyne2015]. 
Second, visitation networks were constructed counting the visits to flowers during Single Visit Depositions. 
Finally, pollinator importance networks were constructed as the product of pollinator efficiency and visit frequency. 

```{r fig-visitation-vs-deposition-vs-importance, echo = F, message = F, warning = F, fig.width = 6.2, fig.height = 4, results = "hide", fig.cap= "**Distribution of interaction weights for the pollen deposition, visitation and pollinator importance networks**. Note that the *x* axis in the density plots have been log-transformed."}


p <- net[meta$net_name[meta$study == "ballantyne" & meta$count != "binary"]] %>%
	plyr::ldply(function(x) {
		data.frame(vname = igraph::E(x) %>% attr("vnames"), 
							weight = igraph::E(x)$weight)
	}, .inform = T) %>%
	dplyr::rename_("net_name" = ".id") %>%
	dplyr::mutate(net_name_f = factor(net_name,  
																		levels = c( 'bal_eff','bal_vis','bal_imp'),
																		labels = c("Deposition", "Visitation", "Importance")), 
	              pla = stringr::str_split_fixed(vname, "\\|", 2)[, 1],
	              pol = stringr::str_split_fixed(vname, "\\|", 2)[, 2]) %>%
  plyr::dlply("net_name_f", function(x){
    p1 <- x %>%
      ggplot(aes(x = pol, y = pla)) +
      geom_tile(aes(fill = weight, width = 0.9, height = 0.9)) + 
      coord_fixed() +
      scale_fill_gradient(low = "#f0f0f0", high = "#525252") +
      ylab("plants") +
      xlab("pollinators") + 
      fer_theme +
      theme(axis.text = element_blank(), 
            axis.ticks = element_blank(), 
            legend.position = "right", 
            legend.title = element_blank(), 
            plot.margin = grid::unit(c(6,0,2,5), "mm"),
            panel.grid = element_blank(),
            legend.key.width = grid::unit(4, "mm"),
            legend.key.height = grid::unit(4, "mm"))
    p2 <- x %>% ggplot(aes(x = weight)) +
      scale_x_log10() +
      stat_density(aes(y =..density..), geom = "line") +
      xlab("link weight") + 
      ylab("density") +
      ggtitle(x$net_name_f[1]) +
      fer_theme +
      theme(plot.margin = grid::unit(c(2,2,0,0), "mm"))
    list(p1, p2)
  }) 

cowplot::plot_grid(p[[1]][[2]], p[[1]][[1]], p[[2]][[2]], p[[2]][[1]], p[[3]][[2]], p[[3]][[1]], ncol = 2, rel_widths = c(1.5,2), labels = c("(a)", "", "(b)","", "(c)"), label_size = 8)  
```

At a network scale, despite marked differences in the distribution of weights of the three networks (Figure \@ref(fig:fig-visitation-vs-deposition-vs-importance)), the driver node density *n~D~* was consistent among the three different approaches (`r 1-round(n_driver$n_driver[n_driver$net_name == "bal_eff"], digits = 2)` for deposition, `r 1-round(n_driver$n_driver[n_driver$net_name == "bal_vis"], digits = 2)` for the visitation, and `r 1-round(n_driver$n_driver[n_driver$net_name == "bal_imp"], digits = 2)` for the pollinator importance network).

The choice of weighting used can also have an impact on at the species level.
Therefore we calculated *f~D~* and *f~S~* (the frequency at which each species is classified as a driver or superior node, respectively, within the set of all possible matchings in a network) and calculated it's correlation among all three weighting schemes.
Although visitation and deposition produce moderately different results, we found a very strong agreement between the order produced by visitation and importance (Table S2). 
Finally, we also investigated whether the asymmetry of mutual dependence, which defines the direction of control, was consistent among the three possible weighting schemes. We found again that the direction of the dominant dependence was maintained was consistent for 95\% of the interactions weighted by visitation or importance, the two most appropriate metrics for pollinator and plant dependence (Table S2).

```{r table-correlations-visitation-vs-efficiency, echo = FALSE, warning = F, message = F, results = "asis"}
d_sp <- driver %>%
  plyr::ldply(function(x) {
    o <- get_frequencies(x) %>%
      dplyr::mutate(type = attr(x, "type"),
                    scaled = attr(x, "scaled"))
    net_names_with_extension <- unique(o$net_name) %>% as.character()
    net_names_without_extension <- 
    	strsplit(net_names_with_extension, "_", fixed = T) %>%
    	lapply(function(x){ 
    		if(x[length(x)] %in% LETTERS) {
    			x[-length(x)]
    		} else {
    			x
    		}
    		}) %>%
    	lapply(paste, collapse = "_") %>% unlist()
    o %>% dplyr::mutate(
    	net_name = plyr::mapvalues(net_name, net_names_with_extension,
    														 net_names_without_extension)
    )
  }) %>%
  dplyr::inner_join(meta)

correlations <- d_sp %>%
	dplyr::filter(study == "ballantyne",
								threshold == 0.5,
								type == "asymmetry",
								scaled == F) %>% 
	dplyr::group_by(net_name, threshold, type, scaled) %>%
	dplyr::mutate(d_weight = d_weight/max(d_weight),
								d_rank = rank(-d_weight, ties.method = "average")) %>%
	dplyr::group_by(net_name, species) %>% 
	dplyr::summarise(d_rank = mean(d_rank)) %>%
	dplyr::group_by() %>%
	dplyr::select(net_name, species, d_rank) %>% 
	dplyr::distinct() %>%
	tidyr::spread(net_name, d_rank) %>%
  dplyr::select(-species) %>%
  as.matrix() %>%
  Hmisc::rcorr(type = "spearman")


my_paste <- function(x, y){
  if(is.na(y)) return ("-")
  b <- ""
  if(y < 0.05) b <- ""
  paste0(b, round(x, digits = 2), " (", fix_small_pvalue(y, 3), ")", b)
}

dir_net_b <- net[meta$net_name[meta$study == "ballantyne"]] %>%
  lapply(function(x){
    x %>% 
      bipartite_digraph(type = "weight", keep = "all", weight.type = "asymmetry") %>%
      igraph::ends(igraph::E(.)) %>% 
      apply(1, function(y) paste(y[1], y[2]))
  })

# same order as the correlations 
dir_net_b <- dir_net_b[colnames(correlations$P)]

lt <- combn(length(dir_net_b), 2) %>%
  apply(2, function(x){
    length(intersect(dir_net_b[[x[1]]], dir_net_b[[x[2]]])) /
      length(dir_net_b[[x[1]]])
  }) %>%
  magrittr::multiply_by(100) %>% round() %>% paste0("%")

nam <- c("unweighted","deposition", "importance", "visitation")

mapply(my_paste, correlations$r, correlations$P) %>%
  matrix(ncol = length(dir_net_b)) %>% magrittr::set_colnames(nam) %>%
  magrittr::set_rownames(nam) %>% `[<-`(lower.tri(.), lt) %>% 
  xtable::xtable(caption = "\\textbf{Agreement among network weighting schemes}. Spearman correlation coeffcients (with p-value) of species' $f_D$ and the percentage of interactions that share the direction of dependence obtained using the three weighting schemes and an unweighted scheme.") %>%
	print(comment = FALSE, include.rownames = TRUE, caption.placement = "top", booktabs = T)
	
```

Altogether, evidence supports the idea that visitation is a suitable metric to estimate the mutual dependence of species pairs. First, it is directly related to pollinator foraging. Second, it produces results consistent, at least within our controllability framework, with plant reproductive success (as estimated by the importance metric). 

# Sensitivity analysis

Our approach is fundamentaly based on the network structure. 
Often, the majority of the interactions that determine this structure are weak, which in our networks means that most interactions are formed by a small number of observed pollination visits, and therefore those weak intercations are less conspicuous in the field than strong ones. 
To strengthen the case of pur approach, we therefore evaluated the robustness of our results to simulated sampling limitations. 

To do so, for each network, we removed a portion of the links and calculated how three control metrics of the subsampled network compare to those of the full network. 
Specifically, we calculated the difference between the $n_D$ of the subsampled and the full network, the spearman correlation between the vectors $f_D$—which contain the frequency with wich each species is classified as a driver species, and the spearman correlation between $f_S$—which contain the frequency with which each species is classified as a superior node. 
We removed links from the full network with a probability inversly proportional to the interaction weight, and varied the portion of links removed between 0.5 and 0.95 at 0.05 increments. 
We repeated the procedure ten times for each portion level and each network to obtain a total sample size of $n=2000$.

Overall, the results of the sensitivity analysis indicate that our approach might be useful for management even in the absence of complete sampling. 
Specifically as the proportion of sampled interaction decreassed, the variability of $n_D$ increassed, but was overall very similar when compared to that obtained using all available interactions (Figure \@ref(fig:fig-subsampling-sensitivity)a). 
Similarly, the correlation between the relative frequency with which species are classified as a driver ($f_D$) or as a superior node ($f_S$) was correlated ever for *extreme* levels of undersampling (Figure \@ref(fig:fig-subsampling-sensitivity)b). 
For instance, we found that with a sampling level of 0.5, the mean spearman correlation coefficient was 0.66 for $f_D$ and 0.76 for $f_S$. 
Finally, the resulst suggest that the relative ranking of species is better conserved in $f_S$ than for $f_D$ troughout all levels subsampling levels.

```{r fig-subsampling-sensitivity, echo = F, message = F, warning = F, fig.width = 4.5, fig.height = 3.5, results = "hide", fig.cap= "**Sensitivity to subsampling**. (a) The difference between the *n~D~* of the subsampled and the full networks. (b) The spearman correlation of the relative importance of species between the subsampled and the full networks."}
n_d_sampling <- readRDS("../data/processed/sampling_robustness/n_d_sampling.rds")
	
p1 <- n_d_sampling %>% 
	dplyr::filter(!grepl("bal", net_name)) %>%
	ggplot(aes(x = sampling_proportion, y = n_d_base-n_d)) +
	geom_hline(yintercept = 0, linetype = 1, size = 0.3, colour = "grey") +
	xlab("sampling proportion") +
	ylab(expression(paste(Delta, n[D]))) +
	geom_boxplot(aes(x = as.factor(sampling_proportion)), size = 0.3,
               colour = "grey10", outlier.shape = 21, outlier.size = 1) +
	fer_theme

f_sampling <- readRDS("../data/processed/sampling_robustness/f_sampling.rds")

p2 <- f_sampling %>%
	dplyr::filter(!grepl("bal", net_name)) %>%
	ggplot(aes(x = as.factor(sampling_proportion), y = correlation)) +
	geom_boxplot(aes(fill = frequency), size = 0.3,
               colour = "grey10", outlier.shape = 21, outlier.size = 1) +
	xlab("sampling proportion") +
	ylab("spearman correlation") +
	scale_fill_brewer(labels = expression(f[D], f[S]), name = "") +
	fer_theme +
	theme(legend.position = c(0.875,0.2), legend.justification = "center", 
				legend.direction = "horizontal", legend.key = element_blank())

cowplot::plot_grid(p1, p2, ncol = 1, align = "v", rel_heights = c(1,1), labels = c("(a)", "(b)"), label_size = 8)

# f_sampling %>%
#   dplyr::filter(!grepl("bal", net_name)) %>%
# 	dplyr::filter(sampling_proportion == 0.5) %>%
# 	dplyr::group_by(frequency) %>%
# 	dplyr::summarise(correlation = mean(correlation))
```

# Chosing the direction of control

Our decision to adopt the direction of asymmetries as the direction of control, while coherent with ecological processes, confers several advantages. 
First it is consistent with previous studies, which facilitates the comparability between our findings and those in other systems explored using structural controlability. 
Second, it reduces the number of control cycles in the network—which require special treatment in our approach. 
And third, the reduced number of links, facilitates the computation of all possible maximum matchings.

For ilustration, we show all maximum cardinality matchings for an example network in which links are weighted based on the mutual dependences (Figure \@ref(fig:fig-matchings-bidirectional)). 
We note, however, that using mutual dependences, or any set up that can lead to bidirectional links, is problematic for a couple of reasons. 
First, having two links between interacting species and using our maximum matching approach to calculate the control configurations, can result in matchings that include cycle inducing links (Figure \@ref(fig:fig-matchings-bidirectional-no)). 
Strictly speaking these configurations are maximum matchings in the alternative bipartite configuration (Figure \@ref(fig:fig-direction-of-control)e) but not in the directed network (Figure \@ref(fig:fig-direction-of-control)f). 
While bidirectional links are the norm when using mutual dependences, they only appear in the asymmetry-weighted networks whenever the mutual dependences between two species are strictly symmetric. 
In this special case, we include two links weighted with 0.5 to reflect the fact that the species affect each other in the same proportion. 

```{r fig-matchings-bidirectional, echo = F, message = F, warning = F, fig.width = 6.2, fig.height = 3.2, results = "hide", fig.cap = "**Matchings of a simple network with bidirectional links**. (a) A network with bidirectional links. (b-e) All possible control configurations." }
par(mfrow=c(2,3), mar=c(0,0,0,0))

bi_net %>% 
	plot(layout = lay, 
			 vertex.color = v_c, 
			 vertex.size = 30,
			 vertex.label = sp_names_fancy,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 edge.label = round(E(.)$weight,1), 
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s,
			 edge.curved = T,
			 edge.arrow.size = 0.5,
			 margin = ma)

text(label_pos_x, label_pos_y, "(a)", adj = c(0,0), font = 2, cex = 0.9)

1:4 %>%
	plyr::l_ply(function(x, pal){
		
		attach(nets[[x]], pos = 1, warn.conflicts = F)	
		
		nets[[x]]$bi_net %>% 
			plot(layout = lay, 
					 vertex.size = 30,
					 vertex.label = names_fancy,
					 vertex.label.family = fam,
					 vertex.label.color = l_c,
					 vertex.shape = igraph::V(.)$superior_shape,
					 vertex.label.cex = igraph::V(.)$superior * 0.1 + 0.9,
					 # vertex.shape = igraph::V(.)$vertex.shape,
					 vertex.color = pal[igraph::V(.)$matched],
					 vertex.frame.color = pal[igraph::V(.)$matched_border],
					 edge.color = pal[igraph::E(.)$matched_col],
					 # edge.color = c("#B2ABD2", "#FDB863"),
					 edge.label = NA, 
					 edge.width = E(.)$matched/2,
					 edge.label.family = fam,
					 edge.label.color = igraph::E(.)$matched,
					 edge.label.cex = l_s,
					 edge.curved = T,
					 edge.arrow.size = 0.5,
					 margin = ma, 
					 palette = pal) %>% 
			print()
		
		igraph::V(bi_net)$name <- sp_names
		
		text(label_pos_x, label_pos_y, paste0("(",letters[1+x], ")"), adj = c(0,0), font = 2, cex = 0.8)
		text(text_pos_x, text_pos_y, cex = 0.8,
				 paste0("D = ", length(igraph::V(bi_net)) - as_mat$matching_size, "\n",
				 			 "matching size: ", as_mat$matching_size, "\n",
				 			 "matching weight: ", round(matching_weight, 1)))
	}, pal)

plot.new()
legend(0.3, 0.7, legend = c("unmatched link", "matched link"), horiz = F,
			 lty = 1, 
			 col = pal[c(1, 5)],
			 lwd = 2, cex = 0.9, xjust=0.08, yjust=1, bty = "n")

legend(0.3, 0.5, legend = c("unmatched node", "matched node"), horiz = F,
			 pch = 21, 
			 pt.bg = pal[c(2, 4)],
			 col = pal[c(1, 5)],
			 pt.cex = 2,
			 cex = 0.9, xjust=0, yjust=1, bty = "n")

legend(0.3, 0.3, legend = c("superior node", "non-superior node"),
			 horiz = F,
			 pch = c(22, 21), 
			 # pt.bg = pal[c(2, 4)],
			 pt.cex = 2,
			 cex = 0.9, xjust=0, yjust=1, bty = "n")


```

```{r  fig-matchings-bidirectional-no, echo = F, message = F, warning = F, fig.width = 6.2, fig.height = 2.4, results = "hide", fig.cap= "**Cycles in a bidirectional network**. Our approach finds twelve configurations for Figure \\@ref(fig:fig-matchings-bidirectional)a that are matchings in the alternative bipartite representation, but not actual matchings in the directed network."}

par(mfrow=c(2,6), mar=c(0,0,0,0))
5:length(nets) %>%
	plyr::l_ply(function(x, pal){
		
		attach(nets[[x]], pos = 1, warn.conflicts = F)	
		
		nets[[x]]$bi_net %>% 
			plot(layout = lay, 
					 vertex.size = 35,
					 vertex.label = names_fancy,
					 vertex.label.family = fam,
					 vertex.label.color = l_c,
					 vertex.label.cex = igraph::V(.)$superior * 0.1 + 0.6,
					 vertex.frame.color = igraph::V(.)$matched_col,
					 vertex.shape = igraph::V(.)$superior_shape,
					 # vertex.shape = igraph::V(.)$vertex.shape,
					 vertex.color = pal[igraph::V(.)$matched],
					 edge.color = pal[igraph::E(.)$matched_col],
					 # edge.color = c("#B2ABD2", "#FDB863"),
					 edge.label = NA, 
					 edge.width = E(.)$matched/3,
					 edge.label.family = fam,
					 edge.label.color = igraph::E(.)$matched,
					 edge.label.cex = l_s,
					 edge.curved = T,
					 edge.arrow.size = 0.5,
					 margin = ma, 
					 palette = pal) %>% 
			print()
		
		igraph::V(bi_net)$name <- sp_names
		
		# text(label_pos_x, label_pos_y, paste0(letters[1+x-5], ")"), adj = c(0,0))
		# text(text_pos_x, text_pos_y, cex = 0.95,
		# 		 paste0("D = ", length(igraph::V(bi_net)) - as_mat$matching_size, "\n",
		# 		 			 "matching size: ", as_mat$matching_size, "\n",
		# 		 			 "matching weight: ", round(matching_weight, 1)))
	}, pal)

```

We consider two approaches to tackle this limitation. 
The first approach, is to calculate the matching(s) as usual and then, before calculating $f_S$ and $f_D$, filter out the cycle containing matchings (Figure \@ref(fig:fig-matchings-bidirectional-no)). 
In the special case that the network has no maximal matchings that correspond to feasible control configurations, because they all include cycles, we reduce the size of the cliques we enumerate in $H$ (Figure \@ref(fig:fig-finding-all-matchings)) and repeat. 
The second approach is, instead of calculating the matching(s) for the network with bidirectional cycles, we calculate the matching(s) of $2^n$ unidirectional versions of the network, where $n$ is the number of cycles in the network (Figure \@ref(fig:fig-tackle-cycles)).
We then average over the unidirectional networks to find the overall $f_S$ and $f_D$ for a given species. 


```{r fig-tackle-cycles, echo = F, message = F, warning = F, fig.width = 3.3, fig.height = 1.5, results = "hide", fig.cap= "**Dealing with cycles**. The network on the left, which has *n = 2* cycles, can be decomposed in *2^n^* unidirectional networs."}
layout(matrix(c(1,2,3, 1,4, 5), ncol = 3, byrow = TRUE), widths = c(2, 1,1))
par( mar=c(0,0,0,0))

set.seed(3)
g_one_bi <- matrix(c(0,1,1,1,0,1,1,0,0), ncol = 3) %>%
	igraph::graph_from_adjacency_matrix()
lay_g_one_bi <- layout_nicely(g_one_bi)

plot(g_one_bi, 
		 edge.curved = c(T, T, T, T, T), 
		 layout = lay_g_one_bi, 
		 vertex.color = NA, 
		 vertex.label = NA,
		 vertex.size = 30, 
				 edge.arrow.size = 0.5,
		 margin = c(0,0,0,0.5))
text(-1, 1.1, "(a)", font = 2, cex = 0.9)
text(1.65, 1.1, "(b)", font = 2, cex = 0.9)

# xline <- 1.5
# arrows(x0 = xline, y0=-2, x1=xline, y1=2, col='grey30', length=0, lwd=1)
per <- gtools::permutations(2, 2, v = c(1,3), repeats.allowed = T)
per[, 2] <- per[, 2] + 1
per %>%
	plyr::a_ply(1, function(x){
		print(x)
	g_one_bi%>% 
		delete_edges(x) %>% 
		plot(layout = lay_g_one_bi, 
				 vertex.color = NA, 
				 vertex.label = NA,
				 vertex.size = 40, 
				 edge.arrow.size = 0.3)

})

```

The number of maximal matchings increases disproportionally fast with the number of links in a network. 
For instance, our example network in Figure 1, which is composed of unidirectional links weighted by the asymmetry, has two different maximum matchings. 
In contrast, the equivalent network with bidirectional links has 16 different maximum matchings (Figure \@ref(fig:fig-matchings-bidirectional) and \@ref(fig:fig-matchings-bidirectional-no)). 
To further ilustrate the implications of this growth, some of our empirical networks had approximately ten thousand different maximum matchings using asymmetries but one hundred million when using mutual dependences. 
This exponential growth, and the computational cost of either filtering matchings with cycles or calculating the matchings for $2^n$ networks, surpassed the capabilities of the available computational resources and rendered us unable to calculate all possible maximum matchings when using mutual dependences in most of our bidirectional networks.
Nevertheless, as most of our networks weighted by asymmetry had between zero and four cycles, we successfully used the second approach explained in the previous paragraph to calculate the all maximum matchings for these networks.

We highlight that althoug the direction of control might affect the $f_S$ and $f_D$, it doesn't affect strongly the network's relative density of driver nodes $n_D$. 
We reached this conclusion by calculating the $n_D$ obtained assuming that (a) the direction of control is governed by the asymmetry or (b) bidirectional dependences, (c) that plants depend on pollinators, and that (d) pollinators depend on plants. 
Although the $n_D$ values were quantitatively different between the approaches (Figure \@ref(fig:fig-alternative-assumptions)), the Spearman correlation among these four options suggested a very high agreement (Table S3).

```{r fig-alternative-assumptions, echo = F, message = F, warning = F, fig.width = 4, fig.height = 1.6, results = "hide", fig.cap= "**Absolute differences among asumptions on the direction of control.**"}

a_m_driver <- a_m %>% 
  dplyr::full_join(meta) %>%
  dplyr::filter(study != "ballantyne") %>% 
  dplyr::mutate(type = factor(type, 
                              levels =  c("AB", "BA", "weight", "z-bi"),
                              labels = c("pla. to pol.", "pol. to pla.", "asymmetry", "bidirectional dep.")),
                type_l  = as.character(type)) %>%
  dplyr::mutate(n_driver = n_pla + n_pol - n_matched, 
                n_driver_rel = 1 - n_matched / (n_pla + n_pol)) 

type_l <- unique(a_m_driver$type_l)

a_m_driver %>%
  ggplot(aes(x = type, y = n_driver_rel), parse = T) +
  geom_boxplot(size = 0.25, colour = "grey10",
							 outlier.shape = 21, outlier.size = 1) +
  coord_flip() +
  xlab("") +
  ylab(expression(n[D])) +
  fer_theme +
  theme(plot.margin = grid::unit(c(0,1,2,0), "mm"))

```


```{r table-alternative-assumptions, echo = FALSE, warning = F, message = F, results = "asis", sanitize = FALSE}

corr_matrix <- a_m_driver %>%
  dplyr::select(net_name, type, n_driver) %>%
  tidyr::spread(type, n_driver) %>%
  dplyr::select(-net_name) %>%
  as.matrix() %>%
  cor(method = "spearman") %>%
  round(digits = 2)

corr_matrix[lower.tri(corr_matrix, diag = T)] <- ""
corr_matrix <- corr_matrix[, -1]
corr_matrix <- corr_matrix[-(nrow(corr_matrix)), ]

 corr_matrix %>% 
  xtable::xtable(caption = "\\textbf{Agreement among assumptions on the direction of control}. Spearman correlation coefficients of the number of driver nodes $n_D$ four different assumptions of the direction of control..") %>%
	print(comment = FALSE, include.rownames = TRUE, caption.placement = "top", booktabs = T)

```


# Matching's weight threshold

We use the frequency with which a species is classified as a driver node $f_D$ and the frequency with which a species is classified as a superior node $f_S$ in a set of accepted maximal matchings to infer their relative importance.
Maximal matchings were accepted if the matching weight was over a certain threshold. 
This threshold was defined as a proportion of the maximum matching's weight. 
Here we evaluate the impact that a particular choice of this threshold has on $f_D$ and $f_S$. 

The number of accepted maximal matchings increased rapidly as the threshold at which they are accepted decreases. Nevertheless this number stabilises below approximately 0.6-0.7 (Figure \@ref(fig:fig-n-matchings)). 

```{r fig-n-matchings, echo = F, message = F, warning = F, fig.width = 3.2, fig.height = 2.4, results = "hide", fig.cap= "**Number of maximal matchings as a function of the weight threshold**. Each line correspond to one network."}
d_sp %>%
	dplyr::filter(scaled == FALSE, 
								study != "ballantyne", 
								type == "asymmetry") %>%
	dplyr::group_by(net_name, threshold) %>%
	dplyr::summarise(n_matchings = mean(unique(n_matchings))) %>%
	ggplot(aes(x = threshold, y = n_matchings)) +
	geom_line(aes(group = net_name), colour = "grey20", size = 0.3) +
	scale_y_log10() +
	scale_x_reverse() +
	ylab("maximal matchings") +
	fer_theme
```

We then examined how the relative importance of species changes with the chosen threshold. 
We observe, that regardless of the matching weight's threshold species tend to be superior nodes in all or none of the matchings, which equates to $f_S$ values of one or zero, and the contrast between important and unimportant species is maintained (Figure \@ref(fig:fig-f-s-rankings)).
Contrastingly, species' $f_D$ reach intermediate levels of importance and show higher variability across thresholds (Figure \@ref(fig:fig-f-d-rankings)). 
We note here that we were unable to compute all the maximum cardinality matchings for one of our networks (uninvaded community in site 8). 
We estimate the number of matchings to be more than one billion, which surpassed our available computational resources.

```{r fig-f-s-rankings, echo = F, message = F, warning = F, fig.width = 6.2, fig.height = 9, results = "hide", fig.cap="**Frequency with which a species was classified as a superior node ($f_S$) as a function of the matching weight threshold**. Rows correspond to study sites.", cache = T}
sites <- net_prop %>% dplyr::arrange(study, site, inv) %$% site %>% unique()
threshold_data <- d_sp %>%
			dplyr::filter(scaled == FALSE, 
										study != "ballantyne", 
										type == "asymmetry") %>%
			dplyr::mutate(f_s = d_freq / n_matchings, 
										f_d = (n_matchings - m_freq) / n_matchings, 
										site = factor(site, sites), 
										site_num = as.numeric(site)) %>%
			dplyr::group_by(net_name, threshold, species) %>%
			dplyr::summarise(f_s = mean(f_s),
											 f_d = mean(f_d), 
											 site = dplyr::first(site),
											 site_num = dplyr::first(site_num),
											 inv = dplyr::first(inv)) %>%
			dplyr::group_by() %>%
			dplyr::mutate(site_num = site_num -1, # to account for ballantynes
										inv = plyr::mapvalues(inv, c(T, F), 
																					c("invaded", "uninvaded")))
# not finished note
note <- data.frame(site_num = 8, inv = "invaded", text = "results not available")

p <- c("f_s", "f_d") %>%
	plyr::llply(function(x){
		threshold_data %>% 
			# dplyr::group_by(net_name, species) %>%
			# dplyr::arrange(threshold) %>%
			# dplyr::mutate(initial = dplyr::first(f_s)) %>%
			# dplyr::group_by() %>%
			# reshape2::melt(measure.vars = c("f_s", "f_d"), value.name = "f") %>% 
			# dplyr::group_by() %>% View
			ggplot() +
			geom_line(aes_string(x = "threshold", group = "species", y = x), size = 0.2) +
			geom_text(data = note, aes(label = text), x = 0.5, y = 0.5, size = 3) +
			# geom_point(size = 0.5) +
			facet_grid(site_num ~ inv) +
			fer_theme
	})

p[[1]] + ylab(expression(f[S]))
```

```{r fig-f-d-rankings, echo = F, message = F, warning = F, fig.width = 6.2, fig.height = 9, results = "hide", fig.cap= "**Frequency with which a species was classified as a superior node ($f_D$) as a function of the matching weight threshold**. Rows correspond to study sites.", cache = T}
p[[2]] + ylab(expression(f[D]))

```

Finally, we examined the agreement across thresholds by calculating the Spearman correlation matrix of species' $f_S$ and $f_D$ for each network. 
The mean of those matrices is shown in Table S4. 
Overall, among all thresholds, we found a very high agreement for $f_S$, and high to very high for $f_D$. 
With the exception of using a threshold of 1 (only maximum matchings are accepted), the choice of the threshold has little impact on the relative importance of species. 
For convenience, we use an intermediate level of 0.5. 
Nevertheless, the differences are marginal and any threshold $<= 0.9$ is likely to produce very similar results. 

```{r table-correlations-thresholds, echo = F, message = F, warning = F, results = "asis", sanitize = F, cache = T}
correlation_matrix <- c("f_s", "f_d") %>%
	plyr::llply(function(x){
		threshold_data %>%
			plyr::daply("net_name", get_corr_matrix, column = x) %>% 
			plyr::aaply(c(2, 3), mean)
	})

correlation_matrix_o <- correlation_matrix[[1]]
correlation_matrix_o[upper.tri(correlation_matrix_o)] <- 
	correlation_matrix[[2]][upper.tri(correlation_matrix[[2]])]
c_m <- round(correlation_matrix_o, 3)
c_m[is.na(c_m)] <- "—"

xtable::xtable(c_m, caption = "\\textbf{Spearman correlation coefficient among different matching weight thresholds}. The upper triangle shows values for $f_D$ and the lower triangle shows values for $f_S$") %>%
	print(comment = FALSE, include.rownames = TRUE, caption.placement = "top", booktabs = T)
```

# Statistical models

```{r table-nd-coef, echo = FALSE, warning = FALSE, message = FALSE, results = "asis", sanitize = FALSE}
library(glmulti)

manag_table <- manag_models %>%
			coef.glmulti(select = 0.95) %>%
  as.data.frame() %>%
  tibble::rownames_to_column("factor") %>%
  dplyr::mutate(pare = grepl("(", factor, fixed =T),
                factor = plyr::mapvalues(factor, 
                												 c("studylopezaraiza", "invTRUE",
                												 	"I(n_links/(n_pla * n_pol))",
                												 	"I(n_pla + n_pol)", 
                												 	"I(n_pla/n_pol)"),
                												 c("study site", "invasion status",
                												 	"connectance", "spp. richness", 
                												 	"ratio plant/pollinator"))) %>%
  dplyr::arrange(-pare, -Importance, factor) %>% 
  dplyr::select(-pare) %>%
  magrittr::set_names(c(" ", "est.", "var", "mod.", "imp.", "C.I.")) %>%
			dplyr::select(-var, -mod.)


manag_table %>%
	xtable::xtable(caption = "\\textbf{Coefficients of the $n_D$ models}. Estimates are averaged over the models that accounted for 95\\% of the evidence weight.",
										 digits =  c(0, 0, 2, 2, 2),
										 display = c("d", "s", "f", "f", "G")) %>%
	print(booktabs = T, include.rownames = F,  caption.placement = "top", comment = F, sanitize.text.function = function(x){x})

```


# References
