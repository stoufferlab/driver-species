---
title: "Biotic invasions fuck with the manageability of pollination networks"
subtitle: "Supporting Information"
classoption: a4paper
csl: ecology-letters.csl
output:
  pdf_document:
    fig_crop: no
    keep_tex: yes
  html_document: default
  word_document: default
header-includes:
- \usepackage{setspace}
- \usepackage{float}
- \usepackage{rotating}
- \renewcommand{\figurename}{Supporting Figure}
- \renewcommand{\tablename}{Supporting Table}
documentclass: artikel1
bibliography: references.bib
nocite: | 
  @Lopezaraiza-Mikel2007, @Bartomeus2008
---

\doublespacing

```{r libraries, echo = F, include = F}
library(igraph)
library(magrittr)
library(dplyr)
library(latex2exp)
library(ggplot2)
library(RColorBrewer)

"../code/functions" %>% 
	list.files(full.names = T) %>%
	plyr::l_ply(source)

"../code/plotting_functions" %>% 
	list.files(full.names = T) %>%
	plyr::l_ply(source)
 
mutate_cond <- function(.data, condition, ..., envir = parent.frame()) {
  condition <- eval(substitute(condition), .data, envir)
  .data[condition, ] <- .data[condition, ] %>% dplyr::mutate(...)
  .data
}

```

```{r load data, include = F}
net <- "../data/processed/networks" %>%
	read_networks()
meta <- readr::read_csv("../data/ntw_info.csv") %>% dplyr::tbl_df() %>%
	dplyr::rename(count = method)
n_driver <- readRDS("../data/processed/n_driver.rds")
manag_models <- readRDS("../data/processed/models_manageability.rds")
src_bi_w <- readRDS("../data/processed/manageability_bi_vs_weight.rds")
r_w <- readRDS("../data/processed/random_weights.rds") %>% dplyr::tbl_df() %>%
  dplyr::rename_("net_name" = ".id")
r_d <- readRDS("../data/processed/random_directions.rds") %>% dplyr::tbl_df() %>%
  dplyr::rename_("net_name" = ".id")

prop <- expand.grid(c("asymmetry", "max_dep"), 
                    c("scaled_FALSE", "scaled_TRUE")) %>% plyr::alply(1)
driver <- c("../data/processed/matching_frequency") %>% 
  list.files(full.names = T) %>%
  lapply(list.files, full.names = T) %>% 
  unlist() %>% 
  lapply(read_allRDS)
driver <- mapply(function(x, y){
  attr(x, "type") <- as.character(y[,1])
  attr(x, "scaled") <- stringr::str_split(as.character(y[,2]), "_") %>% unlist() %>% extract(2) %>% as.logical()
  return(x)
}, driver, prop)
driver_bi <- "../data/processed/matching_frequency_bi" %>% 
  read_allRDS()

n_matched <- readRDS("../data/processed/n_matched.rds")

```

```{r plot theme, echo = FALSE, warning = F, message = F}
fer_theme <- theme_bw() +
	theme(text = element_text(family = "Helvetica"),
	      title = element_text(size = 7, hjust = 0),
	      legend.title = element_text(size = 8),
	      legend.text = element_text(size = 7),
				axis.text = element_text(size = 7),
				axis.title = element_text(size = 8, hjust = 0.5), 
				strip.text = element_text(size = 8, hjust = 0), 
				strip.background = element_blank(),
				plot.margin = grid::unit(c(5, 0, 2, 0), "mm"),
				panel.grid = element_blank())
```

```{r example networks, include = F, message = F, warning = F, }

sp_names_fancy <- c(TeX("$p_1$"), TeX("$p_2$"), TeX("$p_3$"), TeX("$a_1$"), TeX("$a_2$"))
sp_names_fancy_b <- c(TeX("$\\mathbf{p_1}$"), TeX("$\\mathbf{p_2}$"), TeX("$\\mathbf{p_3}$"), TeX("$\\mathbf{a_1}$"), TeX("$\\mathbf{a_2}$"))

sp_names <- c("p1", "p2", "p3", "a1", "a2")

adj_matrix <- c(0,0,0,1,0,
								0,0,0,2,5,
								0,0,0,0,0,
								0,0,1,0,0,
								0,0,1,0,0) %>%
	matrix(nrow = 5, byrow = T)

example_net <- adj_matrix %>% 
	graph_from_adjacency_matrix(mode = "undirected", weighted = TRUE) 
igraph::V(example_net)$type <- c(F, F, F, T, T)
igraph::V(example_net)$name <- sp_names

base_net <- example_net
bi_net <- example_net %>%
	keep_largest_component() %>%
	bipartite_digraph(type = "z-bi", weight.type = "asymmetry") 
as_net <- example_net %>%
	keep_largest_component() %>%
	bipartite_digraph(type = "weight", weight.type = "asymmetry")

fam <- "Helvetica"
# layout is based on the bidirectional network
set.seed(1)

lay <- bi_net %>%
	layout_nicely()
v_c <- "white"
l_c <- "black"
l_s <- 0.9
ma <- c(0,0,0,0)
label_pos_x <- -1
label_pos_y <- 1

pal <- RColorBrewer::brewer.pal(5, "PuOr")


# BIDIRECTIONAL MATCHINGS


as_mat <- bi_net %>%
	digraph_bipartite() %>% 
	max_bipartite_match()

as_all_mat <- bi_net %>%
	digraph_bipartite(type = "z-bi") %>%
	igraph::make_line_graph() %>%
	igraph::complementer() %>% 
	igraph::max_cliques(min = as_mat$matching_size) %>%
	rev()

text_pos_x <- 0.5
text_pos_y <- -0.7

base_bi_net <- bi_net
E(bi_net)$weight <- round(E(bi_net)$weight, 1)

nets <- 1:length(as_all_mat) %>%
	plyr::llply(function(x){
		
		igraph::E(bi_net)$matched <- 2
		igraph::E(bi_net)$matched[as_all_mat[[x]]] <- 4
		
		igraph::V(bi_net)$matched <- 2
		igraph::V(bi_net)$matched[igraph::V(bi_net)$name %in%
																ends(bi_net, as_all_mat[[x]])[, 2]] <- 4
		
		igraph::V(bi_net)$superior <- 1
		igraph::V(bi_net)$superior[igraph::V(bi_net)$name %in%
																ends(bi_net, as_all_mat[[x]])[, 1]] <- 2
		
		names_fancy <- sp_names_fancy
		names_fancy[igraph::V(bi_net)$name %in%
																ends(bi_net, as_all_mat[[x]])[, 1]] <-
			sp_names_fancy_b[igraph::V(bi_net)$name %in%
																ends(bi_net, as_all_mat[[x]])[, 1]]
		
		matching_weight <- sum(E(bi_net)$weight[as_all_mat[[x]]])
		
		n_edges <- length(igraph::E(bi_net))
		has_cycles <- igraph::E(bi_net)[setdiff(1:n_edges, as_all_mat[[x]])] %>%
			igraph::delete_edges(bi_net, .) %>% 
			igraph::is_dag() %>%
			magrittr::not()
		
		list(
			bi_net = bi_net,
			names_fancy = names_fancy,
			as_mat = as_mat, 
			as_all_mat = as_all_mat[[x]], 
			matching_weight = matching_weight,
			has_cycles = has_cycles
		)
	
})

nets <- nets[order(!unlist(lapply(nets, function(x) x$has_cycles)), unlist(lapply(nets, function(x) x$matching_weight)), decreasing = T)]
```

# S1: Finding a complex network's matchings

Our approach to find the minumum number of driver nodes relies on finding maximum matchings and maximum cardinality matchings. Most existing algorithms are designed to work with undirected bipartie networks, where finding the maximum matching is equivalent to finding the maximum flow between the two levels. 

We start with a directed network in which the direction of the link represents the direction of control (Supporting figure 1a). We then construct an alternative representation of the directed network in which each node of the directed network is represented by two nodes that indicate their outgoing and incoming links (Supporting figure 1b). Finding a maximum matching in this alternative representation is equivalent to finding the largest possible set of edges in which one node in the left hand side is connected to at most one node in the right hand side. To find the maximum matching we use the push-relabel algorithm implemented in `max_bipartite_matching` in the R package igraph 1.0.1 [@Csardi2006a]. Once we have the matching shown in the Supporting Figure 1b, it is then easy to identify the roles of each node in this representation: nodes on the right hand side that are connected to a matched link (purple) are matched, while those connected to a matched link on the left hand side are superior. This information can then be mapped back to the original representation to identify the control paths and the driver nodes in the network (Supporting Figure 1c). Supporting Figure 1d, e, and f ilustrate this approach for a network with bidirectional links.

```{r fig-direction-of-control, echo = F, message = F, warning = F, fig.width = 6.2, fig.height = 3.4, results = "hide", fig.cap = "**Finding a maximum matching in a complex network**. (a & d) Directed networks that indicate the direction of control between species. (b & e) Alternative bipartite representations of the directed networks. (c & f) The matchings in the bipartite representation mapped back to the original network."}
# par(mfrow=c(2,2), mar=c(0,0,0,0))
bi_sp_names_fancy <- c( TeX("$p_1^-$"), TeX("$p_2^-$"), TeX("$p_3^-$"), TeX("$a_1^-$"), TeX("$a_2^-$"), TeX("$p_1^+$"), TeX("$p_2^+$"), TeX("$p_3^+$"), TeX("$a_1^+$"), TeX("$a_2^+$"))

bi_sp_names_fancy_b <- c( TeX("$p_1^-$"), TeX("$p_2^-$"), TeX("$p_3^-$"), TeX("$a_1^-$"), TeX("$a_2^-$"), TeX("$\\mathbf{p_1^+}$"), TeX("$\\mathbf{p_2^+}$"), TeX("$\\mathbf{p_3^+}$"), TeX("$\\mathbf{a_1^+}$"), TeX("$\\mathbf{a_2^+}$"))


# par(mfrow=c(2,3), mar= c(0,0,0,0))
layout(matrix(c(1,2,3,4, 5, 6, 7, 7, 7), 3, 3, byrow = TRUE),
  	heights=c(8,8,1))
par( mar=c(0,0,0,0))
# ASYMMETRY
as_net %>% 
	plot(layout = lay, 
			 vertex.color = v_c, 
			 vertex.size = 35,
			 vertex.label = sp_names_fancy,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 edge.label = round(E(.)$weight,1), 
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s,
			 edge.curved = F,
			 edge.arrow.size = 0.5,
			 margin = ma)

text(label_pos_x, label_pos_y, "a)", adj = c(0,0))


as_mat <- as_net %>%
	digraph_bipartite() %>% 
	max_bipartite_match()

as_all_mat <- as_net %>%
	digraph_bipartite() %>%
	igraph::make_line_graph() %>%
	igraph::complementer() %>% 
	igraph::max_cliques(min = as_mat$matching_size) %>%
	rev()

text_pos_x <- 0.5
text_pos_y <- -0.7

base_as_net <- as_net
E(as_net)$weight <- round(E(as_net)$weight, 1)

bi_as_net <- as_net %>%
	digraph_bipartite() 

igraph::V(bi_as_net)$matched <- 2
igraph::V(bi_as_net)$matched[igraph::V(bi_as_net)$name %in%
														 	ends(bi_as_net, as_all_mat[[1]])[, 2]] <- 4
igraph::V(bi_as_net)$matched[1:5] <- NA

igraph::V(bi_as_net)$superior <- 30
igraph::V(bi_as_net)$superior[igraph::V(bi_as_net)$name %in%
														 	ends(bi_as_net, as_all_mat[[1]])[, 1]] <- 40
igraph::V(bi_as_net)$superior[6:10] <- 35

igraph::E(bi_as_net)$matched <- 2
		igraph::E(bi_as_net)$matched[as_all_mat[[1]]] <- 4
																 
bi_as_net %>%
	plot(layout = matrix(c(rep(c(-0.5, 0.9), each = 5), rep(seq(-0.8, 0.8, length.out = 5), 2)), ncol = 2), 
			 # vertex.size = igraph::V(.)$superior,
			 vertex.size = 30, 
			 vertex.label = c(bi_sp_names_fancy[6:10], bi_sp_names_fancy[1:5]),
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 # vertex.label.cex = igraph::V(.)$superior * 0.1 + 0.9,
			 # vertex.color = pal[igraph::V(.)$matched],
			 vertex.color = NA,
			 edge.color = pal[E(.)$matched],
			 edge.label = NA, 
			 edge.width = E(.)$matched/2,
			 edge.label.family = fam,
			 edge.label.color = igraph::E(.)$matched,
			 edge.label.cex = l_s,
			 edge.curved = F,
			 edge.arrow.size = 0.5,
			 margin = ma, 
			 rescale = F)

text(-0.95, 0.825, "b)", adj = c(0,0))

E(as_net)$matched <- 2
		E(as_net)$matched[as_all_mat[[1]]] <- 4
		
		igraph::V(as_net)$matched <- 2
		igraph::V(as_net)$matched[igraph::V(as_net)$name %in%
																ends(as_net, as_all_mat[[1]])[, 2]] <- 4
		
		igraph::V(as_net)$superior <- 1
		igraph::V(as_net)$superior[igraph::V(as_net)$name %in%
																ends(as_net, as_all_mat[[1]])[, 1]] <- 2
		
		names_fancy <- sp_names_fancy
		names_fancy[igraph::V(as_net)$name %in%
																ends(as_net, as_all_mat[[1]])[, 1]] <-
			sp_names_fancy_b[igraph::V(as_net)$name %in%
																ends(as_net, as_all_mat[[1]])[, 1]]
		
		matching_weight <- sum(E(as_net)$weight[as_all_mat[[1]]])
		
		as_net %>% 
			plot(layout = lay, 
					 vertex.size = igraph::V(.)$superior * 10 + 20,
					 vertex.label = names_fancy,
					 vertex.label.family = fam,
					 vertex.label.color = l_c,
					 vertex.label.cex = igraph::V(.)$superior * 0.1 + 0.9,
					 # vertex.shape = igraph::V(.)$vertex.shape,
					 vertex.color = pal[igraph::V(.)$matched],
					 edge.color = pal[E(.)$matched],
					 edge.label = NA, 
					 edge.width = E(.)$matched/2,
					 edge.label.family = fam,
					 edge.label.color = igraph::E(.)$matched,
					 edge.label.cex = l_s,
					 edge.curved = F,
					 edge.arrow.size = 0.5,
					 margin = ma) %>% 
			print()

text(label_pos_x, label_pos_y, "c)", adj = c(0,0))


bi_net %>% 
	plot(layout = lay, 
			 vertex.color = v_c, 
			 vertex.size = 35,
			 vertex.label = sp_names_fancy,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 edge.label = round(E(.)$weight,1), 
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s,
			 edge.curved = T,
			 edge.arrow.size = 0.5,
			 margin = ma)
text(label_pos_x, label_pos_y, "d)", adj = c(0,0))

i <- 1
bi_bi_net <- nets[[i]]$bi_net %>%
	digraph_bipartite(type = "z-bi")

		igraph::E(bi_bi_net)$matched <- 2
		igraph::E(bi_bi_net)$matched[nets[[i]]$as_all_mat] <- 4
		
		igraph::V(bi_bi_net)$matched <- 2
		igraph::V(bi_bi_net)$matched[igraph::V(bi_bi_net)$name %in%
																ends(bi_bi_net, nets[[i]]$as_all_mat)[, 1]] <- 4
		igraph::V(bi_bi_net)$matched[6:10] <- NA
		
		igraph::V(bi_bi_net)$superior <- 30
		igraph::V(bi_bi_net)$superior[igraph::V(bi_bi_net)$name %in%
																ends(bi_bi_net, nets[[i]]$as_all_mat)[, 2]] <- 40
		igraph::V(bi_bi_net)$superior[1:5] <- 35
		
		bi_names_fancy <- bi_sp_names_fancy
		bi_names_fancy[igraph::V(bi_bi_net)$name %in%
									ends(bi_bi_net, nets[[i]]$as_all_mat)[, 2]] <-
			bi_sp_names_fancy_b[igraph::V(bi_bi_net)$name %in%
														ends(bi_bi_net, nets[[i]]$as_all_mat)[, 2]]
		
		
bi_bi_net %>%
	plot(layout = matrix(c(rep(c(0.9,-0.5), each = 5), rep(seq(-0.8, 0.8, length.out = 5), 2)), ncol = 2), 
			 # vertex.size = igraph::V(.)$superior,
			 vertex.size = 30,
			 vertex.label = bi_sp_names_fancy, 
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 # vertex.color = pal[igraph::V(.)$matched],
			 vertex.color = NA, 
			 edge.color = pal[igraph::E(.)$matched],
			 # edge.label = round(E(.)$weight,1), 
			 edge.label.family = fam,
			 edge.width = E(.)$matched/2,
			 edge.label.color = l_c,
			 edge.label.cex = l_s,
			 edge.curved = F,
			 edge.arrow.size = 0.5,
			 margin =  ma, 
			 # asp = 0.5, 
			 rescale = F)

text(-0.95, 0.825, "e)", adj = c(0,0))

nets[[1]]$bi_net %>%
	plot(layout = lay, 
			 vertex.label = nets[[1]]$names_fancy,
			 vertex.size = igraph::V(.)$superior * 10 + 20,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 vertex.color = pal[igraph::V(.)$matched],
			 edge.color = pal[igraph::E(.)$matched],
			 # edge.label = round(E(.)$weight,1), 
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s,
			 edge.curved = T,
			 edge.arrow.size = 0.5,
			 edge.width = E(.)$matched/2,
			 margin = ma, 
			 # asp = 0.5, 
			 rescale = T)

text(label_pos_x, label_pos_y, "f)", adj = c(0,0))

## LEGEND 
plot.new()
legend(0.16, 0.9, legend = c("unmatched link", "matched link"), horiz = TRUE,
			 lty = 1, 
			 col = pal[c(2, 4)],
			 lwd = 2, cex = 0.9, xjust=0.5, yjust=0.8, bty = "n")

legend(0.57, 0.9, legend = c("unmatched node", "matched node"), horiz = TRUE,
			 pch = 21, 
			 pt.bg = pal[c(2, 4)],
			 pt.cex = 2,
			 cex = 0.9, xjust=0.5, yjust=0.8, bty = "n")

legend(1-0.16 + 0.05, 0.9, legend = expression(paste(bold("  superior node"))), horiz = TRUE,
			 pch = 21, 
			 # pt.bg = pal[c(2, 4)],
			 pt.cex = c(3),
			 cex = 0.9, xjust=0.5, yjust=0.8, bty = "n")
```

The algorithm implemented in `max_bipartite_matching`, however, is only able to find **one** of the, possibly many, maximum matchings in a network. One maximum matching is sufficient to calculate *n~D~* and hence to provide indication of a communitie's manageability, however it is not possible to estimate the role of individual species. To do that we need to calculate all possible maximum matchings (or all maximal cardinality matchings in weighted networks like ours). We start from the alternative bipartite representation in Supporting Figure 1b and assign an identity to each of the links in the network (shown as numbers in Supporting Figure 2a). We will call this bipartite representation *B*. We then construct the line graph of the alternative bipartite representation *L(B)* (Supporting Figure 2b). Each node in *L(B)* represents a link in *B* and are connected to each other only if they share a common node in *B*. We calculate the complement graph of *L(B)* and idetify all the maximum cliques (Supporting Figure 2c). Here some extra definitions are neccessary. First, the complement of *L(B)*, *H*, is a graph with the same nodes as *L(B)* but that has a link between two given nodes if and only if there is not a link in *L(B)*. Second, a clique is a subset of nodes such that any two of them are linked. Lastly, a maximum clique is a clique such that there are no cliques with more nodes. In this example there are two maximum cliques: that one formed by 1, 3 and 5, and by 2, 3 and 5. The final step is then to map these cliques into the original network to obtain all possible maximum cardinality matchings as shown in Figure 1 in the main text.

```{r fig-finding-all-matchings, echo = F, message = F, warning = F, fig.width = 6.2, fig.height = 1.8, results = "hide", fig.cap = "**Finding all possible maximum cardinality matchings**. (a) Alternative bipartite representation of a directed network. (b) Line graph of the network in a. (c) Complement of the network in b. The two maximum cliques are shown in red and blue."}
layout(matrix(c(1,2,3,4, 5, 6), 2, 3, byrow = TRUE),
  	heights=c(8,1))
par( mar=c(0,0,0,0))


as_mat <- as_net %>%
	digraph_bipartite() %>% 
	max_bipartite_match()

as_all_mat <- as_net %>%
	digraph_bipartite() %>%
	igraph::make_line_graph() %>%
	igraph::complementer() %>% 
	igraph::max_cliques(min = as_mat$matching_size) %>%
	rev()

text_pos_x <- 0.5
text_pos_y <- -0.7

base_as_net <- as_net
E(as_net)$weight <- round(E(as_net)$weight, 1)

bi_as_net <- as_net %>%
	digraph_bipartite() 

igraph::V(bi_as_net)$matched <- 2
igraph::V(bi_as_net)$matched[igraph::V(bi_as_net)$name %in%
														 	ends(bi_as_net, as_all_mat[[1]])[, 2]] <- 4
igraph::V(bi_as_net)$matched[1:5] <- NA

igraph::V(bi_as_net)$superior <- 30
igraph::V(bi_as_net)$superior[igraph::V(bi_as_net)$name %in%
														 	ends(bi_as_net, as_all_mat[[1]])[, 1]] <- 40
igraph::V(bi_as_net)$superior[6:10] <- 35

igraph::E(bi_as_net)$matched <- 2
		igraph::E(bi_as_net)$matched[as_all_mat[[1]]] <- 4
# 																 
# bi_as_net %>%
# 	plot(layout = matrix(c(rep(c(-0.5, 0.9), each = 5), rep(seq(-0.8, 0.8, length.out = 5), 2)), ncol = 2), 
# 			 # vertex.size = igraph::V(.)$superior,
# 			 vertex.size = 30, 
# 			 vertex.label =  c(bi_sp_names_fancy[6:10], bi_sp_names_fancy[1:5]),
# 			 vertex.label.family = fam,
# 			 vertex.label.color = l_c,
# 			 # vertex.label.cex = igraph::V(.)$superior * 0.1 + 0.9,
# 			 # vertex.color = pal[igraph::V(.)$matched],
# 			 vertex.color = NA,
# 			 # edge.color = pal[E(.)$matched],
# 			 edge.label = NA, 
# 			 # edge.width = E(.)$matched/2,
# 			 edge.label.family = fam,
# 			 edge.label.color = igraph::E(.)$matched,
# 			 edge.label.cex = l_s,
# 			 edge.curved = F,
# 			 edge.arrow.size = 0.5,
# 			 margin = ma, 
# 			 rescale = F)
# 
# text(-0.95, 0.825, "a)", adj = c(0,0))

###

bi_as_net %>% 
	delete_vertices(c(1, 3, 7)) %>% 
	plot(vertex.size = 35, 
			 vertex.label = c(bi_sp_names_fancy[6:10], bi_sp_names_fancy[1:5])[-c(1,3,7)], 
			 vertex.color = "white", 
			 edge.label = 1:5,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s,
			 edge.curved = F,
			 edge.arrow.size = 0.5,
			 margin = ma, 
			 layout = layout_in_circle)

text(-1, 1, "a)", adj = c(0,0))

set.seed(2)
bi_as_net %>%
		igraph::make_line_graph() %>% 
	plot(vertex.size = 35, 
			 # vertex.label = c(bi_sp_names_fancy[6:10], bi_sp_names_fancy[1:5])[-c(1,3,7)], 
			 vertex.color = "white", 
			 # edge.label = 1:5,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s,
			 edge.curved = F,
			 edge.arrow.size = 0.5,
			 margin = ma, 
			 layout = layout_in_circle)

text(-1, 1, "b)", adj = c(0,0))


nam <- ends(bi_net, 1:length(igraph::E(bi_as_net)))

comp <- bi_as_net %>%
		igraph::make_line_graph() %>% 
		igraph::complementer() 


colo <- c("#d7191c", "grey70", "#d7191c", "#2b83ba", "grey70", "#2b83ba", "#814E6B")
vertices <- layout_in_circle(comp)
plot.new()
scaling_x <- 0.94
scaling_y <- 0.58
centring_x <- -0.01
centring_y <- 0.2
# polygon((vertices[c(1,3,5), 1] + 1)/2 * scaling_x + centring_x, (vertices[c(1,3,5), 2] + 1) /2 *scaling_y +centring_y, col = "#d7191c")
par(new = T)
comp %>%
	plot(vertex.size = 35, 
			 # vertex.label = c(bi_sp_names_fancy[6:10], bi_sp_names_fancy[1:5])[-c(1,3,7)], 
			 vertex.color = NA, 
			 # edge.label = 1:5,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 edge.color = colo, 
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s,
			 edge.curved = F,
			 edge.arrow.size = 0.5,
			 margin = ma, 
			 layout = layout_in_circle)



text(-1, 1, "c)", adj = c(0,0))

# 
# igraph::max_cliques(min = matching$matching_size, 
# 												max = matching$matching_size,
# 												file = temporary_file)
## Legends

plot.new()
text(0.5, 0.5, expression(paste(italic(B), ": bipartite representation")), adj = c(0.5,0.75))

plot.new()
text(0.5, 0.5, expression(paste(italic(L(B)), ": line graph of ", italic(B))), adj = c(0.5,0.75))

plot.new()
text(0.5, 0.5, expression(paste(italic(H), ": complement of ", italic(L(B)))) , adj = c(0.5,0.75))
```

In the main text we show all maximum cardinality matchings for a simple example network. To further ilustrate our methodology, here we also show the approach for the smallest of our empirical networks, the uninvaded network at site 10 (Supporting Table 1; Supporting Figure 3). The largest component of this network is composed by 16 species of which 2 are non-invasive plants and the rest are pollinators. The one-to-one relationship between matched and superior nodes implies that in order to achieve full network controllability, most pollinators would be unmatched, and hence driver species that require external intervention. At the same time, both plants in the community, *Heracleum sphpndylum* and *Rubus fructicosus* and one of the pollinators *Orthotylus/Lygocorus* tend to be classified as superior nodes.

```{r fig-SA_exp, echo = F, message = F, warning = F, fig.width = 6.2, fig.height = 6.2, results = "hide", fig.cap = "**Illustration of the procedure with one empirical network**. (a) The initial visitation network. (b) The directed network in which the direction of control and the magnitude of the asymmetry are determined based on the mutual dependences. (c) One of the possible maximum matchings calculated using the procedures illustrated in the Supporting Figure 1 and 2."}
par(mfrow=c(2,2), mar=c(0,0,0,0))
n <- keep_largest_component(net$SA_exp)
replace_names <- data.frame(sp_name = igraph::V(n)$name) %>%
	dplyr::mutate(sp_number = 1:nrow(.),
								sp_letter = letters[sp_number], 
								sp_name = stringr::str_replace(sp_name, "[0-9]", ""),
								sp_name = stringr::str_replace(sp_name, "\\?rutitarse", "rufitarse"))
set.seed(7)

la <- igraph::layout_nicely(n)
n %>%
	plot(vertex.color = v_c, 
			 vertex.size = 15,
			 vertex.label = replace_names$sp_letter,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 vertex.label.cex = 0.9,
			 edge.label = round(igraph::E(.)$weight,1), 
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s*0.8,
			 edge.curved = F,
			 edge.arrow.size = 0.5,
			 margin = ma, 
			 layout = la)
text(label_pos_x, label_pos_y, paste0(letters[1], ")"), adj = c(0,0))

as_net <- n %>%
	bipartite_digraph(type = "weight", keep = "all", weight.type = "asymmetry", scale = F)
	
as_net %>%	
	plot(vertex.color = v_c, 
			 vertex.size = 15,
			 vertex.label = replace_names$sp_letter,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 vertex.label.cex = 0.9,
			 edge.label = round(igraph::E(.)$weight,2), 
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s*0.8,
			 edge.curved = F,
			 edge.arrow.size = 0.5,
			 margin = ma, 
			 layout = la)

text(label_pos_x, label_pos_y, paste0(letters[2], ")"), adj = c(0,0))


as_mat <- as_net %>%
	digraph_bipartite() %>% 
	max_bipartite_match()

as_all_mat <- as_net %>%
	digraph_bipartite() %>%
	igraph::make_line_graph() %>%
	igraph::complementer() %>% 
	igraph::max_cliques(min = as_mat$matching_size) %>%
	rev()

text_pos_x <- 0.5
text_pos_y <- -0.7

base_as_net <- n
# E(as_net)$weight <- round(E(as_net)$weight, 1)

or <- as_all_mat %>%
	plyr::laply(function(x){
		sum(E(as_net)$weight[x])
	}) %>% order(decreasing = T)

as_all_mat <- as_all_mat[or]

1 %>%
	plyr::l_ply(function(x){
		
		E(as_net)$matched <- 2
		E(as_net)$matched[as_all_mat[[x]]] <- 4
		
		igraph::V(as_net)$matched <- 2
		igraph::V(as_net)$matched[igraph::V(as_net)$name %in%
																ends(as_net, as_all_mat[[x]])[, 2]] <- 4
		
		igraph::V(as_net)$superior <- 1
		igraph::V(as_net)$superior[igraph::V(as_net)$name %in%
																ends(as_net, as_all_mat[[x]])[, 1]] <- 2
		
		# names_fancy <- sp_names_fancy
		# names_fancy[igraph::V(as_net)$name %in%
		# 														ends(as_net, as_all_mat[[x]])[, 1]] <-
		# 	sp_names_fancy_b[igraph::V(as_net)$name %in%
		# 														ends(as_net, as_all_mat[[x]])[, 1]]
		# 
		matching_weight <- sum(E(as_net)$weight[as_all_mat[[x]]])
		
		as_net %>% 
			plot(layout = la, 
					 vertex.size = igraph::V(.)$superior * 7 + 7,
					 vertex.label = replace_names$sp_letter,
					 vertex.label.family = fam,
					 vertex.label.color = l_c,
					 vertex.label.font = igraph::V(.)$superior,
					 vertex.label.cex = igraph::V(.)$superior * 0.1 + 0.9,
					 # vertex.shape = igraph::V(.)$vertex.shape,
					 vertex.color = pal[igraph::V(.)$matched],
					 edge.color = pal[E(.)$matched],
					 edge.label = NA, 
					 edge.width = E(.)$matched/2,
					 edge.label.family = fam,
					 edge.label.color = igraph::E(.)$matched,
					 edge.label.cex = l_s,
					 edge.curved = F,
					 edge.arrow.size = 0.5,
					 margin = ma) %>% 
			print()
		
		igraph::V(as_net)$name <- sp_names
		
		text(label_pos_x, label_pos_y, paste0(letters[2+x], ")"), adj = c(0,0))
		text(text_pos_x + 0.2, text_pos_y + 0.1, cex = 0.95,
				 paste0("D = ", length(igraph::V(as_net)) - as_mat$matching_size, "\n",
				 			 "matching size: ", as_mat$matching_size, "\n",
				 			 "matching weight: ", round(matching_weight, 1)))
})

plot.new()

legend(0.28, 0.95, legend = replace_names$sp_name, horiz = F, bty = "n", text.font = 3, cex = 0.9)
legend(0.2, 0.95, legend = replace_names$sp_letter, horiz = F, bty = "n", text.font = 2, cex = 0.9)

# library(grid)
# library(gridExtra)
# 
# ttt <- tableGrob(replace_names) 
# grid.newpage()
# grid.draw(ttt)

```

In addition, here we also show all the maximum cardinality matchings for an example network in which the links are weighted based on the mutual dependences (Supporting Figure 4). It is important to note that using mutual dependencies is problematic for a couple of reasons. 

First, having two links between species and using our maximum matching approach to calculate the control configurations, result in matchings that include cycle forming links (Supporting Figure 5). Strictly speaking these configurations are maximum matchings in the alternative bipartite configuration (Supporting Figure 1e) but are not in the directed network (Supporting Figure 1f).  While bidirectional links are the norm when using mutual dependences, they only appear in the asymmetry-weighted networks whenever the mutual dependences between two species symmetric. In this special case, we include two links weighted with 0.5 to reflect the fact that the species affect each other in the same proportion. Whenever present, we filter out the cycle containing matchings before conducting any analysis. In the special case when the network has no matchings that correspond to control configurations, we reduce by one the size of the cliques we enumerate in *H* (Supporting Figure 2).

Second, the number of maximal matchings increasses dispproportionally fast with the number of links in a network. For instance, our example network in Figure 1, which is composed by uni-directional links weighted by the asymmetry, has two different maximum matchings. In contrast, the equivalent network with bidirectional links has 16 different maximum matchings (Supporting Figure 4 and 5). To further ilustrate this growth, some of our empirical networks, had approximately ten thousand different maximum matchings using asymmetries but one hundred million when using mutual dependences. This exponential growth, and the computational cost of filtering matchings with cycles, surpassed the capabilities of the available computational resources and rendered us unable to calculate all possible maximum matchings when using mutual dependences in most of our networks.

```{r fig-matchings-bidirectional, echo = F, message = F, warning = F, fig.width = 6.2, fig.height = 3.2, results = "hide", fig.cap = "**Matchings of a simple network with bidirectional links**. (a) A network with bidirectional links. (b-e) Possible control configurations." }
par(mfrow=c(2,3), mar=c(0,0,0,0))

bi_net %>% 
	plot(layout = lay, 
			 vertex.color = v_c, 
			 vertex.size = 30,
			 vertex.label = sp_names_fancy,
			 vertex.label.family = fam,
			 vertex.label.color = l_c,
			 edge.label = round(E(.)$weight,1), 
			 edge.label.family = fam,
			 edge.label.color = l_c,
			 edge.label.cex = l_s,
			 edge.curved = T,
			 edge.arrow.size = 0.5,
			 margin = ma)

text(label_pos_x, label_pos_y, "a)", adj = c(0,0))

1:4 %>%
	plyr::l_ply(function(x, pal){
		
		attach(nets[[x]], pos = 1, warn.conflicts = F)	
		
		nets[[x]]$bi_net %>% 
			plot(layout = lay, 
					 vertex.size = 30,
					 vertex.label = names_fancy,
					 vertex.label.family = fam,
					 vertex.label.color = l_c,
					 vertex.label.cex = igraph::V(.)$superior * 0.1 + 0.9,
					 # vertex.shape = igraph::V(.)$vertex.shape,
					 vertex.color = pal[igraph::V(.)$matched],
					 edge.color = pal[igraph::E(.)$matched],
					 # edge.color = c("#B2ABD2", "#FDB863"),
					 edge.label = NA, 
					 edge.width = E(.)$matched/2,
					 edge.label.family = fam,
					 edge.label.color = igraph::E(.)$matched,
					 edge.label.cex = l_s,
					 edge.curved = T,
					 edge.arrow.size = 0.5,
					 margin = ma, 
					 palette = pal) %>% 
			print()
		
		igraph::V(bi_net)$name <- sp_names
		
		text(label_pos_x, label_pos_y, paste0(letters[1+x], ")"), adj = c(0,0))
		text(text_pos_x, text_pos_y, cex = 0.95,
				 paste0("D = ", length(igraph::V(bi_net)) - as_mat$matching_size, "\n",
				 			 "matching size: ", as_mat$matching_size, "\n",
				 			 "matching weight: ", round(matching_weight, 1)))
	}, pal)

plot.new()
legend(0.5, 0.7, legend = c("unmatched link", "matched link"), horiz = F,
			 lty = 1, 
			 col = pal[c(2, 4)],
			 lwd = 2, cex = 0.9, xjust=0.5, yjust=1, bty = "n")

legend(0.5, 0.5, legend = c("unmatched node", "matched node"), horiz = F,
			 pch = 21, 
			 pt.bg = pal[c(2, 4)],
			 pt.cex = 2,
			 cex = 0.9, xjust=0.5, yjust=1, bty = "n")

legend(0.5, 0.3, legend = expression(paste(bold("(bold label)"), " ", "superior nodes")), horiz = TRUE,
			 cex = 0.9, xjust=0.5, yjust=1, bty = "n")


```

```{r  fig-matchings-bidirectional-no, echo = F, message = F, warning = F, fig.width = 6.2, fig.height = 4.8, results = "hide", fig.cap= "**Cycles in a bidirectional network**. Our approach finds twelve configurations for Supporting Figure 4a that are not actual matchings."}

par(mfrow=c(3,4), mar=c(0,0,0,0))
5:length(nets) %>%
	plyr::l_ply(function(x, pal){
		
		attach(nets[[x]], pos = 1, warn.conflicts = F)	
		
		nets[[x]]$bi_net %>% 
			plot(layout = lay, 
					 vertex.size = 30,
					 vertex.label = names_fancy,
					 vertex.label.family = fam,
					 vertex.label.color = l_c,
					 vertex.label.cex = igraph::V(.)$superior * 0.1 + 0.9,
					 # vertex.shape = igraph::V(.)$vertex.shape,
					 vertex.color = pal[igraph::V(.)$matched],
					 edge.color = pal[igraph::E(.)$matched],
					 # edge.color = c("#B2ABD2", "#FDB863"),
					 edge.label = NA, 
					 edge.width = E(.)$matched/2,
					 edge.label.family = fam,
					 edge.label.color = igraph::E(.)$matched,
					 edge.label.cex = l_s,
					 edge.curved = T,
					 edge.arrow.size = 0.5,
					 margin = ma, 
					 palette = pal) %>% 
			print()
		
		igraph::V(bi_net)$name <- sp_names
		
		# text(label_pos_x, label_pos_y, paste0(letters[1+x-5], ")"), adj = c(0,0))
		# text(text_pos_x, text_pos_y, cex = 0.95,
		# 		 paste0("D = ", length(igraph::V(bi_net)) - as_mat$matching_size, "\n",
		# 		 			 "matching size: ", as_mat$matching_size, "\n",
		# 		 			 "matching weight: ", round(matching_weight, 1)))
	}, pal)

```

# S2: Properties of empirical networks

```{r calc-network-properties, echo = F, message = F}
net_prop <- net %>%
	plyr::ldply(function(x){
		x <- keep_largest_component(x)
		bipartite::networklevel(igraph::as_incidence_matrix(x, 
																												types = igraph::V(x)$type == "pla",
																												attr = "weight"),
														index = c("connectance", "web asymmetry", 
																			"ISA", 
																			"weighted NODF")) %>%
			as.list() %>% as.data.frame() %>%
			dplyr::mutate(n_sp = length(igraph::V(x)),
										n_pla = sum(igraph::V(x)$type == "pla"),
										n_pol = sum(igraph::V(x)$type == "pol"))
	})

library(xtable)

names(net_prop)[1] <- "net_name"

net_prop <- meta %>%
	dplyr::mutate(n_s_t = n_pla + n_pol) %>%
	dplyr::select(-n_pla, -n_pol) %>%
	dplyr::inner_join(net_prop)

```

The studied networks had species richess ranging between `r min(net_prop$n_s_t)` and `r max(net_prop$n_s_t)` (`r min(net_prop$n_sp)`-`r max(net_prop$n_sp)` when considering only the largest component in each network). As evidenced by the overall network asymmetry *AS* [@Bluthgen2007] networks had a low ratio of plants to pollinators. Furthermore, networks had relatively low levels of nestedness [when measured using the quantitative version of the NODF index; @Almeida-Neto2011]. Details for each network can be found in Supporting Table 1.

```{r table-network-properties, results = "asis", echo = F, message = F, warning = F, fig.width = 6.2, fig.height = 4.8, sanitize = FALSE}

net_prop %>%
	dplyr::select(-net_name, -count, -net) %>%
	dplyr::filter(study != "ballantyne") %>%
	dplyr::arrange(study, site, inv) %>%
	mutate_cond(inv == FALSE, invader = "—") %>%
  dplyr::mutate(site = rep(1:dplyr::n_distinct(site), each = 2),
                inv = plyr::mapvalues(inv, c(TRUE, FALSE), c("yes", "no")),
                study = plyr::mapvalues(study, 
                                        c("bartomeus", "lopezaraiza"),
                                        c("Cap de Creus, Spain",
                                          "Bristol, United Kingdom"))) %>%
	dplyr::select(site, invader, n_s_t, n_sp, n_pla, n_pol, connectance, web.asymmetry, weighted.NODF, study) %>%
	dplyr::rename_("$R$" = "n_s_t",
								 "$n_p$" = "n_pla",
								 "$n_a$" = "n_pol",
								 "location" = "study",
								 "$n_s$" = "n_sp",
								 "$c$"= "connectance", 
								 "NODF" = "weighted.NODF",
								 # "$\\bar{a}$" = "interaction.strength.asymmetry",
								 "$AS$" = "web.asymmetry") %>%
	xtable::xtable(caption = "\\textbf{Properties of the analysed plant-pollinator communities}. Invasive plants were \\textit{Carpobrotus affine acinaciformis} (car), \\textit{Opuntia stricta} (op), and \\textit{Impatients grandulifera} (imp). All properties, with the exception of the networks' total species richness ($R$), correspond to the network's largest component. Specifically we show the number of species ($n_s$), the number of plants ($n_p$), the number of pollinators ($n_a$), the network connectance ($c$), the network assymetry ($AS$), and the network nestedness (NODF index). British networks were assembled by Lopezaraiza-Mikel et al. (2007), Spanish were networks assembled by Bartomeus et al. (2008).") %>%
	print(#floating.environment = "sidewaystable", 
		comment = FALSE, sanitize.text.function = function(x){x}, include.rownames = FALSE)

# knitr::kable(meta)
```

# S3: Visitation as a proxy for species interdependence

Visitation frequency has been shown to be an appropriate surrogate for inter-specific effects in pollination networks [@Vazquez2005; @Bascompte2006]. 
Nevertheless visitation is not equivalent to pollen deposition and might be insufficient to reflect the dependencies of plants on animals and vice versa [@Alarcon2010; @King2013]. 
We therefore investigated the effect of calculating the dependencies using visitation or pollination effectiveness and importance---two metrics more proximate to plant reproductive success (Supporting Figure 6).
We did this by comparing *(i)* the manageability of the community and *(ii)* the percentage of interactions that maintained the direction of dependency. 
To do that, we used data collected by @Ballantyne2015 from a low diversity pollination community at a dry lowland heathland in Dorset, UK  (50° 43.7'N 2° 07.2'W). 
First, deposition networks were quantified using the mean Single Visit Deposition---the number of conspecific pollen grains effectively deposited on a virgin stigma during a single visit by a particular animal [@NeEman2010; @King2013; @Ballantyne2015]. 
Second, visitation networks were constructed counting the visits to flowers during Single Visit Depositions. 
Finally, pollinator importance networks were constructed as the product of pollinator efficiency and visit frequency. 

```{r fig-visitation-vs-deposition-vs-importance, echo = F, message = F, warning = F, fig.width = 6.2, fig.height = 4, results = "hide", fig.cap= "**Distribution of interaction weights for the pollen deposition, visitation and pollinator importance networks**. Note that the *x* axis in the density plots have been log-transformed."}
n_driver <- meta %>%
  dplyr::inner_join(n_matched) %>% 
  dplyr::mutate(n_driver = 1 - n_matched / (n_pla + n_pol))

p <- net[meta$net_name[meta$study == "ballantyne" & meta$count != "binary"]] %>%
	plyr::ldply(function(x) {
		data.frame(vname = igraph::E(x) %>% attr("vnames"), 
							weight = igraph::E(x)$weight)
	}, .inform = T) %>%
	dplyr::rename_("net_name" = ".id") %>%
	dplyr::mutate(net_name_f = factor(net_name,  
																		levels = c( 'bal_eff','bal_vis','bal_imp'),
																		labels = c("a) Deposition", "b) Visitation", "c) Importance")), 
	              pla = stringr::str_split_fixed(vname, "\\|", 2)[, 1],
	              pol = stringr::str_split_fixed(vname, "\\|", 2)[, 2]) %>%
  plyr::dlply("net_name_f", function(x){
    p1 <- x %>%
      ggplot(aes(x = pol, y = pla)) +
      geom_tile(aes(fill = weight, width = 0.9, height = 0.9)) + 
      coord_fixed() +
      scale_fill_gradient(low = "#f0f0f0", high = "#525252") +
      ylab("plants") +
      xlab("pollinators") + 
      fer_theme +
      theme(axis.text = element_blank(), 
            axis.ticks = element_blank(), 
            legend.position = "right", 
            legend.title = element_blank(), 
            plot.margin = grid::unit(c(6,0,2,5), "mm"),
            panel.grid = element_blank(),
            legend.key.width = grid::unit(4, "mm"),
            legend.key.height = grid::unit(4, "mm"))
    p2 <- x %>% ggplot(aes(x = weight)) +
      scale_x_log10() +
      stat_density(aes(y =..density..), geom = "line") +
      xlab("link weight") + 
      ylab("density") +
      ggtitle(x$net_name_f[1]) +
      fer_theme +
      theme(plot.margin = grid::unit(c(2,2,0,0), "mm"))
    list(p1, p2)
  }) 

cowplot::plot_grid(p[[1]][[2]], p[[1]][[1]], p[[2]][[2]], p[[2]][[1]], p[[3]][[2]], p[[3]][[1]], ncol = 2, rel_widths = c(1.5,2))  
```

We first investigated the effects at a network scale. 
Despite marked differences in the distribution of weights of the three networks, the minimum number of driver species to control the whole community was consistent among the three different approaches (`r 1-round(n_driver$n_driver[n_driver$net_name == "bal_eff"], digits = 2)` for deposition, `r 1-round(n_driver$n_driver[n_driver$net_name == "bal_vis"], digits = 2)` for the visitation, and `r 1-round(n_driver$n_driver[n_driver$net_name == "bal_imp"], digits = 2)` for the pollinator importance network).

The choice of weighting used can also have an impact on the relative importance of species.
Therefore we calculated the frequency that each species is present in the possible sets of driver species under the three schemes. 
Although visitation and deposition produce strikingly different results, we found a very strong agreement between the order produced by visitation and importance (Supporting Table 2). 
Finally, we investigated whether the asymmetry of mutual dependency, which defines the direction of control, was consistent among the three possible weighting schemes. We found again that the direction of the dominant dependency was maintained was consistent for 95\% of the interactions weighted by visitation or importance, the two most appropriate metrics for pollinator and plant dependency (Supporting Table 2).

```{r table-correlations-visitation-vs-efficiency, echo = FALSE, warning = F, message = F, results = "asis"}
d_sp <- driver %>%
  plyr::ldply(function(x) {
    get_frequencies(x) %>%
      dplyr::mutate(type = attr(x, "type"),
                    scaled = attr(x, "scaled"))
  }) %>%
  dplyr::inner_join(meta)

correlations <- d_sp %>%
	dplyr::filter(study == "ballantyne",
								threshold == 0.5,
								type == "asymmetry",
								scaled == F) %>%
	dplyr::group_by(net_name, threshold, type, scaled) %>%
	dplyr::mutate(d_weight = d_weight/max(d_weight),
								d_rank = rank(-d_weight, ties.method = "average")) %>%
	dplyr::group_by() %>%
	dplyr::select(net_name, species, d_rank) %>%
	tidyr::spread(net_name, d_rank) %>%
  dplyr::select(-species) %>%
  as.matrix() %>%
  Hmisc::rcorr(type = "spearman")


my_paste <- function(x, y){
  if(is.na(y)) return ("-")
  b <- ""
  if(y < 0.05) b <- ""
  paste0(b, round(x, digits = 2), " (", fix_small_pvalue(y, 3), ")", b)
}

dir_net_b <- net[meta$net_name[meta$study == "ballantyne"]] %>%
  lapply(function(x){
    x %>% 
      bipartite_digraph(type = "weight", keep = "all", weight.type = "asymmetry") %>%
      igraph::ends(igraph::E(.)) %>% 
      apply(1, function(y) paste(y[1], y[2]))
  })

# same order as the correlations 
dir_net_b <- dir_net_b[colnames(correlations$P)]

lt <- combn(length(dir_net_b), 2) %>%
  apply(2, function(x){
    length(intersect(dir_net_b[[x[1]]], dir_net_b[[x[2]]])) /
      length(dir_net_b[[x[1]]])
  }) %>%
  magrittr::multiply_by(100) %>% round() %>% paste0("%")

nam <- c("unweighted","deposition", "importance", "visitation")

mapply(my_paste, correlations$r, correlations$P) %>%
  matrix(ncol = length(dir_net_b)) %>% magrittr::set_colnames(nam) %>%
  magrittr::set_rownames(nam) %>% `[<-`(lower.tri(.), lt) %>% 
  xtable::xtable(caption = "\\textbf{Correlation of $n_d$ among network weighting schemes}. Spearman correlation coeffcients (with p-value) of the relative importance of species and the percentage of interactions that share the direction of dependency obtained using the three weighting schemes and an unweighted scheme.") %>%
	print(comment = FALSE, include.rownames = FALSE)
	
```

Altogether, evidence supports the idea that visitation is a suitable metric to estimate the mutual dependency of species pairs. First, it is directly related to pollinator foraging. Second, it produces results consistent, at least within our controllability framework, with plant reproductive success (as estimated by the importance metric).

# References
