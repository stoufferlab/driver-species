\documentclass[a4paper,10pt]{article}
\usepackage[margin=22.5mm]{geometry}
\usepackage{titlesec}

% abstract + title + authors
\usepackage{abstract}
\renewcommand{\abstractnamefont}{\normalfont\bfseries}
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} 
\usepackage{titlesec}
\usepackage{authblk}
\usepackage{datetime}
\newdateformat{usvardate}{ 
\monthname[\THEMONTH] \ordinal{DAY}, \THEYEAR}

% math
\usepackage{amssymb}
\usepackage{newtxmath}
 
% manuscript looking document
\usepackage{setspace}
\usepackage{lineno,xcolor}
\setlength{\parskip}{0.5em} 

% comments
\usepackage[draft]{todonotes}

% colorbox
\usepackage{tcolorbox}

% graphics
\usepackage{graphicx}
\usepackage{float}
\usepackage{sidecap}
\sidecaptionvpos{figure}{t}
\usepackage[font=small]{caption}
\usepackage{subcaption}

% table
\usepackage{booktabs}

% references & links
\usepackage[
backend=bibtex,
style= authoryear,
citestyle = authoryear,
url=false,
doi=true,
isbn=false
]{biblatex}
\addbibresource{references.bib}
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    citecolor=magenta,
    linkcolor=magenta
}
\usepackage{doi}

\begin{document}

<<libraries, echo = FALSE, warning = F, message = F>>=
library(magrittr)
library(knitr)
library(ggplot2)
library(glmulti)
library(Hmisc)
library(MuMIn)
opts_knit$set (root.dir=normalizePath('../'))
@

<<auxiliary functions, echo = FALSE, warning = F, message = F>>=
"./code/V2.0/functions" %>% 
	list.files(full.names = T) %>%
	plyr::l_ply(source)
@

<<plot theme, echo = FALSE, warning = F, message = F>>=
fer_theme <- theme_bw() +
	theme(text = element_text(family = "Times"),
	      title = element_text(size = 7.5, hjust = 0),
	      legend.title = element_text(size = 9),
	      legend.text = element_text(size = 8),
				axis.text = element_text(size = 8),
				axis.title = element_text(size = 9, hjust = 0.5), 
				strip.text = element_text(size = 9, hjust = 0), 
				strip.background = element_blank(),
				plot.margin = grid::unit(c(5, 0, 2, 0), "mm"))
@

<<read data and results, echo = FALSE, warning = F, message = F>>=
net <- "./data/V2.0/networks" %>%
	read_networks()
meta <- readr::read_csv("data/ntw_info.csv") %>% dplyr::tbl_df() %>%
	dplyr::rename(count = method)
n_matched <- readRDS("./data/V2.0/n_matched.rds")
m_f <- read_allRDS("./data/V2.0/matching_frequency")
m_f_b <- read_allRDS("./data/V2.0/matching_frequency_bi/")
a_m <- readRDS("./data/V2.0/n_matched_all_types.rds") 
s_p <- readRDS("./data/V2.0/species_properties.rds") %>% dplyr::tbl_df()
mod <- readRDS("./data/V2.0/species_models.rds")
# r_w <- readRDS("./data/V2.0/random_weights.rds") %>% dplyr::tbl_df() %>%
#   dplyr::rename_("net_name" = ".id")
r_w_bi <- readRDS("./data/V2.0/random_weights_bi.rds") %>% dplyr::tbl_df() %>%
  dplyr::rename_("net_name" = ".id")
@

% title
\title{
	{\LARGE \textsc{Structural controlability of pollination networks}}\\
	{\normalsize Supplementary Information} }
	% Authors and Affiliations
  \author{\large E. Fernando Cagua}
  \author{\large Kate Wootton}
  \author{\large Johanna Voinopol-Sassu}
  \author{\large Daniel B. Stouffer}
  \affil{\normalsize Center of Integrative Ecology, School of Biological Sciences, University of Canterbury}
\date{}
\maketitle

\renewcommand{\thefigure}{S\arabic{figure}}
\renewcommand{\thetable}{S\arabic{table}}

\onehalfspacing

\section{Manageability}

We calculated the number of driver species neccessary to control the whole community under the assumption that a species that depends more strongly on an interaction partner is controlled by the partner (\autoref{table:n_driver}). We tested the robustness of this assumption by comparing the relative number of driver species assuming that a) the dependency assymetry does not imply an unidirectional control direction, rather a species could control all its interaction partners and vice versa, b) that plants depend on pollinators and c) that pollinators depend on plants (\autoref{fig:alternative_matchings}). Our results using the direction of the largest dependency are consistent with the proposed alternatives: although we obtained different absolute numbers of driver species (\autoref{fig:alternative_assumptions}),  their relative numbers are not statistically distinguishable (\autoref{table:corr_driver}). 

\begin{table}
\centering
\small
<<table n_driver, echo = FALSE, warning = F, message = F, results = "asis">>=
# find n_driver
n_driver <- n_matched %>%
  dplyr::full_join(meta) %>% 
  dplyr::filter(!is.na(inv)) %>%
  dplyr::mutate(n_dr = n_pla + n_pol - n_matched,
                n_dr_p = n_matched / (n_pla + n_pol))

n_driver %>%
  dplyr::select(site, inv, n_pla, n_pol, n_dr, n_dr_p, study) %>%
  dplyr::arrange(study, site, inv) %>%
  dplyr::mutate(site = rep(1:dplyr::n_distinct(site), each = 2),
                inv = plyr::mapvalues(inv, c(TRUE, FALSE), c("yes", "no")),
                n_dr_p = round(n_dr_p, digits = 2),
                study = plyr::mapvalues(study, 
                                        c("bartomeus", "lopezaraiza"),
                                        c("Cap de Creus, Spain",
                                          "Bristol, United Kingdom"))) %>%
  dplyr::rename_("invaded" = "inv",
                 "No. pla." = "n_pla",
                 "No. pol." = "n_pol",
                 "$n_d$" = "n_dr",
                 "manageability" = "n_dr_p",
                 "source" = "study") %>%
  kable(align = "c", booktabs = T, 
        linesep = c("", "\\addlinespace"), escape = F)
@
\caption{\label{table:n_driver} Properties of the analysed plant-pollinator communities. British networks were assembled by \textcite{Lopezaraiza-Mikel2007}, Spanish networks assembled by \textcite{Bartomeus2008}.}
\end{table}

\begin{figure}
\centering
\begin{subfigure}[c]{0.8\textwidth}
\centering
<<fig explain matching pla-pol, echo = FALSE, warning = F, message = F, results = "asis", fig.height=1.4, fig.width=5.75>>=
my_theme <- theme_bw() +
	#scale_color_brewer(palette = "Paired") +
	theme(legend.position = "none",
				text = element_text(family = "Times"),
				plot.margin=unit(c(4,0,-4,0),"mm"),
				panel.margin=unit(c(0,0,0,0),"mm"),
				# panel.border = element_rect(colour = "grey10", size = 0.5),
				panel.border = element_blank(),
				axis.text = element_blank(),
				axis.ticks.x = element_blank(),
				axis.ticks.y = element_blank(),
				axis.title = element_text(size = 9),
				plot.title = element_text(hjust = 0.05, vjust = -1.5, size = 9),
				panel.grid = element_blank())

# Function to generate paths between each connected node
edgeMaker <- function(whichRow, len = 100, curved = TRUE){
	fromC <- layoutCoordinates[adj_list[whichRow, 1], ]  # Origin
	toC <- layoutCoordinates[adj_list[whichRow, 2], ]  # Terminus
	
	# Add curve:
	graphCenter <- colMeans(layoutCoordinates)  # Center of the overall graph
	bezierMid <- c(fromC[1], toC[2])  # A midpoint, for bended edges
	distance1 <- sum((graphCenter - bezierMid)^2)
	if(distance1 < sum((graphCenter - c(toC[1], fromC[2]))^2)){
		bezierMid <- c(toC[1], fromC[2])
	}  # To select the best Bezier midpoint
	bezierMid <- (fromC + toC + bezierMid) / 3  # Moderate the Bezier midpoint
	if(curved == FALSE){bezierMid <- (fromC + toC) / 2}  # Remove the curve
	
	edge <- data.frame(bezier(c(fromC[1], bezierMid[1], toC[1]),  # Generate
														c(fromC[2], bezierMid[2], toC[2]),  # X & y
														evaluation = len))  # Bezier path coordinates
	edge$Sequence <- 1:len  # For size and colour weighting in plot
	edge$Group <- paste(adj_list[whichRow, 1:2], collapse = ">")
	return(edge)
}

sp_names <- c("a[1]", "a[2]", "a[3]", "p[1]", "p[2]")

adj_matrix <- c(0,0,0,0,0,
								0,0,0,0,0,
								0,0,0,0,0,
								1,1,1,0,0,
								0,1,1,0,0) %>%
	matrix(nrow = 5, byrow = T) %>%
	`rownames<-`(sp_names) %>%
	`colnames<-`(sp_names)

net_exp <- adj_matrix %>% 
	igraph::graph_from_adjacency_matrix(mode = "directed") 
igraph::V(net_exp)$type <- c(F, F, F, T, T)
igraph::E(net_exp)$weight <- 1

layoutCoordinates <- cbind(c(0,1,2,0.5,1.5), 
													 c(1,1,1,0,0)) %>%
	`colnames<-`(c("x", "y"))

adj_list <- adj_matrix %>% 
	reshape2::melt() %>% 
	dplyr::filter(value > 0)

# Generate an edge path for each pair of connected nodes
n <- 17
allEdges <- lapply(1:nrow(adj_list), edgeMaker, len = n, curved = FALSE)
allEdges <- do.call(rbind, allEdges) %>%
	dplyr::filter(Sequence != n) %>%
	dplyr::mutate(Group = factor(Group),
				 type = Group)

new_lev <- c("m", "u", "u", "m", "u")
levels(allEdges$type) <- new_lev

nodes <- data.frame(layoutCoordinates) %>%
	dplyr::mutate(spe = sp_names,
								spe_c = c("m", "m", "u", "u", "u"), 
								pos = rep(c(0.25, -0.25), c(3,2)))

p1 <- ggplot(allEdges) +  # Pretty simple plot code
	geom_path(aes(x = x, y = y, group = Group, colour = type, size = type), 
						arrow = arrow(type = "closed", angle = 15, length = grid::unit(0.1, "inches"))) + # and taper
	geom_point(data = nodes,  # Add nodes
						 aes(x = x, y = y , fill = spe_c), size = 5, pch = 21,
						 colour = "black") + 
	geom_text(data = nodes, aes(x = x, y = y + pos, label = spe), size = 3, parse = T) +
	scale_fill_manual(values = c("#636363", "white")) + 
	scale_colour_manual(values = c("#636363", "#bdbdbd")) +
	my_theme + xlab("") + ylab("") + ylim(c(-0.27, 1.26)) +
 theme(plot.margin=unit(c(4,4,-4,-4),"mm")) +
	scale_size_manual(values = c(0.5, 0.5))
	
net_exp <- digraph_bipartite(net_exp)
adj_matrix <- net_exp %>% igraph::as_adjacency_matrix(sparse = F, type = "upper")
layoutCoordinates <- cbind(rep(0:4, 2), rep(c(1,0), each = 5)) %>%
	`colnames<-`(c("x", "y"))

adj_list <- adj_matrix %>% 
	reshape2::melt() %>% 
	dplyr::filter(value > 0)

# Generate an edge path for each pair of connected nodes
n <- 100
allEdges <- lapply(1:nrow(adj_list), edgeMaker, len = n, curved = FALSE)
allEdges <- do.call(rbind, allEdges) %>%
	dplyr::filter(Sequence != n,
								Sequence != 1) %>%
	dplyr::mutate(Group = factor(Group),
				 type = Group)

new_lev <- c("m", "u", "u", "m", "u")
levels(allEdges$type) <- new_lev

nodes <- data.frame(layoutCoordinates) %>%
	dplyr::mutate(spe = rep(sp_names, 2),
								spe_l = c(paste0(sp_names, " %->% phantom(0)"), paste0(sp_names, " %<-% phantom(0)")),
								spe_c = c(rep("u",5), c("m", "m", "u", "u", "u")), 
								pos = rep(c(0.25, -0.25), each = 5))

p2 <- ggplot(allEdges) +  # Pretty simple plot code
	geom_path(aes(x = x, y = y, group = Group, colour = type, size = type)) + # and taper
	geom_point(data = nodes,  # Add nodes
						 aes(x = x, y = y, fill = spe_c), size = 5, pch = 21,
						 colour = "black") + 
	geom_text(data = nodes, aes(x = x + 0.08, y = y + pos, label = spe_l), parse = T, size = 3) +
	# coord_flip()  + scale_x_reverse() + scale_y_reverse() +
	scale_fill_manual(values = c("#636363", "white")) + 
	scale_colour_manual(values = c("#636363", "#bdbdbd")) +
	xlim(c(-0.12, 4.12)) + ylim(c(-0.27, 1.26)) +
	my_theme + xlab("") + ylab("") +
	scale_size_manual(values = c(0.5, 0.5))

multiplot(p1, p2, layout = matrix(nrow = 1, c(1,1,1,2,2,2,2,2)))
@
\caption{plants can drive the abbundance of pollinators but not otherwise}
\end{subfigure}

\begin{subfigure}[c]{0.8\textwidth}
\centering
<<fig explain matching pol-pla, echo = FALSE, warning = F, message = F, results = "asis", fig.height=1.4, fig.width=5.75>>=


sp_names <- c("a[1]", "a[2]", "a[3]", "p[1]", "p[2]")

adj_matrix <- c(0,0,0,1,0,
								0,0,0,1,1,
								0,0,0,1,1,
								0,0,0,0,0,
								0,0,0,0,0) %>%
	matrix(nrow = 5, byrow = T) %>%
	`rownames<-`(sp_names) %>%
	`colnames<-`(sp_names)

net_exp <- adj_matrix %>% 
	igraph::graph_from_adjacency_matrix(mode = "directed") 
igraph::V(net_exp)$type <- c(F, F, F, T, T)
igraph::E(net_exp)$weight <- 1

layoutCoordinates <- cbind(c(0,1,2,0.5,1.5), 
													 c(1,1,1,0,0)) %>%
	`colnames<-`(c("x", "y"))

adj_list <- adj_matrix %>% 
	reshape2::melt() %>% 
	dplyr::filter(value > 0)

# Generate an edge path for each pair of connected nodes
n <- 17
allEdges <- lapply(1:nrow(adj_list), edgeMaker, len = n, curved = FALSE)
allEdges <- do.call(rbind, allEdges) %>%
	dplyr::filter(Sequence != n) %>%
	dplyr::mutate(Group = factor(Group),
				 type = Group)

new_lev <- c("m", "u", "m", "u", "u")
levels(allEdges$type) <- new_lev

nodes <- data.frame(layoutCoordinates) %>%
	dplyr::mutate(spe = sp_names,
								spe_c = c("u", "u", "u", "m", "m"), 
								pos = rep(c(0.25, -0.25), c(3,2)))

p1 <- ggplot(allEdges) +  # Pretty simple plot code
	geom_path(aes(x = x, y = y, group = Group, colour = type, size = type), 
						arrow = arrow(type = "closed", angle = 15, length = grid::unit(0.1, "inches"))) + # and taper
	geom_point(data = nodes,  # Add nodes
						 aes(x = x, y = y , fill = spe_c), size = 5, pch = 21,
						 colour = "black") + 
	geom_text(data = nodes, aes(x = x, y = y + pos, label = spe), size = 3, parse = T) +
	scale_fill_manual(values = c("#636363", "white")) + 
	scale_colour_manual(values = c("#636363", "#bdbdbd")) +
	my_theme + xlab("") + ylab("") + ylim(c(-0.27, 1.26)) +
 theme(plot.margin=unit(c(4,4,-4,-4),"mm")) +
	scale_size_manual(values = c(0.5, 0.5))
	
net_exp <- digraph_bipartite(net_exp)
adj_matrix <- net_exp %>% igraph::as_adjacency_matrix(sparse = F, type = "upper")
layoutCoordinates <- cbind(rep(0:4, 2), rep(c(1,0), each = 5)) %>%
	`colnames<-`(c("x", "y"))

adj_list <- adj_matrix %>% 
	reshape2::melt() %>% 
	dplyr::filter(value > 0)

# Generate an edge path for each pair of connected nodes
n <- 100
allEdges <- lapply(1:nrow(adj_list), edgeMaker, len = n, curved = FALSE)
allEdges <- do.call(rbind, allEdges) %>%
	dplyr::filter(Sequence != n,
								Sequence != 1) %>%
	dplyr::mutate(Group = factor(Group),
				 type = Group)

new_lev <- c("m", "m", "u", "u", "u")
levels(allEdges$type) <- new_lev

nodes <- data.frame(layoutCoordinates) %>%
	dplyr::mutate(spe = rep(sp_names, 2),
								spe_l = c(paste0(sp_names, " %->% phantom(0)"), paste0(sp_names, " %<-% phantom(0)")),
								spe_c = c(rep("u",5), c("u", "u", "u", "m", "m")), 
								pos = rep(c(0.25, -0.25), each = 5))

p2 <- ggplot(allEdges) +  # Pretty simple plot code
	geom_path(aes(x = x, y = y, group = Group, colour = type, size = type)) + # and taper
	geom_point(data = nodes,  # Add nodes
						 aes(x = x, y = y, fill = spe_c), size = 5, pch = 21,
						 colour = "black") + 
	geom_text(data = nodes, aes(x = x + 0.08, y = y + pos, label = spe_l), parse = T, size = 3) +
	# coord_flip()  + scale_x_reverse() + scale_y_reverse() +
	scale_fill_manual(values = c("#636363", "white")) + 
	scale_colour_manual(values = c("#636363", "#bdbdbd")) +
	xlim(c(-0.12, 4.12)) + ylim(c(-0.27, 1.26)) +
	my_theme + xlab("") + ylab("") +
	scale_size_manual(values = c(0.5, 0.5))

multiplot(p1, p2, layout = matrix(nrow = 1, c(1,1,1,2,2,2,2,2)))
@
\caption{pollinators can drive the abbundance of plants but not otherwise}
\end{subfigure}

\begin{subfigure}[c]{0.8\textwidth}
\centering
<<fig explain matching both, echo = FALSE, warning = F, message = F, results = "asis", fig.height=1.4, fig.width=5.75>>=

sp_names <- c("a[1]", "a[2]", "a[3]", "p[1]", "p[2]")

adj_matrix <- c(0,0,0,1,0,
								0,0,0,1,1,
								0,0,0,1,1,
								1,1,1,0,0,
								0,1,1,0,0) %>%
	matrix(nrow = 5, byrow = T) %>%
	`rownames<-`(sp_names) %>%
	`colnames<-`(sp_names)

net_exp <- adj_matrix %>% 
	igraph::graph_from_adjacency_matrix(mode = "directed") 
igraph::V(net_exp)$type <- c(F, F, F, T, T)
igraph::E(net_exp)$weight <- 1

layoutCoordinates <- cbind(c(0,1,2,0.5,1.5), 
													 c(1,1,1,0,0)) %>%
	`colnames<-`(c("x", "y"))

adj_list <- adj_matrix %>% 
	reshape2::melt() %>% 
	dplyr::filter(value > 0)

# Generate an edge path for each pair of connected nodes
n <- 17
allEdges <- lapply(1:nrow(adj_list), edgeMaker, len = n, curved = FALSE)
allEdges <- do.call(rbind, allEdges) %>%
	dplyr::filter(Sequence != n) %>%
	dplyr::mutate(Group = factor(Group),
				 type = Group)

new_lev <- c("m", "u", "m", "u", "u", "u", "m", "u", "u", "m")
dir <- c("m", "m", "m", "m", "m", "u", "u", "u", "u", "u")
dir2 <- c("m", "u", "m", "u", "u", "u", "m", "m", "u", "m")
id <- 1:10
allEdges %<>% dplyr::mutate(dir = type,
                            dir2 = dir)
levels(allEdges$type) <- new_lev
levels(allEdges$dir) <- dir
levels(allEdges$dir2) <- dir2
allEdges %<>% 
  dplyr::mutate(dir = as.numeric(dir),
                dir2 = as.numeric(dir2),
                dir = plyr::mapvalues(dir, c(1,2), c(0.03, -0.03)),
                dir2 = plyr::mapvalues(dir2, c(1,2), c(0.03, -0.03)))

nodes <- data.frame(layoutCoordinates) %>%
	dplyr::mutate(spe = sp_names,
								spe_c = c("u", "m", "m", "m", "m"), 
								pos = rep(c(0.25, -0.25), c(3,2)))

# ggplot(allEdges) +  # Pretty simple plot code
# 	geom_path(aes(x = x + dir, y = y + dir2, group = Group, colour = type, size = type), 
# 						arrow = arrow(type = "closed", angle = 15, length = grid::unit(0.1, "inches")))

p1 <- ggplot(allEdges) +  # Pretty simple plot code
	geom_path(aes(x = x + dir, y = y + dir2, group = Group, colour = type, size = type), 
						arrow = arrow(type = "closed", angle = 15, length = grid::unit(0.1, "inches"))) + # and taper
	geom_point(data = nodes,  # Add nodes
						 aes(x = x, y = y , fill = spe_c), size = 5, pch = 21,
						 colour = "black") + 
	geom_text(data = nodes, aes(x = x, y = y + pos, label = spe), size = 3, parse = T) +
	scale_fill_manual(values = c("#636363", "white")) + 
	scale_colour_manual(values = c("#636363", "#bdbdbd")) +
	my_theme + xlab("") + ylab("") + ylim(c(-0.27, 1.26)) +
 theme(plot.margin=unit(c(4,4,-4,-4),"mm")) +
	scale_size_manual(values = c(0.5, 0.5))
	
net_exp <- digraph_bipartite(net_exp)
adj_matrix <- net_exp %>% igraph::as_adjacency_matrix(sparse = F, type = "upper")
layoutCoordinates <- cbind(rep(0:4, 2), rep(c(1,0), each = 5)) %>%
	`colnames<-`(c("x", "y"))

adj_list <- adj_matrix %>% 
	reshape2::melt() %>% 
	dplyr::filter(value > 0)

# Generate an edge path for each pair of connected nodes
n <- 100
allEdges <- lapply(1:nrow(adj_list), edgeMaker, len = n, curved = FALSE)
allEdges <- do.call(rbind, allEdges) %>%
	dplyr::filter(Sequence != n,
								Sequence != 1) %>%
	dplyr::mutate(Group = factor(Group),
				 type = Group)

new_lev <- c("m", "m", "u", "u", "u", "u", "m", "u", "u", "m")
levels(allEdges$type) <- new_lev

nodes <- data.frame(layoutCoordinates) %>%
	dplyr::mutate(spe = rep(sp_names, 2),
								spe_l = c(paste0(sp_names, " %->% phantom(0)"), paste0(sp_names, " %<-% phantom(0)")),
								spe_c = c(rep("u",5), c("u", "m", "m", "m", "m")), 
								pos = rep(c(0.25, -0.25), each = 5))

p2 <- ggplot(allEdges) +  # Pretty simple plot code
	geom_path(aes(x = x, y = y, group = Group, colour = type, size = type)) + # and taper
	geom_point(data = nodes,  # Add nodes
						 aes(x = x, y = y, fill = spe_c), size = 5, pch = 21,
						 colour = "black") + 
	geom_text(data = nodes, aes(x = x + 0.08, y = y + pos, label = spe_l), parse = T, size = 3) +
	# coord_flip()  + scale_x_reverse() + scale_y_reverse() +
	scale_fill_manual(values = c("#636363", "white")) + 
	scale_colour_manual(values = c("#636363", "#bdbdbd")) +
	xlim(c(-0.12, 4.12)) + ylim(c(-0.27, 1.26)) +
	my_theme + xlab("") + ylab("") +
	scale_size_manual(values = c(0.5, 0.5))

multiplot(p1, p2, layout = matrix(nrow = 1, c(1,1,1,2,2,2,2,2)))
@
\caption{plants can drive the abbundance of pollinators with the same likelyhood than pollinators can modify the abbundance of plants}
\end{subfigure}
\caption{\label{fig:alternative_matchings} Here we show one of the possible maximum matching for each of the direction of control assumptions in the same simple plant pollinator network. }
\end{figure}

\begin{figure}
\centering
<<fig alternative assumptions, echo = FALSE, warning = F, message = F, fig.height=1.5, fig.width=4.3>>=
a_m_driver <- a_m %>% 
  dplyr::full_join(meta) %>%
  dplyr::filter(study != "ballantyne") %>% 
  dplyr::mutate(type = factor(type, 
                              levels =  c("AB", "BA", "weight", "z-bi"),
                              labels = c("pla. to pol.", "pol. to pla.", "dependency", "bidirectional")),
                type_l  = as.character(type)) %>%
  dplyr::mutate(n_driver = n_pla + n_pol - n_matched, 
                n_driver_rel = 1 - n_matched / (n_pla + n_pol)) 

type_l <- unique(a_m_driver$type_l)

a_m_driver %>%
  ggplot(aes(x = type, y = 1 - n_driver_rel), parse = T) +
  geom_boxplot(size = 0.25, colour = "grey10",
							 outlier.shape = 21, outlier.size = 1) +
  coord_flip() + 
  xlab("") +
  ylab("manageability") + 
  fer_theme + 
  theme(plot.margin = grid::unit(c(0,1,2,0), "mm"))

@
\caption{\label{fig:alternative_assumptions} Proportion of driver species necessary to control the full pollination network under four different assumptions of the direction of control}
\end{figure}

\begin{table}
\centering
\small
<<table alternative assumptions, echo = FALSE, warning = F, message = F, results = "asis">>=

corr_matrix <- a_m_driver %>%
  dplyr::select(net_name, type, n_driver) %>%
  tidyr::spread(type, n_driver) %>%
  dplyr::select(-net_name) %>%
  as.matrix() %>%
  cor(method = "spearman") %>%
  round(digits = 2)

corr_matrix[lower.tri(corr_matrix, diag = T)] <- ""
corr_matrix <- corr_matrix[, -1]
corr_matrix <- corr_matrix[-(nrow(corr_matrix)), ]
kable(corr_matrix, align = "c", format = "latex", booktabs = T)

@
\caption{\label{table:corr_driver} Spearman correlation coefficients of the number of driver species necessary to control the full pollination network under the four different assumptions of the direction of control.}
\end{table}

We built a set of three generalised linear models with a logistic error structure to investigate the variables that influence the set of driver species. We found that the proportion of driver species is largely independent of the study site but highly dependent on the ratio of plant to pollinator diveristy (\autoref{table:n_driver_explanatory}).

\begin{table}
\centering
\small
<<table explaining n_driver, echo = FALSE, warning = F, message = F, results = "asis">>=


m0 <- glm(cbind(n_dr, n_matched) ~ n_pla * n_pol + study + inv, 
          data = n_driver, 
          family = "binomial")
m_nr <- glm(cbind(n_dr, n_matched) ~ I(n_pla/n_pol) + study + inv, 
          data = n_driver, 
          family = "binomial")
m8 <- glm(cbind(n_dr, n_matched) ~ I(n_pla/n_pol) + inv, 
          data = n_driver, 
          family = "binomial")
m9 <- glm(cbind(n_dr, n_matched) ~ I(n_pla/n_pol) + study, 
          data = n_driver, 
          family = "binomial")
m1 <- glm(cbind(n_dr, n_matched) ~ I(n_pla/n_pol), 
          data = n_driver, 
          family = "binomial")
m2 <- glm(cbind(n_dr, n_matched) ~ study, 
          data = n_driver, 
          family = "binomial")
m3 <- glm(cbind(n_dr, n_matched) ~ I(n_pla + n_pol), 
          data = n_driver, 
          family = "binomial")
m4 <- glm(cbind(n_dr, n_matched) ~ n_pla, 
          data = n_driver, 
          family = "binomial")
m5 <- glm(cbind(n_dr, n_matched) ~ n_pol, 
          data = n_driver, 
          family = "binomial")
m6 <- glm(cbind(n_dr, n_matched) ~ inv, 
          data = n_driver, 
          family = "binomial")
m7 <- glm(cbind(n_dr, n_matched) ~ study + inv, 
          data = n_driver, 
          family = "binomial")

ms <- MuMIn::model.sel(m_nr, m1, m2, m0, m3, m4, m5, m6, m7, m8, m9)

i <- 1:8 # indices of columns with model terms
response <- "m"

res <- as.data.frame(ms)
v <- names(ms)[i]
v[v == "(Intercept)"] <- 1

# create formula-like model names:
mnames <- apply(res[, i], 1, function(x) 
     deparse(MuMIn::simplify.formula(reformulate(v[!is.na(x)], response = response)))) %>%
  sub("study", "s", .) %>%
  sub("I(n_pla/n_pol)", "r_{p/a}", ., fixed = T) %>%
  sub("I(n_pla + n_pol)", "n", ., fixed = T) %>%
  sub("n_pla * n_pol", "n_p + n_a + n_p:n_a", ., fixed = T) %>%
  sub("n_pla", "n_p", .) %>%
  sub("inv", "i", .) %>%
  sub("n_pol", "n_a", .) %>%
  sub("~", '\\\\sim', .) %>%
  paste0("$", ., "$")

res <- dplyr::rename_(res, "$\\Delta$AIC" = "delta")

cbind(model = mnames, res[, -i]) %>%
  knitr::kable(align = "c", booktabs = T, digits = 2, escape = F, row.names = F, linesep = "")
@
\caption{\label{table:n_driver_explanatory} The manageability ($m$) is largaly influenced by the ratio of plant to pollinator species richness ($r_{p/a}$) but not the location of the community ($s$), the plant richness ($n_p$), the pollinator richness ($n_a$), or the total number of species in the community ($n$). NOTE: In reality the response variable was cbind($n_d$, $1-n_d$), what's the convention to specify such a model?}
\end{table}

\begin{figure}
\centering
<<fig randomisations bi, echo = FALSE, warning = F, message = F, fig.height=1.46, fig.width=3.1>>=
r_bi <- r_w_bi %>%
  dplyr::inner_join(meta) %>%
  dplyr::filter(count == "visitation") %>%
  dplyr::mutate(n_dr = n_pla + n_pol - n_matched)

# non-parametric
z_scores_bi <- r_bi$method %>%
  unique() %>%
  plyr::ldply(function(x){
    a_m %>%
      dplyr::filter(type == "z-bi") %>%
      dplyr::inner_join(meta) %>%
      dplyr::filter(count == "visitation") %>%
      dplyr::mutate(n_dr = n_pla + n_pol - n_matched) %>%
      dplyr::mutate(method = x)
  }) %>% 
  dplyr::bind_rows(r_bi) %>%
  dplyr::group_by(net_name, method) %>%
  dplyr::mutate(z_r = rank(n_dr, na.last = NA),
                z_s = qlogis(z_r/n()),
                z_s = replace(z_s, is.infinite(z_s) & z_s > 0, qlogis(0.999)),
                z_s = replace(z_s, is.infinite(z_s) & z_s < 0, qlogis(0.001))) %>%
  dplyr::filter(is.na(sim))

z_scores_bi %<>%
  plyr::ddply("method", function(x){
    x %>%
      dplyr::mutate(sign = t.test(z_s)$p.value)
  }, .inform = T) %>% 
  dplyr::group_by(method) %>%
  dplyr::mutate(m_z = median(z_s)) %>%
  dplyr::group_by() %>%
  dplyr::arrange(m_z) %>%
  dplyr::filter(method %in% c("swsh_both", 
                              "quasiswap_count"
                              # "r00_both", 
                              # "r0_both", 
                              # "c0_both", 
                              ))


z_scores_method_order <- unique(z_scores_bi$method)

z_scores_bi %>%
  dplyr::mutate(method = factor(method, levels = z_scores_method_order),
                m_n = as.numeric(method),
                m_n = replace(m_n, m_n == 3, 3.5)) %>%
  ggplot(aes(x = m_n, y = -1 * z_s)) +
  # geom_hline(yintercept = c(-0), linetype = 2, alpha = 0.7, size = 0.25) + 
  # geom_vline(xintercept = c(2.75), alpha = 0.6, size = 0.25) +
  geom_hline(yintercept = 0, size = 0.25, linetype = 2, colour = "grey30") +
  geom_boxplot(aes(group = method), size = 0.25, colour = "grey10",
							 outlier.shape = 21, outlier.size = 1) +
  # geom_point(aes(y = 9, colour = sign <= 0.05), shape = 8, size = 1) +
  coord_flip() +
  # scale_fill_manual(values = c("white", "#bdbdbd")) +
  scale_x_continuous(breaks = c(1, 2, 3.5), labels = rev(c("random\ndependency", "maintain strength\nrandomise degree", "maintain degree\nrandomise strength"))) +
  xlab("") +
  ylab("Z-score of emp. manageability") + 
  fer_theme +
  theme(axis.text.x = element_text(angle = 90), 
        legend.position = "none",
				plot.margin = grid::unit(c(2, 1, 2, 0), "mm"), 
				# panel.grid.minor.x = element_blank(),
				panel.grid.minor.y = element_blank())

@
\caption{\label{fig:randomisations_bi} The manageability of network randomisations that mantain the strength or the degree of species is not different from the empirical manageability using bidirectional links.}
\end{figure}

\section{Driver species}

<<driver species dependency, echo = FALSE, warning = F, message = F>>=

get_frequencies <- . %>%
  plyr::ldply(function(x){
    plyr::ldply(x, function(y){
      matched <- y$matched %>%
        dplyr::rename(species = ve,
                      m_freq = ma, 
                      m_weight = we)
      driver <- y$driver %>%
        dplyr::rename(species = vs,
                      d_freq = ma, 
                      d_weight = we)
      dplyr::inner_join(matched, driver, by = "species") %>%
        dplyr::mutate(n_matchings = attr(y, "n_matchings"))
    }, .id = "threshold") 
	}, .id = "net_name") %>% 
  dplyr::mutate(threshold = as.numeric(as.character(threshold))) %>%
  dplyr::filter(threshold %in% c(0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1)) %>%
  dplyr::mutate(m_reim = m_freq/n_matchings,
                d_reim = d_freq/n_matchings,
                d_weight = d_weight/n_matchings)

drivers_b <- get_frequencies(m_f_b) %>% 
  dplyr::mutate(type = "z-bi") 

drivers <- get_frequencies(m_f) %>% 
  dplyr::mutate(type = "weight") %>%
  dplyr::bind_rows(drivers_b)
  
driver_sp <- drivers %>%
  dplyr::filter(threshold == 1) %>%
  dplyr::group_by(net_name, species, type) %>%
  dplyr::summarise(imp = d_weight != 1,
                   d_reim_0 = d_weight,
                   sp_imp = paste(d_weight, species))

drivers %<>%
  dplyr::inner_join(driver_sp) %>%
  dplyr::inner_join(meta)

n_matchings <- drivers %>%
  dplyr::filter(threshold == 1, count != "binary") %>%
  dplyr::group_by(net_name, type) %>%
  dplyr::summarise(n_matchings = mean(n_matchings))


p_weights <- drivers %>%
  dplyr::group_by(net_name, type, threshold) %>%
  dplyr::summarise(n_matchings = mean(n_matchings)) %>% 
  dplyr::mutate(new_m = n_matchings - lead(n_matchings),
                new_m = replace(new_m, is.na(new_m), last(n_matchings))) %>%
  dplyr::select(-n_matchings)

drivers <- drivers %>%
  dplyr::inner_join(p_weights) %>%
  dplyr::group_by(net_name, type, species) %>%
  dplyr::mutate(d_weight_mean = weighted.mean(d_weight, new_m))
@

Unlike unweighted networks, where a maximum matching is defined by its size (the number of matched edges), in weighted networks, a maximum matching is one whose edges have the largest possible total weight among all possible matchings. This means that in weighted networks there is a number of matchings that have maximal size, but are not maximum matchings because its total weight is not maximal too. Therefore, for weighted networks the number of possible maximum matchings, even for lage networks, can be small (in the studied networks this number ranged from \Sexpr{min(n_matchings$n_matchings)} to \Sexpr{max(n_matchings$n_matchings)}, $\bar{\mu} = \Sexpr{mean(n_matchings$n_matchings)}$). 

However the weight of species dependencies is unexact, a reflection of the fact that interaction strengths and sampling methods themselves are stochastic to some extent. This means that certain level of tolerance must be introduced so that we accept some matchings that have the same size but only a proportion of the maximum matching weight. As this proportion decreasses we accept a markedly larger number of matchings (\autoref{fig:threshold_n_matchings}).

\begin{figure}
\centering
<<fig threshold matching, echo = FALSE, warning = F, message = F, fig.height=2.19, fig.width=3.1>>=

drivers %>%
  dplyr::filter(count != "binary") %>%
  dplyr::group_by(net_name, threshold, type) %>%
  dplyr::summarise(n_matchings = mean(m_freq + d_freq), 
                   n_sp = mean(n_pla + n_pol)) %>%
  dplyr::group_by(net_name) %>%
  dplyr::mutate(n_matchings_rel = n_matchings / max(n_matchings)) %>%
  ggplot(aes(x = threshold, y = n_matchings)) +
  # geom_point(aes(colour = type), size = 1) +
  geom_line(aes(group = interaction(type, net_name),
                colour = type)) +
  scale_color_manual(values = c("#252525", "#636363")) + 
  scale_y_log10() +
  xlab("proportion of maximum matching weight (threshold)") +
  ylab("number of accepted matchings") +
  fer_theme +
  theme(legend.position = "none")
@
\caption{\label{fig:threshold_n_matchings} The number of accepted matchings increasses as the proportion of maximum matching weight decreasses. Each line correspond to one studied network.}
\end{figure}


<<>>=


get_correlations <- function(y, limit = 5, var = "d_reim", by = c("net_name", "threshold")){
  y %>%
  dplyr::filter(count == "visitation") %>%
  plyr::ddply(by, function(x){
    c <- x %>% 
      dplyr::select_("species", var, "type") %>%
      tidyr::spread_("type", var) %>%
      dplyr::arrange(species)
    
    names(c)<- make.names(names(c)) 
    
    if(ncol(c) == 2) return(NULL)
    
    c %<>%
      dplyr::mutate(w_r = rank(-weight, ties.method = "average"),
                    b_r = rank(-z.bi, ties.method = "average"),
                    weight = replace(weight, w_r > limit & b_r > limit, NA),
                    z.bi = replace(z.bi, w_r > limit & b_r > limit, NA))

    if(nrow(dplyr::filter(c, !is.na(weight))) <= 1) return(NULL)
    
    c <- cor.test(c$weight, c$z.bi, method = "spearman", exact = F)
    
    data.frame(statistic = c$statistic,
               p_value = c$p.value,
               estimate = c$estimate)
  }, .inform = T)
}

correlations <- get_correlations(drivers, limit = 5, "d_weight")

correlations %>%
  ggplot(aes(x = threshold, y = estimate)) +
  geom_line(aes(colour = net_name)) +
  geom_point(aes(fill = p_value < 0.05), shape = 21) +
  geom_smooth()

drivers %>%
  dplyr::filter(threshold == 0) %>%
  get_correlations(limit= 5, "d_weight_mean", by = "net_name") %>%
  dplyr::inner_join(meta) %>%
  ggplot(aes(x = n_pla + n_pol, y = estimate)) +
  geom_point()


drivers %>%
  dplyr::filter(threshold == 1) %>%
  dplyr::group_by(net_name, type) %>%
  dplyr::mutate(ranked = rank(-d_weight_mean, ties.method = "min")) %>%
  dplyr::filter(ranked == 1 | ranked == 2) %>% 
  dplyr::select(net_name, type, species, ranked) %>%
  dplyr::arrange(net_name, type, species) %>% View
  
@


<<fig comparing thresholds, echo = FALSE, warning = F, message = F, fig.height=2.19, fig.width=6.2>>=


# ggplot(drivers, aes(x = threshold, y = d_reim - d_reim_0, colour = d_reim_0, group = species)) +
#   geom_hline(yintercept = c(-0.5, 0.5), linetype = 2) +
#   geom_point() +
#   geom_line() +
#   facet_wrap(~ net_name + type) +
#   scale_alpha_manual(values = c(1, 0.3)) +
#   ylim(c(-1, 1)) +
#     scale_color_gradient2(low = "#377eb8",
#                          high = "#e41a1c",
#                          mid = "grey80", midpoint = 0.5) +
#   fer_theme
# 
# drivers %>%
#   dplyr::filter(study == "ballantyne") %>%
#   ggplot(aes(x = threshold, y = d_reim - d_reim_0, colour = d_reim_0, group = species)) +
#   geom_hline(yintercept = c(-0.5, 0.5), linetype = 2) +
#   geom_point() +
#   geom_line() +
#   facet_grid(net_name + type ~ species) +
#   scale_color_gradient2(low = "#377eb8",
#                          high = "#e41a1c",
#                          mid = "grey80", midpoint = 0.5) +
#   ylim(c(-1, 1)) +
#   fer_theme

# p1 <-
  d %>%
  dplyr::filter(study == "ballantyne", 
                count == "importance" | count == "visitation") %>%
  ggplot(aes(x = threshold, y = d_weight, group = species)) +
  # geom_hline(yintercept = c(-0.5, 0.5), linetype = 2) +
  geom_line(aes(colour = d_weight_mean)) +
  geom_hline(aes(yintercept = d_weight_mean, colour = d_weight_mean)) +
  geom_point(aes(colour = d_weight_mean), size = 1) +
  facet_wrap(type ~ net_name) +
  scale_color_gradient2(low = "#377eb8", 
                         high = "#e41a1c", 
                         mid = "grey80", midpoint = 0.5) +
  scale_fill_gradient2(low = "#377eb8", 
                         high = "#e41a1c", 
                         mid = "grey80", midpoint = 0.5) +
  # ylim(c(-1, 1)) +
  fer_theme +
  theme(legend.position = "none", 
        plot.margin = grid::unit(c(5,2,2,0), "mm"))

ball_correllations <- function(drivers, var){
  drivers %>%
  dplyr::filter(study == "ballantyne",
                count == "visitation" | count == "importance") %>% 
  plyr::ddply(c("threshold"), function(x){
    c <- x %>% 
      dplyr::mutate(type_count = interaction(type, count)) %>%
      dplyr::select_("species", var, "type_count") %>%
      dplyr::arrange(species) %>%
      tidyr::spread_("type_count", var) %>%
      dplyr::select(-species) %>%
      as.matrix() %>%
      cor(method = "spearman")
    
    c[lower.tri(c, diag = T)] <- NA
    
      c %>%
        as.data.frame.table() %>%
        dplyr::filter(!is.na(Freq)) %>%
        tidyr::separate(Var1, c("type1", "count1"), 
                        sep = "\\.", remove = F) %>%
        tidyr::separate(Var2, c("type2", "count2"), 
                        sep = "\\.", remove = F) %>%
        dplyr::mutate(comp = paste(Var1, Var2, sep = "_"))
  })
}

correlations <- ball_correllations(drivers, "d_reim")

# p2 <- 
  correlations %>% 
  # dplyr::filter(type1 != type2) %>%
  ggplot(aes(x = threshold, y = Freq)) +
  geom_point(size = 1) +
  geom_line(aes(colour = comp)) +
  fer_theme +
  theme(plot.margin = grid::unit(c(11.2,1,2,0), "mm")) +
  geom_smooth()

multiplot(p1, p2, layout = matrix(c(1, 1, 2), ncol = 3))

@


First we assessed the impotance of each explanatory variable individually. We included the most relevant subset into a more detailed analysis that included first order interactions between them. 

\begin{figure}
\centering
<<fig species, echo = FALSE, warning = F, message = F, fig.height=2.2, fig.width=6.49>>=
data_pol <- mod[[1]]@objects[[1]]$data
data_pla <- mod[[2]]@objects[[1]]$data

expand.grid(d = seq(min(data_pol$d), max(data_pol$d), by = 1),
            S_d = seq(min(data_pol$S_d), max(data_pol$S_d), length = 20), 
            n = seq(min(data_pol$n), max(data_pol$n), length = 3), 
            S_v = mean(data_pol$S_v)) %>%
  dplyr::mutate(q = predict.glmulti(mod[[1]], 
                                    select = 0.95, 
                                    newdata = .)$averages %>%
                  as.vector(), 
                p = plogis(q)) %>%
  dplyr::mutate(n = factor(n, 
                           levels = seq(min(data_pol$n), max(data_pol$n), length = 3),
                           labels = c("low", "mean", "high"))) %>%
  ggplot(aes(x = d, y = S_d, z = p)) +
  geom_tile(aes(fill = p)) +
  scale_fill_gradient(name = "relative\nimportance", high = "#f0f0f0", low = "#525252") +
  scale_x_continuous(expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  facet_wrap(~n) +
  xlab("degree") +
  ylab("strength of dependencies") +
  stat_contour(colour = "black", size = 0.25) +
  fer_theme

@
\caption{\label{fig:prediction} aSS }
\end{figure}

\section{Visitation as a proxy for species interdependence}

\subsubsection*{Visitation as a proxy for species interdependence}

Visitation frequency has been shown to be an appropriate surrogate for inter-specific effects in pollination networks \autocite{Vazquez2005, Bascompte2006}. Arguably, visitation reflects adequately the dependency of animals to plants, as usually during a visit animals forage for pollen or nectar regardless of wether effective pollination occurs\todo{any citation Daniel?}. Nevertheless visitation is not equivalent to pollen deposition and might be insufficient to reflect the dependencies of plants on animals \autocite{Alarcon2010, King2013}. We therefore investigated the effect of calculating the dependencies using pollination effectiveness and importance---two metrics more proximate to plant reproductive sucess.

Pollinator efficiency is measured as ``the number of conspecific pollen grains deposited on a virgin stigma during a single visit by a particular animal'' \autocite{NeEman2010}. Pollinator importance on the other hand is defined as the product between visitation frequency and pollinator efficency \autocite{Ballantyne2015}. We used data collected by \textcite{Ballantyne2015} from a low diversity pollination community at a dry lowland heathland in Dorset, UK. We assessed the differences between visitation, pollinator effectiveness, and pollinator importance by comparing (i) the manageability of the community and (ii) the percentage of interactions that mantained the direction of dependency.

The number of driver species in a pollination community and the relative importance of each species depend both of the strength of mutual dependencies between plant pollinators and the structure of the pollination network. Traditionally pollination networks have been constructed on the basis of visitation frequency, but not all flower visitor are necessarily a pollinator. It has been shown that whether or not pollination networks are represented using visitation or actual pollen deposition can have effects on the network structure and presumably on the strength of mutuial dependency \autocite{Alarcon2010}. 

We investigated the effects of using visitation, pollen deposition (effective pollination) and pollinator importance (the product of visitation frequency and effective single visit pollen deposition). We used available data collected by \textcite{Ballantyne2015} from a low diversity pollination community at a dry lowland heathland in Dorset, UK (50° 43.7'N 2° 07.2'W).

Deposition networks were quantified using the mean Single Visit Deposition---the number of conspecific pollen grains effectively deposited on a virgin stigma during a single visit by a particular animal \autocite{NeEman2010,King2013,Ballantyne2015}. Visitation networks were constructed counting the visits to flowers during Single Visit Depositions. Pollinator importance networks were consrtucted as the product of pollinator efficiency and visit frequency. 

<<get n_driver, echo = FALSE, warning = F, message = F>>=
n_driver <- meta %>%
  dplyr::inner_join(n_matched) %>% 
  dplyr::mutate(n_driver = 1 - n_matched / (n_pla + n_pol))
@

We first investigated the effects at a network scale. Despite marked differences in the distribution of weights of the three networks (\autoref{fig:ballantyne-ntw}), the minimum number of driver species to control the whole community was consistent among the three different approaches (\Sexpr{1-round(n_driver$n_driver[n_driver$net_name == "bal_eff"], digits = 2)} for deposition, \Sexpr{1-round(n_driver$n_driver[n_driver$net_name == "bal_vis"], digits = 2)} for the visitation, and \Sexpr{1-round(n_driver$n_driver[n_driver$net_name == "bal_imp"], digits = 2)} for the pollinator importance network).

\begin{figure}
\centering
<<matrix representation, echo = FALSE, warning = F, message = F, fig.height=4, fig.width=5.5>>=
p <- net[meta$net_name[meta$study == "ballantyne" & meta$count != "binary"]] %>%
	plyr::ldply(function(x) {
		data.frame(vname = igraph::E(x) %>% attr("vnames"), 
							weight = igraph::E(x)$weight)
	}, .inform = T) %>%
	dplyr::rename_("net_name" = ".id") %>%
	dplyr::mutate(net_name_f = factor(net_name,  
																		levels = c( 'bal_eff','bal_vis','bal_imp'),
																		labels = c("a) Deposition", "b) Visitation", "c) Importance")), 
	              pla = stringr::str_split_fixed(vname, "\\|", 2)[, 1],
	              pol = stringr::str_split_fixed(vname, "\\|", 2)[, 2]) %>%
  plyr::dlply("net_name_f", function(x){
    p1 <- x %>%
      ggplot(aes(x = pol, y = pla)) +
      geom_tile(aes(fill = weight, width = 0.9, height = 0.9)) + 
      coord_fixed() +
      scale_fill_gradient(low = "#f0f0f0", high = "#525252") +
      ylab("plants") +
      xlab("pollinators") + 
      fer_theme +
      theme(axis.text = element_blank(), 
            axis.ticks = element_blank(), 
            legend.position = "right", 
            legend.title = element_blank(), 
            plot.margin = grid::unit(c(6,0,2,5), "mm"),
            panel.grid = element_blank(),
            legend.key.width = grid::unit(4, "mm"),
            legend.key.height = grid::unit(4, "mm"))
    p2 <- x %>% ggplot(aes(x = weight)) +
      scale_x_log10() +
      stat_density(aes(y =..density..), geom = "line") +
      xlab("link weight") + 
      ylab("density") +
      ggtitle(x$net_name_f[1]) +
      fer_theme +
      theme(plot.margin = grid::unit(c(2,2,0,0), "mm"))
    list(p1, p2)
  }) 

multiplot(p[[1]][[2]], p[[1]][[1]], p[[2]][[2]], p[[2]][[1]], p[[3]][[2]], p[[3]][[1]], layout = matrix(c(1,2,2,3,4,4,5,6,6), ncol = 3, byrow = T))  
@
\caption{\label{fig:ballantyne-ntw} Distribution of interaction weights for the pollen deposition, visitation and pollinator importance networks. Note that the \textit{x} axis in the density plots have been log-transformed}
\end{figure}

The choice of weighting used can also have an impact on the realtive importance of species. Therefore we calculated the frequency that each species is present in the possible sets of driver species under the three schemes. Although visitation and deposition produce strikingly different results, we found a very strong agreement between the order produced by visitation and importance (\autoref{table:corr_weights}). Arguably, visitation best reflects the dependency of animals to plants, as usually animals forage for pollen or nectar regardless of wether effective pollination occurs or not. Contrastingly, importance, the product between visit frequency and pollinator effectiveness, best relefect the dependency of plants to animals. 

\begin{table}
\centering
\small
<<table correlations, echo = FALSE, warning = F, message = F, results = "asis">>=
drivers_b <- m_f[meta$net_name[meta$study == "ballantyne"]] %>%
	plyr::ldply(function(x){
	  dplyr::data_frame(species = names(x),
	                    d_freq = attr(x, "n_matchings") - x,
	                    d_reim = 1 - x / attr(x, "n_matchings"),
	                    d_rank = rank(d_reim, ties.method = "average"))
	}) %>%
	dplyr::rename_("net_name" = ".id")

correlations <- drivers_b %>%
  dplyr::select(net_name, species, d_freq) %>%
  tidyr::spread(net_name, d_freq) %>%
  dplyr::select(-species) %>%
  as.matrix() %>%
  Hmisc::rcorr(type = "spearman")


my_paste <- function(x, y){
  if(is.na(y)) return ("-")
  b <- ""
  if(y < 0.05) b <- ""
  paste0(b, round(x, digits = 2), " (", round(y, digits = 4), ")", b)
}

dir_net_b <- net[meta$net_name[meta$study == "ballantyne"]] %>%
  lapply(function(x){
    x %>% 
      bipartite_digraph(type = "weight", keep = "all") %>%
      igraph::ends(igraph::E(.)) %>% 
      apply(1, function(y) paste(y[1], y[2]))
  })

# same order as the correlations 
dir_net_b <- dir_net_b[colnames(correlations$P)]

lt <- combn(length(dir_net_b), 2) %>%
  apply(2, function(x){
    length(intersect(dir_net_b[[x[1]]], dir_net_b[[x[2]]])) /
      length(igraph::E(net[[1]]))
  }) %>%
  magrittr::multiply_by(100) %>% round() %>% paste0("%")

nam <- c("unweighted","deposition", "importance", "visitation")

mapply(my_paste, correlations$r, correlations$P) %>%
  matrix(ncol = length(dir_net_b)) %>% magrittr::set_colnames(nam) %>%
  magrittr::set_rownames(nam) %>% `[<-`(lower.tri(.), lt) %>% 
  kable(align = "c", format = "latex", booktabs = T)
@
\caption{\label{table:corr_weights} Spearman correlation coefficients (with p-value) of the relative importance of species and the percentage of interactions that share the direction of dependency obtained using the three weighting schemes and an unweighted scheme. Significant correlations are highlighted in bold.}
\end{table}

Finally, we investigated whether the asymmetry of mutual dependency, which defines the direction of control, was consistent among the three posible weighting schemes. We found again that the direction of the dominant dependency was mantained was consistent for 95\% of the interactions weighted by visitation or importance (\autoref{table:corr_weights}), the two most appropriate metrics for pollinator and plant dependency.

All together, evidence supports the idea that visitation is a suitable metric to estimate the mutual dependency of species pairs. First it is directly related to pollinator foraging. Second it produces results consistent, at least within our controllability framework, with plant reproductive success (as estimated by the importance metric).




\printbibliography

\end{document}