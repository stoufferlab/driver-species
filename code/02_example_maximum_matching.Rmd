---
title: "Calculating all possible maximum matchings"
author: "Fernando Cagua"
date: "2 September 2015"
output: html_document
---

```{r, echo = FALSE, message=FALSE, warning=FALSE}
library(dplyr)
library(magrittr)
library(igraph)
library(ggplot2)
library(knitr)

opts_knit$set (root.dir=normalizePath('../'))
opts_chunk$set (fig.path = "./figures/02/")
opts_chunk$set (cache.path = "./cache/02/")
opts_chunk$set (fig.width = 11, 
                fig.height = 6,
                out.width = "858px")
```

```{r, echo = FALSE, results = "hide", message=FALSE, warning=FALSE}
list.files("./code/functions", full.names = TRUE) %>% lapply(source)
```

I'm interested in investingating the relative importance of different nodes (and edges) for the controlability of bipartite networks. 

# 1. All maximum matchings

One option is to see how many times the node is selected as a driver node based on all the possible maximum matchings on a bipartite network

## Find them first

Here I show how to calculate the bipartite maximum matchings of an arbitrary bipartite graph.

### Create the graph

```{r, warning = FALSE}
g <- graph_from_literal( a-b-c-d-e-f-a, a-d, g-f, h, i-f, j-k-h)
V(g)$type <- c(FALSE,TRUE)
g %>%	add_layout_(as_bipartite()) %>%	plot()
```

### Calculate a maximum bipartite matching

```{r}
match <- max_bipartite_match(g) 
print(match)
```

This give use the size of the matching, this is how many nodes can be matched on each side. 

### Make the line graph of the bipartite network

Which is the an alternative representation in which edges become nodes and there is a link between them if they share a node in the original network

```{r}
h <- g %>% igraph::make_line_graph() %T>% plot
```

### Get the complementer graph of the line graph

Which is equivalent of changing all 0s for 1s and all 1s for 0s in the adjacency matrix

```{r}
h <- h %>% igraph::complementer() %T>% plot
```

### Find all the cliques that have the same size as the maximum matching found before

```{r}
cli <- h %>% igraph::max_cliques(min = match$matching_size)
cli <- unlist(cli) %>% matrix(ncol = match$matching_size, byrow = TRUE)
print(cli)
```

Let's have a look!!!

At five of them...

```{r, fig.height= 5}
matchings <- apply(cli, 1, function(x) {
	y <- rep(1, length(E(g)))
	y[x] <- 2
	y
})

plyr::a_ply(matchings[, round(seq(1,20, length.out = 5))], 2, function(x){
	p <- g %>%	add_layout_(as_bipartite()) %>%	plot.igraph(edge.color = x)
})
```

## Analyse importance

On posibility is to rank nodes by how many times they act as driver nodes in all maximum matchings in the network. Here we assume that we only want to match the nodes on "top"

```{r}
node_relev_m <- get_matched_vertex(g, choosen_type = FALSE, 
									 matchings = cli, output = "data.frame") %>%
	dplyr::group_by(v) %>%
	dplyr::summarise(freq = sum(!matched))

node_relev_m %>%
	ggplot() +
	geom_point(aes(x = v, y = freq), shape = 21, size = 4) +
	xlab("vertex") +
	ylab("frequency of acting as a driver node") +
	theme_bw()
```

# 2. By removing links/nodes

Another alternative to determine the relative importance of each node (but also links) is to remove it and see how it affects the matching. Following Liu, Slotine and Barabasi 2011, for links we have the following definitions:

1. **Critical** if in it's absense we need to increase the number of driver nodes to maintain full control of the system
2. **Redundant** if it can be removed without affecting the current set of driver nodes
3. **Ordinary** if it's neither critical nor redundant, i.e., its removal can eliminate some control configurations, but the network can still be controlable in its absense 

for nodes we have the following definitions

1. **Critical** if in it's absense we need to increase the number of driver nodes to maintain full control of the system
2. **Redundant** if it after removal the current set of driver nodes decreasses
3. **Ordinary** if after removal the number of driver nodes is maintained

We wan't to see if these definitions (particularly for the nodes) agree with the measssures given by the maxumum matchings. 

Let's use the same dummy network as before. 

```{r, warning = FALSE}
g %>%	add_layout_(as_bipartite()) %>%	plot()
```

### Calculate a maximum bipartite matching

```{r}
match <- max_bipartite_match(g) 
this_side_nodes <- length(V(g)[type == F])
min_drivers <- this_side_nodes - match$matching_size
print(match)
```

## Importance for links

```{r}
plyr::ldply(E(g), function(x){
	matching_size <- g %>% delete_edges(x) %>%
		max_bipartite_match() %$%
		matching_size
	data.frame(e = x, matching_size = matching_size)
}) %>%
	dplyr::mutate(delta_drivers = this_side_nodes - matching_size - min_drivers,
								categ = categ_link(delta_drivers))
```

Well this is boring. All edges are redundant

## Importance for nodes

```{r}
node_relev_c <- plyr::ldply(V(g), function(x){
	matching_size <- g %>% delete_vertices(x) %>%
		max_bipartite_match() %$%
		matching_size
	data.frame(v = x, matching_size = matching_size)
}) %>%
	dplyr::mutate(delta_drivers = this_side_nodes - matching_size - min_drivers,
								categ = categ_node(delta_drivers)) %T>% print
```

This not as boring :) We can see that some are redundant ordinary and some are critical (there is no redundant one). 

# Compare 

```{r}
dplyr::inner_join(node_relev_m, node_relev_c, by = c("v" = ".id")) %>%
	ggplot() +
	geom_point(aes(x = v, y = freq, fill = categ), shape = 21, size = 4) +
	xlab("vertex") +
	ylab("frequency of acting as a driver node") +
	theme_bw()
```

Well now I realise this network was a crappy example. Obviously removing R decreasses the matching... But I don't think that'll happen using the proper bipartite matching (this is having head vertices in one side and tail vertices in the other). Especially because f, d, and b were also critical. 

Still this is a good proof of concept of what will come for the other networks